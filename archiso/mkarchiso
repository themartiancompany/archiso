#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later

set -e -u
shopt -s extglob

# Control the environment
umask 0022
export LC_ALL="C.UTF-8"
if [[ -v LANGUAGE ]]; then
    # LC_ALL=C.UTF-8, unlike LC_ALL=C, does not override LANGUAGE.
    # See https://sourceware.org/bugzilla/show_bug.cgi?id=16621 and https://savannah.gnu.org/bugs/?62815
    unset LANGUAGE
fi
[[ -v SOURCE_DATE_EPOCH ]] || printf -v SOURCE_DATE_EPOCH '%(%s)T' -1
export SOURCE_DATE_EPOCH

# Set application name from the script's file name
app_name="${0##*/}"

# Define global variables. All of them will be overwritten later
pkg_list=()
bootstrap_pkg_list=()
quiet=""
work_dir=""
out_dir=""
gpg_key=""
gpg_sender=""
gpg_home=""
iso_name=""
iso_label=""
iso_publisher=""
iso_application=""
iso_version=""
isofs_dir=""
install_dir=""
arch=""
pacman_conf=""
packages=""
bootstrap_packages=""
pacstrap_dir=""
keys_dir=""
buildmodes=()
bootmodes=()
xorriso_options=()
xorrisofs_options=()
dongle_isofs_dir=""
dongle_xorriso_options=()
dongle_xorrisofs_options=()
cert_list=()
sign_netboot_artifacts=""
declare -A file_permissions=()
fs_images=(
    'airootfs'
    'persistent'
    'keys'
    'swap'
    'dongle_boot'
    'dongle_persistent'
    'dongle_swap'
    'recovery'
    'efi_boot')
fs_images_str_vars=(
    'dir'
    'image_type'
    'image_tool_options'
    'img'
    'size' # All sizes are in kib
    'encryption_key')
fs_images_arr_vars=('files'
                    'image_tool_options')
_img=""
for _img in "${fs_images[@]}"; do
    for _var in "${fs_images_str_vars[@]}"; do
        eval "${_img}_${_var}=''"
    done
    for _var in "${fs_images_arr_vars[@]}"; do
        eval "${_img}_${_var}=()"
    done
done
# adapted from GRUB_EARLY_INITRD_LINUX_STOCK in https://git.savannah.gnu.org/cgit/grub.git/tree/util/grub-mkconfig.in
readonly ucodes=('intel-uc.img' 'intel-ucode.img' 'amd-uc.img' 'amd-ucode.img' 'early_ucode.cpio' 'microcode.cpio')

# Constants
epoch_namespace="93a870ff-8565-4cf3-a67b-f47299271a96"
luks_guid="CA7D7CCB-63ED-4C53-861C-1742536059CC"
linux_guid="0FC63DAF-8483-4772-8E79-3D69D8477DE4"
swap_guid="0657fd6d-a4ab-43c4-84e5-0933c84b4f4f"
_PI=$((3 * 1415))
_E=$((2 * 71828))
_EL=$((42 * 69))
_RO=$((16 * 1803))
_airootfs_const=0
_dongle_const="${_EL}"
_boot_const="${_RO}"
_persistent_const="${_PI}"
_swap_const="${_E}"
_dongle_boot_const=$((_dongle_const + _boot_const))
_dongle_persistent_const=$((_dongle_const + _persistent_const))
_dongle_swap_const=$((_dongle_const + _swap_const))
_keys_const=$((_dongle_const + _boot_const + _persistent_const))
_recovery_const=$((_dongle_const + _boot_const + _keys_const))

# Show an INFO message
# $1: message string
_msg_info() {
    local _msg="${1}"
    [[ "${quiet}" == "y" ]] || printf '[%s] INFO: %s\n' "${app_name}" "${_msg}"
}

# Show a WARNING message
# $1: message string
_msg_warning() {
    local _msg="${1}"
    printf '[%s] WARNING: %s\n' "${app_name}" "${_msg}" >&2
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
_msg_error() {
    local _msg="${1}"
    local _error=${2}
    printf '[%s] ERROR: %s\n' "${app_name}" "${_msg}" >&2
    if (( _error > 0 )); then
        exit "${_error}"
    fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
    IFS='' read -r -d '' usagetext <<ENDUSAGETEXT || true
usage: ${app_name} [options] <profile_dir>
  options:
     -A <application> Set an application name for the ISO
                      Default: '${iso_application}'
     -C <file>        pacman configuration file.
                      Default: '${pacman_conf}'
     -D <install_dir> Set an install_dir. All files will by located here.
                      Default: '${install_dir}'
                      NOTE: Max 8 characters, use only [a-z0-9]
     -L <label>       Set the ISO volume label
                      Default: '${iso_label}'
     -P <publisher>   Set the ISO publisher
                      Default: '${iso_publisher}'
     -c [cert ..]     Provide certificates for codesigning of netboot artifacts
                      Multiple files are provided as quoted, space delimited list.
                      The first file is considered as the signing certificate,
                      the second as the key.
     -g <gpg_key>     Set the PGP key ID to be used for signing the rootfs image.
                      Passed to gpg as the value for --default-key
     -G <mbox>        Set the PGP signer (must include an email address)
                      Passed to gpg as the value for --sender
     -H <gpg_home>    Set the gpg home directory.
     -h               This message
     -m [mode ..]     Build mode(s) to use (valid modes are: 'bootstrap', 'iso' and 'netboot').
                      Multiple build modes are provided as quoted, space delimited list.
     -o <out_dir>     Set the output directory
                      Default: '${out_dir}'
     -p [package ..]  Package(s) to install.
                      Multiple packages are provided as quoted, space delimited list.
     -v               Enable verbose output
     -w <work_dir>    Set the working directory (can't be a bind mount).
                      Default: '${work_dir}'

  profile_dir:        Directory of the archiso profile to build
ENDUSAGETEXT
    printf '%s' "${usagetext}"
    exit "${1}"
}

# Shows configuration options.
_show_config() {
    local build_date
    TZ=UTC printf -v build_date '%(%FT%R%z)T' "${SOURCE_DATE_EPOCH}"
    _msg_info "${app_name} configuration settings"
    _msg_info "             Architecture:   ${arch}"
    _msg_info "        Working directory:   ${work_dir}"
    _msg_info "   Installation directory:   ${install_dir}"
    _msg_info "               Build date:   ${build_date}"
    _msg_info "         Output directory:   ${out_dir}"
    _msg_info "       Current build mode:   ${buildmode}"
    _msg_info "              Build modes:   ${buildmodes[*]}"
    _msg_info "                  GPG key:   ${gpg_key:-None}"
    _msg_info "               GPG signer:   ${gpg_sender:-None}"
    _msg_info "                 GPG Home:   ${gpg_home:-None}"
    _msg_info "           Encryption Key:   ${airootfs_encryption_key:-None}"
    _msg_info "Code signing certificates:   ${cert_list[*]:-None}"
    _msg_info "                  Profile:   ${profile}"
    _msg_info "Pacman configuration file:   ${pacman_conf}"
    _msg_info "          Image file name:   ${image_name:-None}"
    _msg_info "         ISO volume label:   ${iso_label}"
    _msg_info "            ISO publisher:   ${iso_publisher}"
    _msg_info "          ISO application:   ${iso_application}"
    _msg_info "               Boot modes:   ${bootmodes[*]:-None}"
    _msg_info "            Packages File:   ${buildmode_packages}"
    _msg_info "                 Packages:   ${buildmode_pkg_list[*]}"
}

# Cleanup airootfs
_cleanup_pacstrap_dir() {
    local _images=("initramfs-*" "vmlinuz-*" "${ucodes[@]}")
    local _root="${pacstrap_dir}"
    local _boot="${_root}/boot"
    local _log="${pacstrap_dir}/var/log"
    local _machine_id="${pacstrap_dir}/etc/machine-id"
    local _pacman_db="${_root}/var/lib/pacman"
    local _pacman_cache="${_root}/var/cache/pacman/pkg"
    local _tmp="${pacstrap_dir}/var/tmp"
    local _cp_opts=('-af' '--no-preserve=ownership,mode')
    _msg_info "Cleaning up in pacstrap location..."

    # Move kernel, initramfs and microcodes for later usage
    install -d -m 0755 "${work_dir}/boot" 
    for _query in "${_images[@]}"; do
        find "${_boot}" -iname "${_query}" -exec cp "${_cp_opts[@]}" {} "${work_dir}/boot" \; -quit
    done
    [[ -d "${_boot}" ]] && find "${_boot}" -maxdepth 1 -type f -delete
    # Delete pacman database sync cache files (*.tar.gz)
    [[ -d "${_pacman_db}" ]] && find "${_pacman_db}" -maxdepth 1 -type f -delete
    # Delete pacman database sync cache
    [[ -d "${_pacman_db}/sync" ]] && find "${_pacman_db}/sync" -delete
    # Delete pacman cache files
    [[ -d "${_pacman_cache}" ]] && find "${_pacman_cache}" -type f -delete
    # Delete all log files, keeps empty dirs.
    [[ -d "${_log}" ]] && find "${_log}" -type f -delete
    # Delete all temporary files and dirs
    [[ -d "${_tmp}" ]] && find "${_tmp}" -mindepth 1 -delete
    # Delete package pacman related files.
    find "${work_dir}" \( -name '*.pacnew' -o -name '*.pacsave' -o -name '*.pacorig' \) -delete
    if [[ "${persistent_size}" != "" ]]; then
        dbus-uuidgen --ensure="${_machine_id}"
    else
        # Create an empty /etc/machine-id
        rm -f -- "${_machine_id}"
        printf '' > "${_machine_id}"
    fi
    _msg_info "Done!"
}

# Creates a squashfs image from a file system image or directory.
# $1: directory or a file system image
# $2: path of the result image
_run_mksquashfs() {
    local _directory_or_fs="${1}"
    local _image_path="${2}"
    local mksquashfs_options=("${_mkfs_options[@]}")
    [[ ! "${quiet}" == "y" ]] || mksquashfs_options+=('-no-progress' '-quiet')
    _msg_info "Creating SQUASHFS image, this may take some time..."
    mksquashfs "${_directory_or_fs}" "${_image_path}" -noappend "${mksquashfs_options[@]}"
}

# Creates an ext4 image of given size from a directory with the same name in the same path.
# $1: directory to put into the image
# $2: size of the resulting image
# $3: UNIX time (to generate a date-based uuid)
# $4: partition label
# $5: if true the file system image will be writable
_run_mkext4() {
    local _dir="${1}"
    local _image_path="${1}.img"
    local _size="${2}"
    local _epoch="${3}"
    local _label="${4}"
    local _writable="${5}"
    local ext4_hash_seed _fsuuid mkfs_ext4_options=()
    _fsuuid="$(_epoch_to_uuid "${_epoch}")"

    _msg_info "Creating ext4 image"
    _msg_info "Size: ${_size} KB"
    _msg_info "Directory: ${_dir}"
    _msg_info "Image path: ${_image_path}"
    _msg_info "UUID: ${_fsuuid}"
    _msg_info "Label: ${_label}"
    _msg_info "this may take a while..."

    ext4_hash_seed="$(uuidgen --sha1 \
                              --namespace ${epoch_namespace} \
                              --name "${_epoch} ext4 hash seed")"
    mkfs_ext4_options=('-d' "${_dir}"
                       '-O' '^has_journal,^resize_inode'
                       '-E' "lazy_itable_init=0,root_owner=0:0,hash_seed=${ext4_hash_seed}"
                       '-m' '0'
                       '-F'
                       '-b' 4096
                       '-U' 'clear')
    [[ "${_label}" != "" ]] && mkfs_ext4_options+=('-L' "${_label}")
    [[ ! "${quiet}" == "y" ]] || mkfs_ext4_options+=('-q')
    rm -f -- "${_image_path}"
    if [[ ! "${quiet}" == "y" ]]; then
        E2FSPROGS_FAKE_TIME="${_epoch}" mkfs.ext4 "${mkfs_ext4_options[@]}" -- "${_image_path}" "${_size}K"
    else
        E2FSPROGS_FAKE_TIME="${_epoch}" mkfs.ext4 "${mkfs_ext4_options[@]}" -- "${_image_path}" "${_size}K" > /dev/null 2>&1
    fi
    tune2fs -c 0 -i 0 -- "${_image_path}" > /dev/null
    if [ "${_writable}" != "true" ]; then
        tunefs -O read-only "${_image_path}"
    fi
    _msg_info "Done!"
}

# Creates an EROFS image given a directory.
# $1: resulting image
# $2: input directory
# $3: UNIX time (to generate a date-based uuid)
_run_mkerofs() {
    local _image_path="${1}"
    local _dir="${2}"
    local _epoch="${3}"
    local fsuuid
    fsuuid="$(_get_epoch_fsuuid "${_epoch}")"
    [[ ! "${quiet}" == "y" ]] || mkfs_erofs_options+=('--quiet')
    _msg_info "Creating EROFS image"
    _msg_info "Directory: ${_dir}"
    _msg_info "Image path: ${_image_path}"
    _msg_info "UUID: ${fsuuid}"
    _msg_info "this may take a while..."
    mkfs_erofs_options+=('-U' "${fsuuid}" "${_mkfs_options[@]}")
    mkfs.erofs "${mkfs_erofs_options[@]}" -- "${_image_path}" "${_dir}"
    _msg_info "Done!"
}

# Creates a swap image
# $1: resulting image
# $2: image size
# $3: UNIX time (to generate a date-based uuid)
# $4: partition label
_run_mkswap() {
    local _image_path="${1}"
    local _size="${2}"
    local _epoch="${3}"
    local _label="${4}"
    local _fsuuid
    _fsuuid="$(_get_epoch_fsuuid "${_epoch}")"
    dd if=/dev/zero of="${_image_path}" bs=1K count="${_size}" status=progress
    chmod 0600 "${_image_path}"
    sync
    mkswap -L "${_label}" -U "${_fsuuid}" "${_image_path}"
}

# Creates and opens a RAID device
# $1: RAID name
# $2: RAID type (only '1' for now)
_run_mkraid() {
    # local _image_path="${1}"
    # local _dev_path="${1}"
    local _name="${1}"
    # local _size="${2}" # should go into the array
    local _type="${2}"
    shift 3
    local _devices=("$@")
    mdadm --create "/dev/md${_name}.map" \
          --level="${_type}" \
          --run \
          "${_devices[@]}"
}

# Creates and opens a LUKS image of the size of the pacstrap directory plus 200MB.
# $1: image to write on
# $2: partition size
# $3: encryption key
# $4: UNIX time (to generate a date-based uuid)
# $5: partition label
# $6: if true, the partition will be writable
# $7: if true, dm-verity layer will be disabled to be able to be opened by GRUB
_run_mkluks() {
    local _image_path="${1}"
    local _size="${2}"
    local _encryption_key="${3}"
    local _epoch="${4}"
    local _label="${5}"
    local _writable="${6}"
    local _grub="${7}"
    local _fsuuid
    local _fallocate_opts=('--length' "${_size}K")
    local _activation_opts=() _format_opts=() _fallocate_msg="" _key_msg="" _mapper
    local _fallocate_posix_error="fallocate: fallocate failed: Operation not supported" 
    local _key_size='512'
    local _sector_size='4096'
    local _pbkdf_memory='256'
    local _cryptsetup_opts=('--type' 'luks2'
                            '--timeout=69042')
    _mapper=$(basename "${_image_path}")".map"
    image_device="/dev/mapper/${_mapper}"
    _key_opts=()
    _fsuuid="$(_get_epoch_fsuuid "${_epoch}")"

    if [[ "${_encryption_key}" != "" ]]; then
        _key_opts=("--key-file=${_encryption_key}")
        _cryptsetup_opts+=("${_key_opts[@]}")
        _key_msg="with key $(basename "${_encryption_key}")"
    fi

    _activation_opts+=("${_cryptsetup_opts[@]}")
    _format_opts+=("${_cryptsetup_opts[@]}" \
        '--sector-size' "${_sector_size}" \
        '--key-size' "${_key_size}")

    # Remove as soon as gcrypt adds support for argon2i
    # and GRUB for the dm-integrity layer
    if [ "${_grub}" == "true" ]; then
        _format_opts+=('--pbkdf' 'pbkdf2')
    else
        _format_opts+=('--pbkdf-memory' "${_pbkdf_memory}"
                       '--integrity' 'hmac-sha512')
    fi

    if [ "${_writable}" != "true" ]; then
        _msg_info "Integrity journal disabled"
        _activation_opts+=('--persistent' \
                           '--integrity-no-journal' \
                           '--key-size' "${_key_size}")
    fi

    _msg_info "Creating LUKS image $(basename "${_image_path}") with cryptsetup (${_size}KB) ${_key_msg}"
    _fallocate_opts+=("$(_validate_fallocate_opts "${_image_path}")")
    fallocate "${_fallocate_opts[@]}" "${_image_path}"
    while ! eval "cryptsetup -q -y luksFormat ${_format_opts[*]} ${_image_path}"; do
        sleep 1
    done

    _msg_info "Setting label ${_label}"
    while ! eval "cryptsetup config ${_cryptsetup_opts[*]} ${_image_path} --label ${_label}"; do
        _close_luks_device "${image_device}"
    done

    _msg_info "Setting UUID ${_fsuuid}"
    while ! eval "cryptsetup -q -y luksUUID --uuid ${_fsuuid} ${_image_path}"; do
        _close_luks_device "${image_device}"
    done

    _close_luks_device "${image_device}"

    _msg_info "Opening device on mapper ${_mapper}"
    while ! eval "cryptsetup ${_activation_opts[*]} open ${_image_path} ${_mapper}"; do
        _close_luks_device "${image_device}"
    done
    _msg_info "Done!"
}

# Determines correct fallocate options for an image at a chosen path
# $1: path of the fallocate resulting image to verify options for
_validate_fallocate_opts() {
    local _image_path="${1}"
    local _fallocate_posix_error="fallocate: fallocate failed: Operation not supported"
    local _fallocate_msg
    _fallocate_msg="$(fallocate -l "100K" "${_image_path}.test" 2>&1)" 
    if [ "${_fallocate_msg}" == "${_fallocate_posix_error}" ]; then
        rm "${_image_path}.test"
        echo '--posix' 
    elif [ "${_fallocate_msg}" != "" ]; then
        _msg_error "${_fallocate_msg}" 1
    fi
}

# Closes a LUKS device mapper
# $1: device mapper to close
_close_luks_device() {
    local _device="${1}"
    local _mapper
    _mapper=$(basename "${_device}")
    blockdev --flushbufs "${_device}" > /dev/null 2>&1 || true
    cryptsetup luksClose "${_mapper}" > /dev/null 2>&1 || true
    if [ -e "${_device}" ]; then
        dmsetup remove "${_device}" > /dev/null 2>&1 || true
    fi
    sync
}

# Prompts a passphrase to be used as key for a partition
# $1: partition name
# $2: partition label
_ask_passwd() {
    local _name="${1}"
    local _label="${2}"
    local _prompt_cmd _mismatch_cmd="echo"
    local _ask_passwd_opts=("--timeout=69042")
    local _ask_passwd_msg="Insert new passphrase for ${_name} (${_label}): "
    local _ask_passwd_confirm_msg="Confirm: "
    local _mismatch_opts=()
    local _mismatch_msg="Passwords mismatch."
    local _confirm
    if command -v zenity &> /dev/null && [ -n "${DISPLAY}" ]; then
        _prompt_cmd=$(which zenity)
        _mismatch_cmd="${_prompt_cmd}"
        _ask_passwd_opts+=("--password")
        _mismatch_opts+=("--info" "--icon" "dialog-password" "--text")
    else
        _prompt_cmd=$(which systemd-ask-password)
    fi
    local _prompt=("${_prompt_cmd}" "${_ask_passwd_opts[@]}")
    local _mismatch=("${_mismatch_cmd}" "${_mismatch_opts[@]}" "${_mismatch_msg}")
    while true; do
        _passphrase=$("${_prompt[@]}" "${_ask_passwd_msg}")
        echo "${_ask_passwd_confirm_msg}"
        _confirm=$("${_prompt[@]}" "${_ask_passwd_confirm_msg}")
        [[ "${_passphrase}" == "${_confirm}" ]] && break
        "${_mismatch[@]}"
    done
}

# Steps shared by the mkimg+<fs_image_type> functions
# $1: name for the device mapper
# $2: an encryption key (prompts for one if empty)
# $3: partition label
_mkluks_common() {
    local _name="${1}"
    local _key="${2}"
    local _label="${3}"
    local _out="${work_dir}/${_label}.key"
    if [ "${_key}" = "" ]; then
        _ask_passwd "${_name}" "${_label}"
        printf "%s" "${_passphrase}" > "${_out}"
        _encryption_key="${_out}"
    elif [ "${_key}" = "auto" ]; then
        printf "%s" "$(tr -dc A-Za-z0-9 </dev/urandom | head -c 20 ; echo '')" > "${_out}"
        _encryption_key="${_out}"
    fi
}

# Creates a squash fs image.
# $1: path of the resulting image
# $2: partition size
# $3: UNIX time (for a date-based uuid)
# $4: partition label
_mkimg_swap() {
    local _image_path="${1}"
    local _size="${2}"
    local _epoch="${3}"
    local _label="${4}"
    _run_mkswap "${_image_path}" "${_size}" "${_epoch}""${_label}"
}

# Creates a swap partition inside a LUKS container image file.
# $1: device mapper name
# $2: LUKS image path
# $3: image size
# $4: encryption key
# $5: UNIX time (for a date-based uuid)
# $6: partition label
# $7: if true, dm-verity layer will be disabled to open the image from GRUB
_mkimg_swap+luks() {
    local _name="${1}"
    local _image_path="${2}"
    local _size="${3}"
    local _encryption_key="${4}"
    local _epoch="${5}"
    local _label="${6}"
    local _grub="${7}"
    local _writable="true"
    _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
    _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                "${_epoch}" "${_label}" "${_writable}" "${_grub}"
    _run_mkswap "${image_device}" "$(_get_internal_size "${_size}")" "${_epoch}" "${_name}"
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
}

# Creates an ext4 file system image
# $1: directory to use to generate the image
# $2: image path
# $3: image size
# $4: UNIX time (for a date-based uuid)
# $5: partition label
_mkimg_ext4() {
    local _dir="${1}"
    local _image_path="${2}"
    local _size="${3}"
    local _epoch="${4}"
    local _label="${5}"
    local _writable="true"
    _run_mkext4 "${_dir}" "$(_get_internal_size "${_size}")" \
                "${_epoch}" "${_label}" "${_writable}"
    mv "${_dir}.img" "${_image_path}"
    sync
    _msg_info "Done!"
}

# Creates an ext4 fs inside a LUKS container image file.
# $1: device mapper name
# $2: directory to be put onto the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a date-based uuid)
# $7: partion label
# $8: if true, the dm-verity will be disabled to let GRUB open it
_mkimg_ext4+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _grub="${8}"
    local _writable="true"
    _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
    _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                "${_epoch}" "${_label}" "${_writable}" "${_grub}"
    _run_mkext4 "${_dir}" "$(_get_internal_size "${_size}")" \
                "${_epoch}" "${_name}" "${_writable}"
    dd if="${_dir}.img" of="${image_device}" > /dev/null 2>&1
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

# Creates an ext4-formatted RAID1 on a LUKS images array
# $1: RAID name
# $2: directory to fill the RAID with
# $3: encryption key
# $4: UNIX time (to get a date-based UUID)
# $@: LUKS image paths array
_mkimg_ext4+raid1+luks() {
  local _name="${1}"
  local _dir="${2}"
  # local _image_path="${3}"
  # local _size="${4}"
  local _encryption_key="${3}"
  local _epoch="${4}"
  # local _label="${5}"
  # local _grub="${6}"
  local _writable="true"
  shift 4
  local _images=("$@")
  local _image
  for _image in "${_images[@]}"; do
      echo "${_device}"
      _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
      _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                  "${_epoch}" "${_label}" "${_writable}" "${_grub}"
  done

  for _device in "${_devices[@]}"; do
    _close_luks_device "${image_device}"
  done
}

# Creates or expand an ext4-formatted RAID array
# $1: RAID name
# $2: files to be put onto the RAID
# $@: devices, in the following format <todo>
_mkimg+ext4+raid() {
  local _name="${1}"
  local _dir="${2}"
  shift 2
  local _array=("${@}")
  _run_mkraid "${_name}"
  echo "${_array[@]}"
}

# Creates an ext4 image and packs it inside a squashfs image.
# Packs the squash image inside a LUKS image.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the image will be writable
# $9: if true, the dm-verity layer will be disabled so that the image can be opened from GRUB
_mkimg_ext4+squashfs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _writable="${8}"
    local _grub="${9}"
    _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
    _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                "${_epoch}" "${_label}" "${_writable}" "${_grub}"
    _run_mkext4 "${_dir}" "$(_get_internal_size "${_size}")" \
                "${_epoch}" "${_name}" "${_writable}"
    _run_mksquashfs "${_dir}.img" "${image_device}"
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

# Creates a squashfs image and saves it on a LUKS image.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the image will be writable
# $9: if true, the dm-verity layer will be disabled so that the image can be opened from GRUB
_mkimg_squashfs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _writable="${8}"
    local _grub="${9}"
    _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
    _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                "${_epoch}" "${_label}" "${_writable}" "${_grub}"
    _run_mksquashfs "${_dir}" "${image_device}"
    sync
    _close_luks_device "${image_device}"
}

# Creates an ext4 file system inside a squashfs image.
# $1: partition label
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: UNIX time (for a datetime-based uuid)
_mkimg_ext4+squashfs() {
    local _label="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _epoch="${5}"
    local _writable="false"
    _run_mkext4 "${_dir}" "$(_get_internal_size "${_size}")" \
                "${_epoch}" "${_name}" "${_writable}"
    _run_mksquashfs "${_dir}.img" "${_image_path}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

# Creates a squash fs image.
# $1: directory to create the squashfs image with
# $2: resulting image path
_mkimg_squashfs() {
    local _dir="${1}"
    local _image_path="${2}"
    _run_mksquashfs "${_dir}" "${_image_path}"
}

# Create an EROFS image containing the root file system and saves it on the ISO 9660 file system.
# $1: image path
# $2: directory to be put onto the image
# $3: UNIX time (for a date-based uuid)
_mkimg_erofs() {
    local _image_path="${1}"
    local _dir="${2}"
    local _epoch="${3}"
    _run_mkerofs "${_image_path}" "${_dir}" "${_epoch}"
    _msg_info "Done!"
}

# Create an EROFS image containing the root file system and saves it on the LUKS image.
# Save the LUKS image on the ISO 9660 file system.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the dm-verity layer will be disabled so that the image can be opened from GRUB
_mkimg_erofs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _grub="${8}"
    local _writable="false"
    local _tmp_img="${work_dir}/tmp.erofs" _tmp_size
    if [[ "${_size}" == "" ]]; then
	_msg_info "Running mkerofs in advance to determine LUKS partition size"
        _run_mkerofs "${_tmp_img}" "${_dir}" "${_epoch}"
        _tmp_size=$(du -s "${_tmp_img}" | cut -f 1)
        _size=$(( 69420 + _tmp_size * 12 / 10))
    fi
    _mkluks_common "${_name}" "${_encryption_key}" "${_label}"
    _run_mkluks "${_image_path}" "${_size}" "${_encryption_key}" \
                "${_epoch}" "${_label}" "${_writable}" "${_grub}"
    if [[ "${_tmp_size}" != "" ]]; then
        _msg_info "Copying erofs image"
	if [[ "${quiet}" == "y" ]]; then
            dd if="${_tmp_img}" of="${image_device}" > /dev/null 2>&1
	else
            dd if="${_tmp_img}" of="${image_device}"
	fi
    else
	msg_info "Writing erofs image"
        _run_mkerofs "${image_device}" "${_dir}" "${_epoch}"
    fi 
    sync
    _close_luks_device "${image_device}"
}

# Defines functions to create ext4 for file system images
for _img in "${fs_images[@]}"; do
    eval "_mk${_img}_ext4() {" \
             "${_img}_guid=${linux_guid};" \
              "_mkimg_ext4 \${_dir}" \
                          "\${_image_path}" \
                          "\${_size}" \
                          "\${_epoch}" \
                          "\${_label}; }"
    eval "_mk${_img}_squashfs() {" \
              "_mkimg_squashfs \${_dir}" \
                              "\${_image_path}; }"
    eval "_mk${_img}_erofs() {" \
              "_mkimg_erofs \${_image_path}" \
                           "\${_dir}" \
                           "\${_epoch}; }"
    eval "_mk${_img}_erofs+luks() {" \
              "_mkimg_erofs+luks \${_name}" \
                                "\${_dir}" \
                                "\${_image_path}" \
                                "\${_auto_size}" \
                                "\${_encryption_key}" \
                                "\${_epoch}" \
                                "\${_label}" \
                                "\${_grub}; }"
    eval "_mk${_img}_ext4+squashfs() {" \
              "_mkimg_ext4+squashfs \${_name}" \
                                   "\${_dir}" \
                                   "\${_image_path}" \
                                   "\${_size}" \
                                   "\${_epoch}" \
                                   "\${_label}" \
                                   "\${_writable}; }"
    eval "_mk${_img}_ext4+squashfs+luks() {" \
              "_mkimg_ext4+squashfs+luks \${_name}" \
                                        "\${_dir}" \
                                        "\${_image_path}" \
                                        "\${_size}" \
                                        "\${_encryption_key}" \
                                        "\${_epoch}" \
                                        "\${_writable}" \
                                        "\${_grub}; }"
    eval "_mk${_img}_ext4+luks() {" \
              "${_img}_guid=${luks_guid};" \
              "_mkimg_ext4+luks \${_name}" \
                               "\${_dir}" \
                               "\${_image_path}" \
                               "\${_size}" \
                               "\${_encryption_key}" \
                               "\${_epoch}" \
                               "\${_label}" \
                               "\${_grub}; }"
    eval "_mk${_img}_squashfs+luks() {" \
              "_mkimg_squashfs+luks \${_name}" \
                                   "\${_dir}" \
                                   "\${_image_path}" \
                                   "\${_size}" \
                                   "\${_encryption_key}" \
                                   "\${_epoch}" \
                                   "\${_label}" \
                                   "\${_writable}" \
                                   "\${_grub}; }"
    eval "_mk${_img}_swap() {" \
              "_run_mkswap \${_image_path}" \
                          "\${_size}" \
                          "\${_epoch}" \
                          "\${_label}; }"
    eval "_mk${_img}_swap+luks() {" \
              "_mkimg_swap+luks \${_name}" \
                               "\${_image_path}" \
                               "\${_size}" \
                               "\${_encryption_key}" \
                               "\${_epoch}" \
                               "\${_label}" \
                               "\${_grub}; }"
done

# Parameters for _mkairootfs_fs_type functions
_mkairootfs_common() {
    _mkfs_options=("${airootfs_image_tool_options[@]}")
    _name="airootfs"
    _dir="${pacstrap_dir}"
    _image_path="${airootfs_dir}/airootfs."$(_get_fs_ext "airootfs")
    _size="${airootfs_size}"
    _encryption_key="${airootfs_encryption_key}"
    _epoch="$(_get_epoch "airootfs")"
    _label="${iso_label}"
    _writable=false
    _grub=false
    _auto_size=""
    rm -f -- "${_image_path}"
    [[ -e "${_dir}" ]] || _msg_error "The path '${_dir}' does not exist" 1
    install -d -m 0755 -- "${airootfs_dir}"
}

# Parameters for _mkkeys_fs_type functions
_mkkeys_common() {
    _mkfs_options=("${keys_image_tool_options[@]}")
    _name="keys"
    _dir="${keys_dir}"
    _image_path="${dongle_isofs_dir}/keys."$(_get_fs_ext "keys")
    _encryption_key="${keys_encryption_key}"
    _size="${keys_size}"
    _epoch="$(_get_epoch "keys")"
    _label="${iso_label}_KEYS"
    _writable="false"
    _grub="false"
    _auto_size=""
    rm -f -- "${_image_path}"
}

# Parameters for _mkpersistent_fs_type functions
_mkpersistent_common() {
    _name="persistent"
    _dir="${persistent_dir}"
    _image_path="${persistent_img}"
    _encryption_key="${persistent_encryption_key}"
    _size="${persistent_size}"
    _epoch="$(_get_epoch "persistent")"
    _label="${iso_label}_PERSISTENT"
    _writable="true"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _grub="false"
    else
        _grub="true"
    fi
    _auto_size=""
    persistent_epoch="${_epoch}"
    rm -f -- "${_image_path}"
}

# Parameters for _mkdongle_boot_fs_type functions
_mkdongle_boot_common() {
    _name="dongleboot"
    _dir="${dongle_boot_dir}"
    _image_path="${dongle_boot_img}"
    _encryption_key="${dongle_boot_encryption_key}"
    _size="${dongle_boot_size}"
    _epoch=$(_get_epoch "dongle_boot")
    _label="${iso_label}_DONGLE_BOOT"
    _writable="false"
    _grub="true"
    rm -f -- "${_image_path}"
}

# Parameters for _mkdongle_persistent_fs_type functions
_mkdongle_persistent_common() {
    _name="donglepersistent"
    _dir="${dongle_persistent_dir}"
    _image_path="${dongle_persistent_img}"
    _encryption_key="${dongle_persistent_encryption_key}"
    _size="${dongle_persistent_size}"
    _epoch="${dongle_persistent_epoch}"
    _label="${iso_label}_DONGLE_PERSISTENT"
    _writable="true"
    _grub="false"
    rm -f -- "${_image_path}"
}

# Parameters for _mkswap_fs_type functions
_mkswap_common() {
    _name="swap"
    _image_path="${swap_img}"
    # shellcheck disable=SC2154
    _encryption_key="${swap_encryption_key}"
    _size="${swap_size}"
    _epoch=$(_get_epoch "swap")
    if [[ "${swap_image_type}" == *"luks" ]]; then
        _label="${iso_label}_SWAP"
    else
        _label="${_name}"
    fi
    _writable="true"
    _grub="false"
    _auto_size=""
    rm -f -- "${_image_path}"
}

# Parameters for _mkdongle_swap_fs_type functions
_mkdongle_swap_common() {
    _name="dongle_swap"
    _image_path="${dongle_swap_img}"
    # shellcheck disable=SC2154
    _encryption_key="${dongle_swap_encryption_key}"
    _size="${dongle_swap_size}"
    _epoch="$(_get_epoch "dongle_swap")"
    if [[ "${dongle_swap_image_type}" == *"luks" ]]; then
        _label="${iso_label}_DONGLE_SWAP"
    else
        _label="${_name}"
    fi
    _writable="true"
    _grub="false"
    _auto_size=""
    rm -f -- "${_image_path}"
}

# Parameters for _mkrecovery_fs_type functions
_mkrecovery_common() {
    _mkfs_options=("${airootfs_image_tool_options[@]}")
    _name="recovery"
    _dir="${pacstrap_dir}"
    _image_path="${recovery_img}"
    _size="${recovery_size}"
    _encryption_key="${recovery_encryption_key}"
    _epoch="$(_get_epoch "recovery")"
    _label="${iso_label}_RECOVERY"
    _writable=false
    _grub=true
    _auto_size=""
    rm -f -- "${_image_path}"
    [[ -e "${_dir}" ]] || _msg_error "The path '${_dir}' does not exist" 1
}

# Create checksum for a given file.
_mkchecksum() {
    local _file
    local _dir
    local _name
    _file="${1}"
    _dir=$(dirname "${_file}")
    _name=$(basename "${_file%.*}")

    cd -- "${_dir}"
    if [[ -e "${_file}" ]]; then
        _msg_info "Creating checksum of ${_file} for self-test..."
        sha512sum "$(basename "${_file}")" > "${_name}.sha512"
    fi
    cd -- "${OLDPWD}"
}

# GPG sign a file.
_mksignature() {
    local _file="${1}"
    local gpg_options=()
    rm -f -- "${_file}.sig"
    # Add gpg sender option if the value is provided
    [[ -z "${gpg_sender}" ]] || gpg_options+=('--sender' "${gpg_sender}")
    if [ -e "${_file}" ]; then
        _msg_info "Signing $(basename "${_file}")..."
        # always use the .sig file extension, as that is what 
        # mkinitcpio-archiso's hooks expect
        _msg_info "GPG home: ${gpg_home}"
        if [ "${gpg_home}" != "" ]; then
            GNUPGHOME="${gpg_home}" gpg --batch --no-armor --no-include-key-block \
                                        --output "${_file}.sig" --detach-sign \
                                        --homedir "${gpg_home}" \
                                        --default-key "${gpg_key}" "${gpg_options[@]}" "${_file}"
        else
            gpg --batch --no-armor --no-include-key-block \
                --output "${_file}.sig" --detach-sign \
                --default-key "${gpg_key}" "${gpg_options[@]}" "${_file}"
        fi
    fi
    _msg_info "Done!"
}

# Returns the extension for a given file system image
# $1: a value in 'fs_images' (airootfs, persistent, ...)
_get_fs_ext() {
    local _image="${1}"
    local _fs_type
    _fs_type=$(_get_fs_type "${_image}")
    if [ "${_fs_type}" = "squashfs" ]; then
        echo "sfs"
    else
        echo "${_fs_type}"
    fi
}

# Returns image extension for a given file system image
# $1: a value in 'fs_images' (airootfs, persistent, ...)
_get_fs_type() {
    local _image="${1}"
    local _no_luks
    _no_luks=$(eval echo \$"{${_image}_image_type%%+luks}")
    echo "${_no_luks##*"+"}"
}

# Returns internal size for an internal partition from the outer image size
# $1: outer partition size
_get_internal_size() {
    local _size="${1}"
    if [[ "${_size}" -lt $((50 * 1000)) ]]; then
        ratio=60
    elif [[ "${_size}" -gt $((50 * 1000)) ]] && [[ "${_size}" -lt $((200 * 1000)) ]]; then
        ratio=70
    elif [[ "${_size}" -gt $((200 * 1000)) ]] && [[ "${_size}" -lt $((1000 * 1000)) ]]; then
        ratio=75
    elif [[ "${_size}" -gt $((200 * 1000)) ]] && [[ "${_size}" -lt $((5000000)) ]]; then
        ratio=80
    else
        ratio=85
    fi
    echo $(((_size * ratio)/100))
}

# Helper function to run functions only one time.
# $1: function name
_run_once() {
    if [[ ! -e "${work_dir}/${run_once_mode}.${1}" ]]; then
        "$1"
        touch "${work_dir}/${run_once_mode}.${1}"
    else
        if [ "${quiet}" != "y"  ]; then
            _msg_info "Command ${1} already run"
        fi
    fi
}

# Sets up custom pacman.conf with custom cache and pacman hook directories.
_make_pacman_conf() {
    local _cache_dirs _system_cache_dirs _profile_cache_dirs
    _system_cache_dirs="$(pacman-conf CacheDir| tr '\n' ' ')"
    _profile_cache_dirs="$(pacman-conf --config "${pacman_conf}" CacheDir| tr '\n' ' ')"

    # Only use the profile's CacheDir, if it is not the default and not the same as the system cache dir.
    if [[ "${_profile_cache_dirs}" != "/var/cache/pacman/pkg" ]] && \
        [[ "${_system_cache_dirs}" != "${_profile_cache_dirs}" ]]; then
        _cache_dirs="${_profile_cache_dirs}"
    else
        _cache_dirs="${_system_cache_dirs}"
    fi

    _msg_info "Copying custom pacman.conf to work directory..."
    _msg_info "Using pacman CacheDir: ${_cache_dirs}"
    # take the profile pacman.conf and strip all settings that would break in chroot when using pacman -r
    # append CacheDir and HookDir to [options] section
    # HookDir is *always* set to the airootfs' override directory
    # see `man 8 pacman` for further info
    pacman-conf --config "${pacman_conf}" | \
        sed "/CacheDir/d;/DBPath/d;/HookDir/d;/LogFile/d;/RootDir/d;/\[options\]/a CacheDir = ${_cache_dirs}
             /\[options\]/a HookDir = ${pacstrap_dir}/etc/pacman.d/hooks/" > "${work_dir}/${buildmode}.pacman.conf"
}

# Prepares working directory and copies custom root file system files.
_make_custom_airootfs() {
    _validate_file_err="" _validate_file_warn=""
    local passwd=()
    local filename permissions
    local _etc="${profile}/airootfs/etc"

    install -d -m 0755 -o 0 -g 0 -- "${pacstrap_dir}"

    if [[ -d "${profile}/airootfs" ]]; then
        if [[ "${airootfs_image_type}" == *luks ]] && \
           [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
             _resolve_secondary_encryption_key "keys"
             dongle_boot_encryption_key="${keys_encryption_key}"
             cp "${_etc}/mkinitcpio.conf" \
                "${_etc}/mkinitcpio.dongle_boot.conf"
             _build_archiso_mkinitcpio_conf \
                 "${_etc}/mkinitcpio.dongle_boot.conf" \
                 "${airootfs_encryption_key}"
             _resolve_secondary_encryption_key "recovery"
             cp "${_etc}/mkinitcpio.conf" \
                "${profile}/airootfs/etc/mkinitcpio.recovery.conf"
             _build_archiso_mkinitcpio_conf \
                 "${_etc}/mkinitcpio.recovery.conf" \
                 "${recovery_encryption_key}"
        fi
        _build_archiso_mkinitcpio_conf "${_etc}/mkinitcpio.conf" 
        _copy_custom_files "airootfs" "${pacstrap_dir}"
    fi
}

# Install desired packages to the root file system
_make_packages() {
    _msg_info "Installing packages to '${pacstrap_dir}/'..."

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<>"${work_dir}/pubkey.gpg"
        export ARCHISO_GNUPG_FD
    fi

    # Unset TMPDIR to work around https://bugs.archlinux.org/task/70580
    if [[ "${quiet}" = "y" ]]; then
        env -u TMPDIR pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -- "${pacstrap_dir}" "${buildmode_pkg_list[@]}" > /dev/null 2>&1
    else
        env -u TMPDIR pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -- "${pacstrap_dir}" "${buildmode_pkg_list[@]}"
    fi

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<&-
        unset ARCHISO_GNUPG_FD
    fi

    _msg_info "Done! Packages installed successfully."
}

# Customize installation.
_make_customize_airootfs() {
    local passwd=()

    if [[ -e "${profile}/airootfs/etc/passwd" ]]; then
        _msg_info "Copying /etc/skel/* to user homes..."
        while IFS=':' read -a passwd -r; do
            # Only operate on UIDs in range 1000â€“59999
            (( passwd[2] >= 1000 && passwd[2] < 60000 )) || continue
            # Skip invalid home directories
            [[ "${passwd[5]}" == '/' ]] && continue
            [[ -z "${passwd[5]}" ]] && continue
            # Prevent path traversal outside of $pacstrap_dir
            if [[ "$(realpath -q -- "${pacstrap_dir}${passwd[5]}")" == "${pacstrap_dir}"* ]]; then
                if [[ ! -d "${pacstrap_dir}${passwd[5]}" ]]; then
                    install -d -m 0750 -o "${passwd[2]}" -g "${passwd[3]}" -- "${pacstrap_dir}${passwd[5]}"
                fi
                cp -dnRT --preserve=mode,timestamps,links -- "${pacstrap_dir}/etc/skel/." "${pacstrap_dir}${passwd[5]}"
                chmod -f 0750 -- "${pacstrap_dir}${passwd[5]}"
                chown -hR -- "${passwd[2]}:${passwd[3]}" "${pacstrap_dir}${passwd[5]}"
            else
                _msg_error "Failed to set permissions on '${pacstrap_dir}${passwd[5]}'. Outside of valid path." 1
            fi
        done < "${profile}/airootfs/etc/passwd"
        _msg_info "Done!"
    fi

    if [[ -e "${pacstrap_dir}/root/customize_airootfs.sh" ]]; then
        _msg_info "Running customize_airootfs.sh in '${pacstrap_dir}' chroot..."
        _msg_warning "customize_airootfs.sh is deprecated! Support for it will be removed in a future archiso version."
        chmod -f -- +x "${pacstrap_dir}/root/customize_airootfs.sh"
        # Unset TMPDIR to work around https://bugs.archlinux.org/task/70580
        eval -- env -u TMPDIR arch-chroot "${pacstrap_dir}" "/root/customize_airootfs.sh"
        rm -- "${pacstrap_dir}/root/customize_airootfs.sh"
        _msg_info "Done! customize_airootfs.sh run successfully."
    fi
}

# Set up boot loaders
_make_bootmodes_iso() {
    local bootmode
    for bootmode in "${bootmodes[@]}"; do
        _run_once "_make_bootmode_${bootmode}_iso"
    done
}

# Set up boot loaders
_make_bootmodes_dongle() {
    local bootmode
    for bootmode in "${bootmodes[@]}"; do
        _run_once "_make_bootmode_${bootmode}_dongle"
    done
}

# Copy kernel and initramfs to ISO 9660
_make_boot_on_iso9660() {
    isofs_dir="${work_dir}/iso"
    _make_boot_on_iso "${isofs_dir}" "ISO 9660"
    _make_boot_on_iso "${persistent_dir}" "ISO 9660"
}

# Copy kernel and initramfs to dongle ISO 9660
_make_boot_on_dongle() {
    _make_boot_on_iso "${work_dir}/dongle_iso" "dongle ISO 9660"
    _make_boot_on_iso "${work_dir}/dongle_boot" "dongle boot"
    _make_boot_on_iso "${work_dir}/dongle_persistent" "dongle persistent"
}

# Copy kernel and initramfs to ISO 9660
_make_boot_on_iso() {
    local bootable_dir="${1}"
    local _fs_name="${2}"
    local _query _src ucode_image
    local _cp_opts=('-af' '--no-preserve=ownership,mode')
    local boot_dir="${bootable_dir}/${install_dir}/boot"
    local kernel_dir="${bootable_dir}/${install_dir}/boot/${arch}"
    local licenses_src="${pacstrap_dir}/usr/share/licenses"
    local licenses_dest="${boot_dir}/licenses"
    local images=("initramfs-*" "vmlinuz-*")
    _msg_info "Preparing kernel and initramfs for the ${_fs_name} file system in ${bootable_dir}..."
    install -d -m 0755 -- "${kernel_dir}"
    for _query in  "${images[@]}"; do
        find "${work_dir}" -iname "${_query}" -exec cp "${_cp_opts[@]}" {} "${kernel_dir}" \; -quit
        find "${kernel_dir}" -iname "${_query}" -exec chmod 0644 {} \;
    done

    for ucode_image in "${ucodes[@]}"; do
        find "${work_dir}" -iname "${ucode_image}" -exec cp "${_cp_opts[@]}" {} "${boot_dir}" \;
        find "${boot_dir}" -iname "${_query}" -exec chmod 0644 {} \;
        if [[ -e "${licenses_src}/${ucode_image%.*}/" ]]; then
            install -d -m 0755 -- "${licenses_dest}/${ucode_image%.*}/"
            install -m 0644 -- "${licenses_src}/${ucode_image%.*}/"* "${licenses_dest}/${ucode_image%.*}/"
        fi
    done
    _msg_info "Done!"
}

# Adds archiso hooks to profile's mkinitcpio.conf
# $1: mkinitcpio.conf file to edit
# $2: an encryption key to add to resulting initrd image
_build_archiso_mkinitcpio_conf() {
    local _mkinitcpio_conf="${1}"
    local _encryption_key="${2}"
    local _files=() _hooks=() _modules=()
    local _mkinitcpio_conf_tmp="${work_dir}/mkinitcpio.conf"
    
    if [[ "${airootfs_image_type}" == *luks ]] || \
       [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _hooks+=("encrypt") 
        if [[ "${_encryption_key}" != "" ]]; then
            _files+=("${_encryption_key}")
        fi
    fi
    _hooks+=("archiso")

    if [[ "${airootfs_image_type}" == *"ext4"* ]]; then
        _modules+=("ext4")
    fi

    cp "${_mkinitcpio_conf}" "${_mkinitcpio_conf_tmp}"
    sed "s|%ARCHISO_FILES%|${_files[*]}|g;
         s|%ARCHISO_HOOKS%|${_hooks[*]}|g;
         s|%ARCHISO_MODULES%|${_modules[*]}|g" \
        "${_mkinitcpio_conf_tmp}" > "${_mkinitcpio_conf}"
}

# Returns epoch given a file system image name 
# $1: value in fs_images
_get_epoch() {
    local _name="${1}"
    eval "echo \$((SOURCE_DATE_EPOCH + _${_name}_const))"
}

# Returns an unique uuid given a datetime in UNIX time
# $1: UNIX time
_get_epoch_fsuuid() {
    local _epoch="${1}"
    uuidgen --sha1 \
	        --namespace "${epoch_namespace}" \
            --name "${_epoch}"
}

# Returns UUID for the GRUB plain mount
_get_archiso_uuid() {
    #shellcheck disable=SC2005
    echo "$(_epoch_to_uuid "$(_get_epoch airootfs)")"
}

# Returns UUID for the dongle GRUB plain mount
_get_dongle_uuid() {
    #shellcheck disable=SC2005
    echo "$(_epoch_to_uuid "$(_get_epoch dongle)")"
}

# Returns UUID for the GRUB cryptomount (i.e. currently the encrypted boot partition)
_get_cryptomount_uuid() {
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _epoch="$(_get_epoch dongle_boot)"
    else
        _epoch="$(_get_epoch persistent)"
    fi
    _get_epoch_fsuuid "${_epoch}" | sed "s|-||g"
}

# Returns dongle persistent partition uuid
_get_dongle_persistent_uuid() {
    _epoch=$(_get_epoch dongle_persistent)
    _get_epoch_fsuuid "${_epoch}"
}

# Returns dongle swap partition uuid
_get_dongle_swap_uuid() {
    _epoch="$(_get_epoch dongle_swap)"
    _get_epoch_fsuuid "${_epoch}"
}

# Returns UUID for the dongle swap mount
_get_swap_uuid() {
    if [[ "${buildmode}" == 'dongle' ]]; then
        _epoch="$(_get_epoch dongle_swap)"
    else
        _epoch="$(_get_epoch swap)"
    fi
    _get_epoch_fsuuid "${_epoch}"
}


# Produces kernel parameters.
_get_kernel_params() {
    local _kparams=()
    _kparams+=("archisobasedir=${install_dir}"
               "archisolabel=${iso_label}"
               "archisouuid=$(_get_archiso_uuid)"
               "$(_get_crypto_params)")
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _kparams+=("sigdevice=UUID=$(_get_dongle_uuid):iso9660:$(_get_airootfs_path).sig"
                   "verify=y")
    fi
    echo "${_kparams[@]}"
}

# Produces the 'encrypt' hook's kernel parameters needed to boot an encrypted ISO.
_get_crypto_params() {
    declare -a _cparams
    local _keys_fs_type _keys_path
    _keys_fs_type="$(_get_fs_type "keys")"
    _keys_path="keys.$(_get_fs_ext "keys")"
    _cparams=()
    if [[ "${airootfs_image_type}" == *luks ]]; then
        _cparams+=("root=/dev/mapper/root"
                   "cryptdevice=UUID=$(_get_archiso_uuid),$(_get_airootfs_path):root:readonly")
        if [ "${airootfs_encryption_key}" != "" ]; then
            _cparams+=("cryptkey=UUID=$(_get_dongle_uuid):iso9660,${_keys_fs_type}:${_keys_path},airootfs.key")
        fi
    fi
    echo "${_cparams[@]}"
}

# Prepares GRUB for booting from MBR (isohybrid)
_make_bootmode_bios.grub.mbr() {
    bootable_dir="${1}"
    bootable="${2}"
    _msg_info "Setting up GRUB for BIOS booting from a disk..."
    install -d -m 0755 -- "${bootable_dir}/EFI/BOOT"
    _run_once _make_common_bootmode_grub_cfg

    grub-mkstandalone -O i386-pc \
                      --modules="$(_get_grubmodules "bios")" \
                      --locales="en@quot" \
                      --themes="" \
                      --fonts="" \
                      --install-modules="$(_get_grubmodules "bios")" \
                      --disable-shim-lock \
                      --compress=xz \
                      -o "${work_dir}/BOOTIA32.MBR" "boot/grub/grub.cfg=${work_dir}/grub/grub.cfg"

    install -D -m 0644 "${work_dir}/BOOTIA32.MBR" "${bootable_dir}/EFI/BOOT"

    if [[ "${bootable}" == "iso" ]]; then
        _run_once _make_boot_on_iso9660
    elif [[ "${bootable}" == "dongle" ]]; then
        _run_once _make_boot_on_dongle
    fi

    _msg_info "Done! GRUB set up for BIOS booting from a disk successfully."
}

# Prepares GRUB for booting from MBR on the ISO
_make_bootmode_bios.grub.mbr_iso() {
    _make_bootmode_bios.grub.mbr "${isofs_dir}" "iso"
}

# Prepares GRUB for booting from MBR on the dongle ISO
_make_bootmode_bios.grub.mbr_dongle() {
    _make_bootmode_bios.grub.mbr "${dongle_isofs_dir}" "dongle"
}

# Prepares GRUB for El-Torito booting on BIOS systems
# $1: root file system for grub
_make_bootmode_bios.grub.eltorito() {
    local bootable_dir="${1}"
    _msg_info "Setting up GRUB for BIOS booting from an optical disc..."
    install -d -m 0755 -- "${bootable_dir}/EFI/BOOT"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/grub/i386-pc/boot_hybrid.img" "${bootable_dir}/EFI/BOOT/"
    _run_once _make_common_bootmode_grub_cfg

    grub-mkstandalone -O i386-pc-eltorito \
                      --modules="$(_get_grubmodules "bios")" \
                      --locales="en@quot" \
                      --themes="" \
                      --fonts="" \
                      --install-modules="$(_get_grubmodules "bios")" \
                      --disable-shim-lock \
                      --compress=xz \
                      -o "${work_dir}/BOOTIA32.ELTORITO" "boot/grub/grub.cfg=${work_dir}/grub/grub.cfg"

    install -m 0644 -- "${work_dir}/BOOTIA32.ELTORITO" "${bootable_dir}/EFI/BOOT"

    if [[ "${bootable}" == "iso" ]]; then
        _run_once _make_boot_on_iso9660
        if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            _run_once _make_boot_on_dongle
        fi
    elif [[ "${bootable}" == "dongle" ]]; then
        _run_once _make_boot_on_dongle
    fi
}

# Prepares GRUB El Torito on BIOS for the ISO image
_make_bootmode_bios.grub.eltorito_iso() {
    _make_bootmode_bios.grub.eltorito "${isofs_dir}"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.grub.mbr_iso
}

# Prepares GRUB El Torito on BIOS for the dongle ISO image
_make_bootmode_bios.grub.eltorito_dongle() {
    _make_bootmode_bios.grub.eltorito "${dongle_isofs_dir}"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.grub.mbr_dongle
}

# Prepares syslinux for booting from MBR (isohybrid)
# $1: root file system for syslinux
# $2: device type (iso, dongle)
_make_bootmode_bios.syslinux.mbr() {
    bootable_dir="${1}"
    bootable="${2}"
    _msg_info "Setting up SYSLINUX for BIOS booting from a disk..."
    install -d -m 0755 -- "${bootable_dir}/syslinux"
    for _cfg in "${profile}/syslinux/"*.cfg; do
        _build_bootloader_config "${_cfg}" "syslinux" > "${bootable_dir}/syslinux/${_cfg##*/}"
    done
    if [[ -e "${profile}/syslinux/splash.png" ]]; then
        install -m 0644 -- "${profile}/syslinux/splash.png" "${bootable_dir}/syslinux/"
    fi
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/"*.c32 "${bootable_dir}/syslinux/"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/lpxelinux.0" "${bootable_dir}/syslinux/"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/memdisk" "${bootable_dir}/syslinux/"

    if [[ "${bootable}" == "iso" ]]; then
        _run_once _make_boot_on_iso9660
        if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            _run_once _make_boot_on_dongle
        fi
    elif [[ "${bootable}" == "dongle" ]]; then
        _run_once _make_boot_on_dongle
    fi

    if [[ -e "${bootable_dir}/syslinux/hdt.c32" ]]; then
        install -d -m 0755 -- "${bootable_dir}/syslinux/hdt"
        if [[ -e "${pacstrap_dir}/usr/share/hwdata/pci.ids" ]]; then
            gzip -cn9 "${pacstrap_dir}/usr/share/hwdata/pci.ids" > \
                "${bootable_dir}/syslinux/hdt/pciids.gz"
        fi
        find "${pacstrap_dir}/usr/lib/modules" -name 'modules.alias' -print -exec gzip -cn9 '{}' ';' > \
            "${bootable_dir}/syslinux/hdt/modalias.gz"
    fi

    # Add other aditional/extra files to ${install_dir}/boot/
    if [[ -e "${pacstrap_dir}/boot/memtest86+/memtest.bin" ]]; then
        # rename for PXE: https://wiki.archlinux.org/title/Syslinux#Using_memtest
        install -m 0644 -- "${pacstrap_dir}/boot/memtest86+/memtest.bin" "${bootable_dir}/${install_dir}/boot/memtest"
        install -d -m 0755 -- "${bootable_dir}/${install_dir}/boot/licenses/memtest86+/"
        install -m 0644 -- "${pacstrap_dir}/usr/share/licenses/common/GPL2/license.txt" \
            "${bootable_dir}/${install_dir}/boot/licenses/memtest86+/"
    fi
    _msg_info "Done! SYSLINUX set up for BIOS booting from a disk successfully."
}

# Prepares syslinux for booting from MBR on the ISO
_make_bootmode_bios.syslinux.mbr_iso() {
    _make_bootmode_bios.syslinux.mbr "${isofs_dir}" "iso"
}

# Prepares syslinux for booting from MBR on the ISO
_make_bootmode_bios.syslinux.mbr_dongle() {
    _make_bootmode_bios.syslinux.mbr "${dongle_isofs_dir}" "dongle"
}

# Prepares syslinux for El-Torito booting
# $1: root file system for syslinux
_make_bootmode_bios.syslinux.eltorito() {
    local bootable_dir="${1}"
    _msg_info "Setting up SYSLINUX for BIOS booting from an optical disc..."
    install -d -m 0755 -- "${bootable_dir}/syslinux"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/isolinux.bin" "${bootable_dir}/syslinux/"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/isohdpfx.bin" "${bootable_dir}/syslinux/"

    _msg_info "Done! SYSLINUX set up for BIOS booting from an optical disc successfully."
}

# Prepares syslinux for El-Torito booting on BIOS on the ISO
_make_bootmode_bios.syslinux.eltorito_iso() {
    _make_bootmode_bios.syslinux.eltorito "${isofs_dir}"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.syslinux.mbr_iso

}

# Prepares syslinux for El-Torito booting on BIOS on the dongle ISO
_make_bootmode_bios.syslinux.eltorito_dongle() {
    _make_bootmode_bios.syslinux.eltorito "${dongle_isofs_dir}"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.syslinux.mbr_dongle
}

# Copies kernel and initramfs to FAT image
_make_boot_on_fat() {
    local _images _ucode_image
    _msg_info "Preparing kernel and initramfs for the FAT file system..."
    _images=("initramfs-*" "vmlinuz-*")
    mmd -D o -i "${efi_boot_img}" \
        "::/${install_dir}" "::/${install_dir}/boot" "::/${install_dir}/boot/${arch}"
    for _query in "${_images[@]}"; do
        find "${work_dir}" -iname "${_query}" -exec mcopy -D "o" -i "${efi_boot_img}" {} "::/${install_dir}/boot/${arch}/" \; -quit
    done
    for _ucode_image in "${ucodes[@]}"; do
        find "${work_dir}" -iname "${_ucode_image}" -exec mcopy -D "o" -i "${efi_boot_img}" {} "::/${install_dir}/boot/" \;
    done
    _msg_info "Done!"
}

# Creates a FAT image (efiboot.img) which will serve as the EFI system partition
# $1: image size in bytes
_make_efi_boot_img() {
    local _size_kib="0"
    local _size_bytes=${1}

    if (( _size_bytes < 2*1024*1024 )); then
        _msg_info "Validating '${bootmode}': efiboot.img size is ${_size_bytes} bytes is less than 2 MiB! Bumping up to 2 MiB"
        _size_bytes=$((20*1024*1024))
    fi

    # Where it spills?
    _size_bytes=$((_size_bytes * 10))

    # Convert from bytes to KiB and round up to the next full MiB with an additional MiB for reserved sectors.
    _size_kib="$(awk 'function ceil(x){return int(x)+(x>int(x))}
            function byte_to_kib(x){return x/1024}
            function mib_to_kib(x){return x*1024}
            END {print mib_to_kib(ceil((byte_to_kib($1)+1024)/1024))}' <<< "${_size_bytes}"
    )"
    # The FAT image must be created with mkfs.fat not mformat, as some systems have issues with mformat made images:
    # https://lists.gnu.org/archive/html/grub-devel/2019-04/msg00099.html
    rm -f -- "${efi_boot_img}"
    _msg_info "Creating FAT image of size: ${_size_kib} KiB..."
    if [[ "${quiet}" == "y" ]]; then
        # mkfs.fat does not have a -q/--quiet option, so redirect stdout to /dev/null instead
        # https://github.com/dosfstools/dosfstools/issues/103
        mkfs.fat -C -n ARCHISO_EFI "${efi_boot_img}" "${_size_kib}" > /dev/null
    else
        mkfs.fat -C -n ARCHISO_EFI "${efi_boot_img}" "${_size_kib}"
    fi

    # Create the default/fallback boot path in which a boot loaders will be placed later.
    mmd -D o -i "${efi_boot_img}" ::/EFI ::/EFI/BOOT
}

# Copies GRUB files to efiboot.img which is used by both IA32 UEFI and x64 UEFI.
_make_common_bootmode_grub_copy_to_efi_boot_img() {
    local files_to_copy=()
    files_to_copy+=("${work_dir}/grub/"*'.cfg')
    if compgen -G "${profile}/grub/!(*.cfg)" &> /dev/null; then
        files_to_copy+=("${profile}/grub/"!(*.cfg))
    fi
    mcopy -D o -i "${efi_boot_img}" "${files_to_copy[@]}" ::/EFI/BOOT/
}

# Gets an ext4-compatible uuid from a date
# $1: datetime in UNIX time
_epoch_to_uuid() {
    local _epoch="${1}"
    local _uuid
    TZ=UTC printf -v _uuid '%(%F-%H-%M-%S-00)T' "${_epoch}"
    echo "${_uuid}"
}

# Returns ISO image uuid for current buildmode
_get_bootable_uuid() {
    local _uuid
    _uuid="$(_get_archiso_uuid)"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _uuid=$(_get_dongle_uuid)
    fi
    echo "${_uuid}"
}

# Returns the correct device selection command line for use in a templatized GRUB
# configuration file
_get_device_select_cmdline() {
    #shellcheck disable=SC2005
    if [[ "${persistent_image_type}" == *luks ]]; then
        echo "cryptomount -u $(_get_cryptomount_uuid)"
    else
        echo "search --no-floppy --set=root --fs-uuid $(_get_bootable_uuid)"
    fi
}

# Fill a bootloader configuration template and copy the result in a file
# $1: bootloader configuration file (templatized, see profile directory)
# $2: bootloader (empty?)
_build_bootloader_config() {
    local _template="${1}"
    local _bootloader="${2}"
    sed "s|%DEVICE_SELECT_CMDLINE%|$(_get_device_select_cmdline)|g;
         s|%ARCH%|${arch}|g;
         s|%INSTALL_DIR%|/${install_dir}|g;
         s|%KERNEL_PARAMS%|$(_get_kernel_params)|g;
         s|%BOOTABLE_UUID%|$(_get_bootable_uuid)|g;
         s|%FALLBACK_UUID%|$(_get_archiso_uuid)|g" "${_template}"
}

# Fill a templatized crypttab
# $1: crypttab template
# $2: out file
_build_crypttab() {
    local _template="${1}"
    local _out="${2}"
    if [[ "${persistent_image_type}" == *"luks" ]]; then
        sed "s|%PERSISTENT_UUID%|${persistent_uuid}|g" "${_template}" > "${_out}"
    else
        sed '/%PERSISTENT_UUID%/d' "${_template}" > "${_out}"
    fi
    if [[ "${dongle_persistent_image_type}" == *"luks" ]]; then
        sed -i "s|%DONGLE_PERSISTENT_UUID%|${dongle_persistent_uuid}|g" "${_out}"
    else
        sed -i '/%DONGLE_PERSISTENT_UUID%/d' "${_out}"
    fi
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        sed -i "s|%SECURE_MOUNT%|/run/archiso/donglepersistent|g" "${_out}"
    else
        sed -i "s|%SECURE_MOUNT%||g" "${_out}"
    fi
    if [[ "${swap_image_type}" == *"luks" ]]; then
        sed -i "s|%SWAP_UUID%|$(_get_swap_uuid)|g" "${_out}"
    else
        sed -i '/%SWAP_UUID%/d' "${_out}"
    fi
    if [[ "${swap_size}" != "" ]] && [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        sed -i "s|%DONGLE_SWAP_UUID%|$(_get_dongle_swap_uuid)|g" "${_out}"
    else
        sed -i '/%DONGLE_SWAP_UUID%/d' "${_out}"
    fi
}

# Fills templatized udev rules for the persistent partitions
# $1: template udev rule file
_fill_persistent_ro_udev_rules() {
    local _template="${1}"
    # shellcheck disable=SC2154
    if [[ "${persistent_size}" != "" ]]; then
        sed -i "s|%DONGLE_PERSISTENT_UUID%|${dongle_persistent_uuid}|g" "${_template}"
    else
        sed -i '/%DONGLE_PERSISTENT_UUID%/d' "${_template}"
    fi
    if [[ "${persistent_size}" != "" ]]; then
        sed -i "s|%PERSISTENT_UUID%|${persistent_uuid}|g" "${_template}"
    else
        sed -i '/%PERSISTENT_UUID%/d' "${_template}"
    fi
}

# Prepare GRUB configuration files
_make_common_bootmode_grub_cfg(){
    local _cfg

    install -d -- "${work_dir}/grub"

    # Fill GRUB configuration files
    for _cfg in "${profile}/grub/"*'.cfg'; do
        _build_bootloader_config "${_cfg}" "grub" > "${work_dir}/grub/${_cfg##*/}"
    done
    # Add all GRUB files to the list of files used to calculate the required FAT image size.
    efi_boot_files+=("${work_dir}/grub/"
                     "${profile}/grub/"!(*.cfg))

    IFS='' read -r -d '' grubembedcfg <<'EOF' || true
if ! [ -d "$cmdpath" ]; then
    # On some firmware, GRUB has a wrong cmdpath when booted from an optical disc.
    # https://gitlab.archlinux.org/archlinux/archiso/-/issues/183
    if regexp --set=1:isodevice '^(\([^)]+\))\/?[Ee][Ff][Ii]\/[Bb][Oo][Oo][Tt]\/?$' "$cmdpath"; then
        cmdpath="${isodevice}/EFI/BOOT"
    fi
fi
configfile "${cmdpath}/grub.cfg"
EOF
    printf '%s\n' "$grubembedcfg" > "${work_dir}/grub-embed.cfg"
}

_make_common_bootmode_grub_copy_to_isofs_iso() {
    isofs_dir="${work_dir}/iso"
    _make_common_bootmode_grub_copy_to_isofs "${isofs_dir}"
}

_make_common_bootmode_grub_copy_to_isofs_dongle() {
    dongle_isofs_dir="${work_dir}/dongle_iso"
    _make_common_bootmode_grub_copy_to_isofs "${dongle_isofs_dir}"
}

# $1: directory where the content of the ISO file system resides
_make_common_bootmode_grub_copy_to_isofs() {
    local isofs_dir="${1}"
    local files_to_copy=()

    files_to_copy+=("${work_dir}/grub/"*'.cfg')
    if compgen -G "${profile}/grub/!(*.cfg)" &> /dev/null; then
        files_to_copy+=("${profile}/grub/"!(*.cfg))
    fi
    install -m 0644 -- "${files_to_copy[@]}" "${isofs_dir}/EFI/BOOT/"
}

# Minimum GRUB module list to open a luks2 image
# Module list from https://bugs.archlinux.org/task/71382#comment202911
# $1: 'bios' or 'efi'
_get_grubmodules(){
    local _mode="${1}"
    _modules=(afsplitter boot bufio chain configfile cryptodisk disk echo ext2 gcry_rijndael
              gcry_sha256 gcry_sha512 halt iso9660 linux loadenv loopback luks2 minicmd
              normal part_apple part_gpt part_msdos password_pbkdf2 reboot search test
              search_fs_uuid usb)
    if [ "${_mode}" != "bios" ]; then
        _modules+=(at_keyboard all_video btrfs cat echo diskfilter echo efifwsetup f2fs
                   fat font gcry_crc gfxmenu gfxterm gzio hfsplus jpeg keylayouts ls
                   lsefi lsefimmap lzopio ntfs png read regexp search_fs_file search_label
                   serial sleep tpm trig usbserial_common usbserial_ftdi usbserial_pl2303
                   usbserial_usbdebug video xfs zstd)
    elif [ "${_mode}" == "bios" ] ; then
        _modules+=(biosdisk)
    fi
    echo "${_modules[*]}"
}

# Prepares GRUB (32-bit) for EFI boot
# $1: device type ('iso', 'dongle')
_make_bootmode_uefi-ia32.grub.esp() {
    local bootable="${1}"

    # Prepare configuration files
    _run_once _make_common_bootmode_grub_cfg

    # Create EFI binary
    grub-mkstandalone -O i386-efi \
                      --modules="$(_get_grubmodules "efi")" \
                      --locales="en@quot" \
                      --themes="" \
                      --sbat=/usr/share/grub/sbat.csv \
                      --disable-shim-lock \
                      -o "${work_dir}/BOOTIA32.EFI" "boot/grub/grub.cfg=${work_dir}/grub-embed.cfg"

    # Add GRUB to the list of files used to calculate the required FAT image size.
    efi_boot_files+=("${work_dir}/BOOTIA32.EFI"
                     "${pacstrap_dir}/usr/share/edk2-shell/ia32/Shell_Full.efi")

    if [[ " ${bootmodes[*]} " =~ uefi-x64.systemd-boot.esp ]]; then
        # TODO: Remove this branch.
        _run_once "_make_bootmode_uefi-x64.systemd-boot.esp_${bootable}"
    elif [[ " ${bootmodes[*]} " =~ uefi-x64.grub.esp ]]; then
        _run_once "_make_bootmode_uefi-x64.grub.esp_${bootable}"
    else
        efi_boot_size="$(du -bcs -- "${efi_boot_files[@]}" 2>/dev/null | awk 'END { print $1 }')"
        # Create a FAT image for the EFI system partition
        _make_efi_boot_img "${efi_boot_size}"
    fi

    # Copy GRUB EFI binary to the default/fallback boot path
    mcopy -D o -i "${efi_boot_img}" "${work_dir}/BOOTIA32.EFI" ::/EFI/BOOT/BOOTIA32.EFI

    # Copy GRUB files
    _run_once _make_common_bootmode_grub_copy_to_efi_boot_img

    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/ia32/Shell_Full.efi" ]]; then
        mcopy -D o -i "${efi_boot_img}" "${pacstrap_dir}/usr/share/edk2-shell/ia32/Shell_Full.efi" ::/shellia32.efi
    fi

    _msg_info "Done! GRUB set up for UEFI booting successfully."
}

# Prepares GRUB (32 bit) for UEFI the ISO image
_make_bootmode_uefi-ia32.grub.esp_iso() {
    _make_bootmode_uefi-ia32.grub.esp "iso"
}

# Prepares GRUB (32 bit) for UEFI the dongle ISO image
_make_bootmode_uefi-ia32.grub.esp_dongle() {
    _make_bootmode_uefi-ia32.grub.esp "dongle"
}

# Prepares GRUB (32 bit) for El Torito booting
# $1: root file system for GRUB
# $2: device type ('iso' or 'dongle')
_make_bootmode_uefi-ia32.grub.eltorito() {
    local bootable_dir="${1}"
    local bootable="${2}"
    # El Torito UEFI boot requires an image containing the EFI system partition.
    # uefi-ia32.grub.eltorito has the same requirements as uefi-ia32.grub.esp
    _run_once "_make_bootmode_uefi-ia32.grub.esp_${bootable}"

    # Prepare configuration files
    _run_once _make_common_bootmode_grub_cfg

    # Additionally set up systemd-boot in ISO 9660. This allows creating a medium for the live environment by using
    # manual partitioning and simply copying the ISO 9660 file system contents.
    # This is not related to El Torito booting and no firmware uses these files.
    _msg_info "Preparing an /EFI directory for the ISO 9660 file system..."
    install -d -m 0755 -- "${bootable_dir}/EFI/BOOT"

    # Copy GRUB EFI binary to the default/fallback boot path
    install -m 0644 -- "${work_dir}/BOOTIA32.EFI" "${bootable_dir}/EFI/BOOT/BOOTIA32.EFI"

    # Copy GRUB configuration files
    _run_once "_make_common_bootmode_grub_copy_to_isofs_${bootable}"

    # edk2-shell based UEFI shell
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/ia32/Shell_Full.efi" ]]; then
        install -m 0644 -- "${pacstrap_dir}/usr/share/edk2-shell/ia32/Shell_Full.efi" "${bootable_dir}/shellia32.efi"
    fi

    _msg_info "Done!"
}

# Prepares GRUB (32 bit) El Torito for UEFI on the ISO image
_make_bootmode_uefi-ia32.grub.eltorito_iso() {
    _make_bootmode_uefi-ia32.grub.eltorito "${isofs_dir}" "iso"
}
 
# Prepares GRUB (32 bit) El Torito for UEFI on the dongle ISO image
_make_bootmode_uefi-ia32.grub.eltorito_dongle() {
    _make_bootmode_uefi-ia32.grub.eltorito "${dongle_isofs_dir}" "dongle"
}

# Prepares GRUB for EFI boot
_make_bootmode_uefi-x64.grub.esp() {
    # Prepare configuration files
    _run_once _make_common_bootmode_grub_cfg

    # Create EFI binary
    grub-mkstandalone -O x86_64-efi \
                      --modules="$(_get_grubmodules "efi")" \
                      --locales="en@quot" \
                      --themes="" \
                      --sbat=/usr/share/grub/sbat.csv \
                      --disable-shim-lock \
                      -o "${work_dir}/BOOTx64.EFI" "boot/grub/grub.cfg=${work_dir}/grub-embed.cfg"
    # Add GRUB to the list of files used to calculate the required FAT image size.
    efi_boot_files+=("${work_dir}/BOOTx64.EFI"
                     "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi")

    efi_boot_size="$(du -bcs -- "${efi_boot_files[@]}" 2>/dev/null | awk 'END { print $1 }')"

    # Create a FAT image for the EFI system partition
    _make_efi_boot_img "${efi_boot_size}"

    # Copy GRUB EFI binary to the default/fallback boot path
    mcopy -D o -i "${efi_boot_img}" "${work_dir}/BOOTx64.EFI" ::/EFI/BOOT/BOOTx64.EFI

    # Copy GRUB files
    _run_once _make_common_bootmode_grub_copy_to_efi_boot_img

    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        mcopy -D o -i "${efi_boot_img}" \
                      "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" \
                      "::/shellx64.efi"
    fi

    _msg_info "Done! GRUB set up for UEFI booting successfully."
}
 
# Prepares GRUB for the ISO image
_make_bootmode_uefi-x64.grub.esp_iso() {
    _make_bootmode_uefi-x64.grub.esp
}

# Prepares GRUB for the dongle ISO image
_make_bootmode_uefi-x64.grub.esp_dongle() {
    _make_bootmode_uefi-x64.grub.esp
}

# Prepares GRUB for El Torito booting
# $1: root file system for GRUB
# $2: device type ('iso' or 'dongle')
_make_bootmode_uefi-x64.grub.eltorito() {
    local bootable_dir="${1}"
    local bootable="${2}"
    # El Torito UEFI boot requires an image containing the EFI system partition.
    # uefi-x64.grub.eltorito has the same requirements as uefi-x64.grub.esp
    _run_once "_make_bootmode_uefi-x64.grub.esp_${bootable}"

    # Prepare configuration files
    _run_once _make_common_bootmode_grub_cfg

    # Additionally set up systemd-boot in ISO 9660. This allows creating a medium for the live environment by using
    # manual partitioning and simply copying the ISO 9660 file system contents.
    # This is not related to El Torito booting and no firmware uses these files.
    _msg_info "Preparing an /EFI directory for the ISO 9660 file system..."
    install -d -m 0755 -- "${bootable_dir}/EFI/BOOT"

    # Copy GRUB EFI binary to the default/fallback boot path
    install -m 0644 -- "${work_dir}/BOOTx64.EFI" \
        "${bootable_dir}/EFI/BOOT/BOOTx64.EFI"

    # Copy GRUB files
    _run_once "_make_common_bootmode_grub_copy_to_isofs_${bootable}"

    # edk2-shell based UEFI shell
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        install -m 0644 -- "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" "${bootable_dir}/shellx64.efi"
    fi

    _msg_info "Done!"
}

# Prepares GRUB El Torito for UEFI on the ISO image
_make_bootmode_uefi-x64.grub.eltorito_iso() {
    _make_bootmode_uefi-x64.grub.eltorito "${isofs_dir}" "iso"
}

# Prepares GRUB El Torito for UEFI the dongle ISO image
_make_bootmode_uefi-x64.grub.eltorito_dongle() {
    _make_bootmode_uefi-x64.grub.eltorito "${dongle_isofs_dir}" "dongle"
}

# Prepares systemd-boot for booting when written to a disk (isohybrid)
_make_bootmode_uefi-x64.systemd-boot.esp() {
    local _file efi_boot_size _results
    local _available_ucodes=()
    _msg_info "Setting up systemd-boot for UEFI booting..."

    for _file in "${ucodes[@]}"; do
        if [[ -e "${pacstrap_dir}/boot/${_file}" ]]; then
            _available_ucodes+=("${pacstrap_dir}/boot/${_file}")
        fi
    done
    # Calculate the required FAT image size in bytes
    efi_boot_files+=("${pacstrap_dir}/usr/lib/systemd/boot/efi/systemd-bootx64.efi"
                     "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi"
                     "${profile}/efiboot/"
                     "${_available_ucodes[@]}")
    _images=("initramfs-*" "vmlinuz-*")
    for _query in "${_images[@]}"; do
        mapfile -t efi_boot_files < <(find "${work_dir}" -iname "${_query}" -exec echo {} \; -quit)
    done

    efi_boot_size="$(du -bcs -- "${efi_boot_files[@]}" 2>/dev/null | awk 'END { print $1 }')"
    # Create a FAT image for the EFI system partition
    _make_efi_boot_img "${efi_boot_size}"

    # Copy systemd-boot EFI binary to the default/fallback boot path
    mcopy -D o -i "${efi_boot_img}" \
        "${pacstrap_dir}/usr/lib/systemd/boot/efi/systemd-bootx64.efi" ::/EFI/BOOT/BOOTx64.EFI

    # Copy systemd-boot configuration files
    mmd -D o -i "${efi_boot_img}" ::/loader ::/loader/entries
    mcopy -D o -i "${efi_boot_img}" "${profile}/efiboot/loader/loader.conf" ::/loader/
    for _conf in "${profile}/efiboot/loader/entries/"*".conf"; do
        _build_bootloader_config "${_conf}" "systemd-boot" | mcopy -D o -i "${efi_boot_img}" - "::/loader/entries/${_conf##*/}"
        done

    # shellx64.efi is picked up automatically when on /
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        mcopy -D o -i "${efi_boot_img}" \
            "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ::/shellx64.efi
    fi

    # Copy kernel and initramfs to FAT image.
    # systemd-boot can only access files from the EFI system partition it was launched from.
    _make_boot_on_fat

    _msg_info "Done! systemd-boot set up for UEFI booting successfully."
}

# Prepares systemd-boot for the ISO image
_make_bootmode_uefi-x64.systemd-boot.esp_iso() {
    _make_bootmode_uefi-x64.systemd-boot.esp
}

# Prepares systemd-boot for the dongle ISO image
_make_bootmode_uefi-x64.systemd-boot.esp_dongle() {
    _make_bootmode_uefi-x64.systemd-boot.esp
}

# Prepares systemd-boot for El Torito booting
_make_bootmode_uefi-x64.systemd-boot.eltorito() {
    local bootable_dir="${1}"
    local bootable="${2}"
    # El Torito UEFI boot requires an image containing the EFI system partition.
    # uefi-x64.systemd-boot.eltorito has the same requirements as uefi-x64.systemd-boot.esp
    _run_once "_make_bootmode_uefi-x64.systemd-boot.esp_${bootable}"

    # Additionally set up systemd-boot in ISO 9660. This allows creating a medium for the live environment by using
    # manual partitioning and simply copying the ISO 9660 file system contents.
    # This is not related to El Torito booting and no firmware uses these files.
    _msg_info "Preparing an /EFI directory for the ISO 9660 file system..."
    install -d -m 0755 -- "${bootable_dir}/EFI/BOOT"

    # Copy systemd-boot EFI binary to the default/fallback boot path
    install -m 0644 -- "${pacstrap_dir}/usr/lib/systemd/boot/efi/systemd-bootx64.efi" \
        "${bootable_dir}/EFI/BOOT/BOOTx64.EFI"

    # Copy systemd-boot configuration files
    install -d -m 0755 -- "${bootable_dir}/loader/entries"
    install -m 0644 -- "${profile}/efiboot/loader/loader.conf" "${bootable_dir}/loader/"
    for _conf in "${profile}/efiboot/loader/entries/"*".conf"; do
        _build_bootloader_config "${_conf}" "systemd-boot" > "${bootable_dir}/loader/entries/${_conf##*/}"
        done

    # edk2-shell based UEFI shell
    # shellx64.efi is picked up automatically when on /
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        install -m 0644 -- "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" "${bootable_dir}/shellx64.efi"
    fi

    _msg_info "Done!"
}

# Prepares systemd-boot for El Torito booting on the ISO
_make_bootmode_uefi-x64.systemd-boot.eltorito_iso() {
    _make_bootmode_uefi-x64.systemd-boot.eltorito "${isofs_dir}" "iso"
}

# Prepares systemd-boot for El Torito booting on the dongle ISO
_make_bootmode_uefi-x64.systemd-boot.eltorito_dongle() {
    _make_bootmode_uefi-x64.systemd-boot.eltorito "${dongle_isofs_dir}" "dongle"
}

_validate_common_requirements_bootmode_grub(){
    # Check if GRUB is available
    if ! command -v grub-mkstandalone &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': grub-mkstandalone is not available on this host. Install 'grub'!" 0
    fi

    # Check if GRUB configuration files exist
    if [[ ! -d "${profile}/grub" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The '${profile}/grub' directory is missing!" 0
    else
        if [[ ! -e "${profile}/grub/grub.cfg" ]]; then
            (( validation_error=validation_error+1 ))
            _msg_error "Validating '${bootmode}': File '${profile}/grub/grub.cfg' not found!" 0
        fi
        local conffile
        for conffile in "${profile}/grub/"*'.cfg'; do
            if [[ -e "${conffile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "Validating '${bootmode}': No configuration file found in '${profile}/grub/'!" 0
            fi
        done
    fi
}

_validate_common_requirements_bootmode_uefi(){
    # Check if mkfs.fat is available
    if ! command -v mkfs.fat &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': mkfs.fat is not available on this host. Install 'dosfstools'!" 0
    fi
    # Check if mmd and mcopy are available
    if ! { command -v mmd &> /dev/null && command -v mcopy &> /dev/null; }; then
        _msg_error "Validating '${bootmode}': mmd and/or mcopy are not available on this host. Install 'mtools'!" 0
    fi
}

_validate_requirements_bootmode_bios.grub.mbr() {
    # bios.syslinux.mbr requires bios.grub.eltorito
    # actually I'm not sure this is true
    _validate_common_requirements_bootmode_grub
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' bios.grub.eltorito ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Using 'bios.grub.mbr' boot mode without 'bios.grub.eltorito' is not supported." 0
    fi

    # Check if the grub package is in the package list
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' grub ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The 'grub' package is missing from the package list!" 0
    fi
}

_validate_requirements_bootmode_bios.grub.eltorito() {
    # bios.grub.eltorito has the exact same requirements as bios.grub.mbr
    _validate_requirements_bootmode_bios.grub.mbr
}

_validate_requirements_bootmode_bios.syslinux.mbr() {
    local _msg
    # bios.syslinux.mbr requires bios.syslinux.eltorito
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' bios.syslinux.eltorito ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Using 'bios.syslinux.mbr' boot mode without 'bios.syslinux.eltorito' is not supported." 0
    fi

    # Check if the syslinux package is in the package list
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' syslinux ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The 'syslinux' package is missing from the package list!" 0
    fi

    # Check if syslinux configuration files exist
    if [[ ! -d "${profile}/syslinux" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The '${profile}/syslinux' directory is missing!" 0
    else
        local cfgfile
        for cfgfile in "${profile}/syslinux/"*'.cfg'; do
            if [[ -e "${cfgfile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "Validating '${bootmode}': No configuration file found in '${profile}/syslinux/'!" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' memtest86+ ' ]]; then
        _msg=("Validating '${bootmode}': 'memtest86+' is not in the package list."
              "Memory testing will not be available from syslinux.")
        _msg_info "${_msg[*]}"
    fi
}

_validate_requirements_bootmode_bios.syslinux.eltorito() {
    # bios.syslinux.eltorito has the exact same requirements as bios.syslinux.mbr
    _validate_requirements_bootmode_bios.syslinux.mbr
}

_validate_requirements_bootmode_uefi-x64.systemd-boot.esp() {
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]]; then
        _msg_error "Validating '${bootmode}': cannot be used with bootmode uefi-x64.grub.esp!" 0
    fi

    _validate_common_requirements_bootmode_uefi

    # Check if systemd-boot configuration files exist
    if [[ ! -d "${profile}/efiboot/loader/entries" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The '${profile}/efiboot/loader/entries' directory is missing!" 0
    else
        if [[ ! -e "${profile}/efiboot/loader/loader.conf" ]]; then
            (( validation_error=validation_error+1 ))
            _msg_error "Validating '${bootmode}': File '${profile}/efiboot/loader/loader.conf' not found!" 0
        fi
        local conffile
        for conffile in "${profile}/efiboot/loader/entries/"*'.conf'; do
            if [[ -e "${conffile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "Validating '${bootmode}': No configuration file found in '${profile}/efiboot/loader/entries/'!" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' edk2-shell ' ]]; then
        _msg_info "'edk2-shell' is not in the package list. The ISO will not contain a bootable UEFI shell."
    fi
}

_validate_requirements_bootmode_uefi-x64.systemd-boot.eltorito() {
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.eltorito ' ]]; then
        _msg_error "Validating '${bootmode}': cannot be used with bootmode uefi-x64.grub.eltorito!" 0
    fi

    # uefi-x64.systemd-boot.eltorito has the exact same requirements as uefi-x64.systemd-boot.esp
    _validate_requirements_bootmode_uefi-x64.systemd-boot.esp
}

_validate_requirements_bootmode_uefi-ia32.grub.esp() {
    _validate_common_requirements_bootmode_grub
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]]; then
        _validate_requirements_bootmode_uefi-x64.systemd-boot.esp
    elif [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]]; then
        _validate_requirements_bootmode_uefi-x64.grub.esp
    else
        _msg_error "Validating '${bootmode}': requires one of bootmode uefi-x64.systemd-boot.esp or uefi-x64.grub.esp" 0
    fi
}

_validate_requirements_bootmode_uefi-ia32.grub.eltorito() {
    # uefi-ia32.grub.eltorito has the exact same requirements as uefi-ia32.grub.esp
    _validate_requirements_bootmode_uefi-ia32.grub.esp
}

_validate_requirements_bootmode_uefi-x64.grub.esp() {
    _validate_common_requirements_bootmode_uefi
    _validate_common_requirements_bootmode_grub
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]]; then
        _msg_error "Validating '${bootmode}': cannot be used with bootmode uefi-x64.systemd-boot.esp!" 0
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' edk2-shell ' ]]; then
        _msg_info "'edk2-shell' is not in the package list. The ISO will not contain a bootable UEFI shell."
    fi
}

_validate_requirements_bootmode_uefi-x64.grub.eltorito() {
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' ]]; then
        _msg_error "Validating '${bootmode}': cannot be used with bootmode uefi-x64.systemd-boot.eltorito!" 0
    fi
    # uefi-x64.grub.eltorito has the exact same requirements as uefi-x64.grub.esp
    _validate_requirements_bootmode_uefi-x64.grub.esp
}

# Resolves the value of an image encryption key from an <image>_encryption_key
# profiledef.sh variable
# $1: a value in fs_images
_resolve_secondary_encryption_key() {
    local _name="${1}"
    local _encryption_key _image_type
    _image_type=$(eval echo \$"{${_name}_image_type}")
    _encryption_key=$(eval echo \$"{${_name}_encryption_key}")
    if [[ "${_image_type}" == *"luks" ]]; then
        if [[ "${_encryption_key}" == "auto" ]]; then
            _msg_info "Random plaintext password for ${_name}"
            if [[ "${airootfs_image_type}" != *"luks" ]] && \
               [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
                _encryption_key="${work_dir}/${_name}.key"
                _install_dir="${dongle_persistent_dir}/etc/cryptsetup-keys.d"
                eval "${_name}_encryption_key=\"${_encryption_key}\""
                _gen_key "${_encryption_key}" "plain"
                install -d -m700 "${_install_dir}"
                install -D -m400 "${_encryption_key}" "${_install_dir}"
            fi
        elif [[ "${airootfs_image_type}" == *"luks" ]] && \
             [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            _encryption_key="${work_dir}/${_name}.key"
            _install_dir="${pacstrap_dir}/etc/keys"
            #_install_dir="${pacstrap_dir}/etc/cryptsetup-keys.d/${_name}.keys"
            eval "${_name}_encryption_key=\"${_encryption_key}\""
            _gen_key "${_encryption_key}" "binary"
            install -d -m700 "${_install_dir}"
            install -D -m400 "${_encryption_key}" "${_install_dir}"
        elif [[ "${airootfs_image_type}" != *"luks" ]] && \
             [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            _encryption_key="${work_dir}/${_name}.key"
            _install_dir="${dongle_persistent_dir}/etc/keys"
            # _install_dir="${pacstrap_dir}/etc/cryptsetup-keys.d/${_name}.keys"
            eval "${_name}_encryption_key=\"${_encryption_key}\""
            _gen_key "${_encryption_key}" "binary"
            install -d -m700 "${_install_dir}"
            install -D -m400 "${_encryption_key}" "${_install_dir}"
        elif [[ "${airootfs_image_type}" != *"luks" ]] && \
             [[ "${_name}" != "persistent" ]] && \
             ! [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            _encryption_key="${work_dir}/${_name}.key"
            _install_dir="${persistent_dir}/etc/cryptsetup-keys.d"
            eval "${_name}_encryption_key=\"${_encryption_key}\""
            _gen_key "${_encryption_key}" "binary"
            install -d -m700 "${_install_dir}"
            install -D -m400 "${_encryption_key}" "${_install_dir}"
        else
            _msg=("Rootfs encryption and dongle buildmode disabled."
                  "You will be prompted to insert a password for the ${_name} partition.")
            _msg_warning "${_msg[*]}"
            eval "${_name}_encryption_key="
        fi
    fi
}

# Returns install path of airootfs image
_get_airootfs_path(){
    echo "${install_dir}/${arch}/airootfs.$(_get_fs_ext "airootfs")"
}

# Returns workdir airootfs image path
_get_airootfs_img(){
    echo "${airootfs_dir}/airootfs.$(_get_fs_ext "airootfs")"
}

# Builds airootfs filesystem image
_prepare_airootfs_image() {
    local _sig_dir _pacstrap_size

    _pacstrap_size=$(du -s "${pacstrap_dir}" | cut -f 1)
    airootfs_size=$((_pacstrap_size+200000))

    _run_once "_mkairootfs_common"
    _run_once "_mkairootfs_${airootfs_image_type}"
    _mkchecksum "$(_get_airootfs_img)"
    if [[ -n "${gpg_key}" ]]; then
        _mksignature "$(_get_airootfs_img)"
        if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            dongle_isofs_dir="${work_dir}/dongle_iso"
            dongle_persistent_dir="${work_dir}/dongle_persistent"
            dongle_boot_dir="${work_dir}/dongle_boot"
            _sig_dir="${dongle_isofs_dir}/${install_dir}/${arch}"
            install -d -m711 "${_sig_dir}"
            cp "$(_get_airootfs_img).sig" "${_sig_dir}"
        fi
    fi
}

# Builds keys filesystem image
_prepare_keys_image() {
    keys_size=69420
    _run_once "_mkkeys_common"
    _run_once "_mkkeys_${keys_image_type}"

    _mkchecksum "${dongle_isofs_dir}/keys.$(_get_fs_ext "keys")"
    if [[ -n "${gpg_key}" ]]; then
        _mksignature "${dongle_isofs_dir}/keys.$(_get_fs_ext "keys")"
    fi
}

# Builds swap filesystem image
_prepare_swap_image() {
    if [ "${swap_size}" != "" ] || [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _resolve_secondary_encryption_key "swap"
        _run_once "_mkswap_common"
        _run_once "_mkswap_${swap_image_type}"
    fi
}

# Builds dongle swap filesystem image
_prepare_dongle_swap_image() {
    if [ "${swap_size}" != "" ] && [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _resolve_secondary_encryption_key "dongle_swap"
        if [[ "${dongle_swap_size}" == "" ]]; then
            dongle_swap_size="${swap_size}"
        fi
        _run_once "_mkdongle_swap_common"
        _run_once "_mkdongle_swap_${swap_image_type}"
    fi
}

# Builds recovery filesystem image
_prepare_recovery_image() {
    local _pacstrap_size

    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
       [[ "${recovery}" == "true" ]]; then
        if [ "${airootfs_size}" = "" ]; then
            _pacstrap_size=$(du -s "${pacstrap_dir}" | cut -f 1)
            airootfs_size=$((_pacstrap_size+200000))
            recovery_size="${airootfs_size}"
        fi
        _run_once "_mkrecovery_common"
        _run_once "_mkrecovery_${recovery_image_type}"
    fi
}

# Checks whether an image's file system path is present in the profile directories
# $1: file system path
_is_file_in_work_paths() {
    local _filename="${1}"
    local _dir
    local _dirs=("${profile}/airootfs"
                 "${profile}/persistent")
    _pass="false"
    for _dir in "${_dirs[@]}"; do
        if [ -e "${_dir}${_filename}" ]; then
            _pass=""
        fi
    done
}

# Checks if an image's file system path can be applied permissions on
# $1: filename path
# $2: image name (airootfs, persistent)
_validate_file() {
    local _filename="${1}"
    local _storage="${2}"
    local pacstrap_dir="${work_dir}/${arch}/airootfs"
    local persistent_dir="${work_dir}/persistent"
    _validate_file_result="false"
    _validate_file_err="" _validate_file_warn=""
    _is_file_in_work_paths "${_filename}"
    if [[ "${_pass}" != "" ]]; then
        _validate_file_err="Cannot change permissions of '${_filename}'. The file or directory does not exist."
        return
    fi
    if [[ ! -e "${_storage}${_filename}" ]]; then
        _validate_file_warn="Cannot change permissions of '${_storage}${_filename}'. The file or directory does not exist on this storage."
    elif [[ "$(realpath -q -- "${_storage}${_filename}")" != "${_storage}"* ]]; then
        _validate_file_err="Failed to set permissions on '${_storage}${_filename}'. Outside of valid path."
    else
        _validate_file_result=""
    fi
}

# Copies custom files onto an image, reading and applying permissions from a file
# $1: destination image name (airootfs, persistent)
# $2: output directory
_copy_custom_files() {
    local _dest="${1}"
    local _out_dir="${2}"
    local _error_code _msg=()
    local _opts=('-f') _chmod_opts=() _recur=()
    _msg_info "Copying custom ${_dest} files..."
    cp -af --no-preserve=ownership,mode -- "${profile}/${_dest}/." "${_out_dir}"
    for filename in "${!file_permissions[@]}"; do
        IFS=':' read -ra permissions <<< "${file_permissions["${filename}"]}"
        _user="${permissions[0]}" _group="${permissions[1]}" _perm="${permissions[2]}"
        _recur=()
        _validate_file_err="" _validate_file_warn="" _validate_file_result=""
        _validate_file "${filename}" "${_out_dir}"
        if [[ "${_validate_file_result}" == "" ]]; then
            _msg=("Setting" "${_perm} permissions for ${_user}:${_group} on ${filename}")
            if [[ "${filename: -1}" == "/" ]]; then
                _recur+=('-R')
                _msg+=("recursively")
            fi
            [[ "${quiet}" != "y" ]] && _msg_info "${_msg[*]}"
            _chown_opts=("${_opts[@]}" '-h' "${_recur[@]}")
            _chmod_opts=("${_opts[@]}" "${_recur[@]}")
            chown "${_chown_opts[@]}" -- "${_user}:${_group}" "${_out_dir}${filename}"
            chmod "${_chmod_opts[@]}" -- "${_perm}" "${_out_dir}${filename}"
         else
             _msg_type="warning"
	     if [ "${_validate_file_err}" != "" ]; then
	         _msg_type="error"
	         _error_code=1
	     fi
             [[ "${_validate_file_err}" != "" ]] && "_msg_${_msg_type}" "${_validate_file_err}" "${_error_code}"
             [[ "${quiet}" != "y" ]] && [[ "${_validate_file_warn}" != "" ]] && "_msg_${_msg_type}" "${_validate_file_warn}"
         fi
    done
}

# Build persistent filesystem image
_prepare_persistent_image() {
    local pacstrap_dir="${work_dir}/${arch}/airootfs"
    local persistent_dir="${work_dir}/persistent"
    local persistent_dir_size persistent_epoch persistent_uuid
    local crypttab="${profile}/airootfs/etc/crypttab"
    persistent_epoch="$(_get_epoch "persistent")"
    persistent_uuid="$(_get_epoch_fsuuid "${persistent_epoch}")"
    dongle_persistent_epoch=$(_get_epoch "dongle_persistent")
    dongle_persistent_uuid=$(_get_dongle_persistent_uuid)

    local persistent_ro_udev_rule="${pacstrap_dir}/etc/udev/rules.d/98_persistent.rules"
    local dongle_persistent_ro_udev_rule="${pacstrap_dir}/etc/udev/rules.d/99_donglepersistent.rules"
    if [ -d "${profile}/persistent" ]; then
        _copy_custom_files "persistent" "${persistent_dir}"
        persistent_dir_size=$(du -s "${persistent_dir}" | cut -f 1)
        persistent_size=$(( persistent_dir_size > persistent_size ? persistent_dir_size : persistent_size ))
        _msg_info "Done!"
    fi
    _build_crypttab "${crypttab}" "${pacstrap_dir}/etc/crypttab"
    _fill_persistent_ro_udev_rules "${persistent_ro_udev_rule}"
    _fill_persistent_ro_udev_rules "${dongle_persistent_ro_udev_rule}"
    if [ "${persistent_size}" != "" ] || \
       [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _resolve_secondary_encryption_key "persistent"
        _run_once _make_boot_on_dongle
        _run_once "_mkpersistent_common"
        _run_once "_mkpersistent_${persistent_image_type}"
        if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            [ "${dongle_persistent_size}" = "" ] && dongle_persistent_size="${persistent_size}"
            _run_once "_mkdongle_persistent_common"
            _run_once "_mkdongle_persistent_${dongle_persistent_image_type}"
        fi
    fi
}

_prepare_dongle_boot_image() {
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        dongle_boot_size=169042 # 169.042 MB
        _run_once "_mkdongle_boot_common"
        _run_once "_mkdongle_boot_${dongle_boot_image_type}"
    fi
}

# export build artifacts for netboot
_export_netboot_artifacts() {
    _msg_info "Exporting netboot artifacts..."
    install -d -m 0755 "${out_dir}"
    cp -a -- "${isofs_dir}/${install_dir}/" "${out_dir}/"
    _msg_info "Done!"
    du -hs -- "${out_dir}/${install_dir}"
}

# sign build artifacts for netboot
_sign_netboot_artifacts() {
    local _file _dir
    local _files_to_sign=()
    _msg_info "Signing netboot artifacts..."
    _dir="${isofs_dir}/${install_dir}/boot"
    for _file in "${ucodes[@]}"; do
        if [[ -e "${_dir}/${_file}" ]]; then
            _files_to_sign+=("${_dir}/${_file}")
        fi
    done
    for _file in "${_files_to_sign[@]}" "${_dir}/${arch}/vmlinuz-"* "${_dir}/${arch}/initramfs-"*.img; do
        openssl cms \
            -sign \
            -binary \
            -noattr \
            -in "${_file}" \
            -signer "${cert_list[0]}" \
            -inkey "${cert_list[1]}" \
            -outform DER \
            -out "${_file}".ipxe.sig
        done
        _msg_info "Done!"
}

_validate_requirements_airootfs_image_type_squashfs() {
    if ! command -v mksquashfs &> /dev/null; then
        (( validation_error=validation_error+1 ))
        local _msg=("Validating '${airootfs_image_type}': mksquashfs is not available on this host. "
                    "Install 'squashfs-tools'!")
        _msg_error "${_msg[*]}" 0
    fi
}

_validate_requirements_airootfs_image_type_ext4() {
    if ! { command -v mkfs.ext4 &> /dev/null && command -v tune2fs &> /dev/null; }; then
        (( validation_error=validation_error+1 ))
        local _msg=("Validating '${airootfs_image_type}': mkfs.ext4 and/or tune2fs is not available on this host. "
                    "Install 'e2fsprogs'!")
        _msg_error "${_msg[*]}" 0
    fi
}

_validate_requirements_airootfs_image_type_ext4+squashfs() {
    _validate_requirements_airootfs_image_type_ext4
    _validate_requirements_airootfs_image_type_squashfs
}

_validate_requirements_persistent_image_type_ext4() {
    local _msg
    local persistent_ro_udev_rule="${profile}/airootfs/etc/udev/rules.d/98_persistent.rules"
    local dongle_persistent_ro_udev_rule="${profile}/airootfs/etc/udev/rules.d/99_donglepersistent.rules"
    _validate_requirements_airootfs_image_type_ext4
    if [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _msg=("Persistent image not encrypted."
                    "Be sure not to put sensitive data on it and write the resulting image on a write-once device.")
        _msg_warning "${_msg[*]}"
    fi
     if [ ! -e "${persistent_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${persistent_image_type}' for persistent partition: udev rule not found!" 0
    fi
    if [ ! -e "${dongle_persistent_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${dongle_persistent_image_type}' for dongle persistent partition: udev rule not found!" 0
    fi
}

_validate_requirements_persistent_image_type_ext4+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_persistent_image_type_ext4
    if [ ! -e "${profile}/airootfs/etc/crypttab" ]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${persistent_image_type}' for persistent partition: crypttab not found!" 0
    fi
}

# Generates an encryption key when the "auto" value has been specified for an
# <image>_encryption_key variable in profiledef.sh
# $1: output file path
# $2: mode (binary/random plain)
_gen_key() {
    local _out="${1}"
    local _mode="${2}"
    if [ "${_mode}" == "binary" ]; then
        dd if=/dev/random bs=512 count=1 of="${_out}" > /dev/null 2>&1
    elif [ "${_mode}" == "plain" ]; then
        printf "%s" "$(tr -dc A-Za-z0-9 </dev/urandom | head -c 20 ; echo '')" > "${_out}"
    fi
}

# Resolves the value of the airootfs image encryption key 
_resolve_encryption_key(){
    if [ ! -f "${airootfs_encryption_key}" ]; then
        if [ "${airootfs_encryption_key}" = 'auto' ]; then
            airootfs_encryption_key="${work_dir}/${iso_label}.key"
            [ ! -d "${work_dir}" ] && install -d "${work_dir}"
            _gen_key "${airootfs_encryption_key}" "binary"
        elif [ "${airootfs_encryption_key}" != 'auto' ]; then
            _msg_error "File '${airootfs_encryption_key}' does not exist." 0
        fi
    fi
}

_validate_requirements_airootfs_image_type_squashfs+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_airootfs_image_type_squashfs
}

_validate_requirements_airootfs_image_type_ext4+squashfs+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_airootfs_image_type_squashfs
    _validate_requirements_airootfs_image_type_ext4
}

_validate_requirements_airootfs_image_type_erofs() {
    if ! command -v mkfs.erofs &> /dev/null; then
        (( validation_error=validation_error+1 ))
        local _msg=("Validating '${airootfs_image_type}': mkfs.erofs is not available on this host."
                    " Install 'erofs-utils'!")
        _msg_error "${_msg[*]}" 0
    fi
}

_validate_requirements_airootfs_image_type_luks() {
    if ! command -v cryptsetup &> /dev/null; then
        (( validation_error=validation_error+1 ))
        local _msg=("Validating '${airootfs_image_type}': cryptsetup is not available on this host."
                    "Install 'cryptsetup'!")
        _msg_error "${_msg[*]}" 0
    fi
    [[ -n "$airootfs_encryption_key" ]] && _resolve_encryption_key 
}

_validate_requirements_airootfs_image_type_erofs+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_airootfs_image_type_erofs
}

_validate_common_requirements_buildmode_all() {
    local _msg=()
    if ! command -v pacman &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': pacman is not available on this host. Install 'pacman'!" 0
    fi
    if ! command -v find &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': find is not available on this host. Install 'findutils'!" 0
    fi
    if ! command -v gzip &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': gzip is not available on this host. Install 'gzip'!" 0
    fi
    if [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]] && [[ "${persistent_image_type}" != *"luks" ]]; then
        _msg=("Validating build mode '${_buildmode}':"
              "'dongle' build mode not selected; persistent partition encryption disabled."
              "Be sure to use the resulting image on a write-once device to not be vulnerable to 'evil maids'.")
        _msg_warning "${_msg[*]}"
    fi
}

_validate_requirements_buildmode_bootstrap() {
    local bootstrap_pkg_list_from_file=()

    # Check if packages for the bootstrap image are specified
    if [[ -e "${bootstrap_packages}" ]]; then
        mapfile -t bootstrap_pkg_list_from_file < \
            <(sed '/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d' "${bootstrap_packages}")
        bootstrap_pkg_list+=("${bootstrap_pkg_list_from_file[@]}")
        if (( ${#bootstrap_pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "No package specified in '${bootstrap_packages}'." 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Bootstrap packages file '${bootstrap_packages}' does not exist." 0
    fi

    _validate_common_requirements_buildmode_all
    if ! command -v bsdtar &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': bsdtar is not available on this host. Install 'libarchive'!" 0
    fi
}

_validate_common_requirements_buildmode_iso_netboot() {
    local bootmode
    local pkg_list_from_file=()
    local _msg=()

    # Check if the package list file exists and read packages from it
    if [[ -e "${packages}" ]]; then
        mapfile -t pkg_list_from_file < <(sed '/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d' "${packages}")
        pkg_list+=("${pkg_list_from_file[@]}")
        if (( ${#pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "No package specified in '${packages}'." 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Packages file '${packages}' does not exist." 0
    fi

    # Check if the specified airootfs_image_type is supported
    if typeset -f "_mkairootfs_${airootfs_image_type}" &> /dev/null; then
        if typeset -f "_validate_requirements_airootfs_image_type_${airootfs_image_type}" &> /dev/null; then
            "_validate_requirements_airootfs_image_type_${airootfs_image_type}"
        else
            _msg=("Function '_validate_requirements_airootfs_image_type_${airootfs_image_type}' does not exist."
                  "Validating the requirements of '${airootfs_image_type}' airootfs image type will not be possible.")
            _msg_warning "${_msg[*]}"
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Unsupported image type: '${airootfs_image_type}'" 0
    fi
}

_validate_requirements_buildmode_dongle() {
    _validate_common_requirements_buildmode_all
    [[ -n "$airootfs_encryption_key" ]] && _resolve_encryption_key
    if [[ ! "${airootfs_image_type}" == *luks ]]; then
        _msg_warning "Dongle buildmode active but root file system encryption disabled."
    fi
}

_validate_requirements_buildmode_iso() {
    local _msg=()
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    # Check if the specified bootmodes are supported
    if (( ${#bootmodes[@]} < 1 )); then
        (( validation_error=validation_error+1 ))
        _msg_error "No boot modes specified in '${profile}/profiledef.sh'." 0
    fi
    for bootmode in "${bootmodes[@]}"; do
        if typeset -f "_make_bootmode_${bootmode}" &> /dev/null; then
            if typeset -f "_validate_requirements_bootmode_${bootmode}" &> /dev/null; then
                "_validate_requirements_bootmode_${bootmode}"
            else
                _msg=("Function '_validate_requirements_bootmode_${bootmode}' does not exist."
                      "Validating the requirements of '${bootmode}' boot mode will not be possible.")
                _msg_warning "${_msg[*]}"
            fi
        else
            (( validation_error=validation_error+1 ))
            _msg_error "${bootmode} is not a valid boot mode!" 0
        fi
    done

    if ! command -v awk &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': awk is not available on this host. Install 'awk'!" 0
    fi

    # Check if the profile supports the specified persistent_image_type
    if typeset -f "_mkpersistent_${persistent_image_type}" &> /dev/null; then
        if typeset -f "_validate_requirements_persistent_image_type_${persistent_image_type}" &> /dev/null; then
            "_validate_requirements_persistent_image_type_${persistent_image_type}"
        else
            _msg=("Function '_validate_requirements_persistent_image_type_${persistent_image_type}' does not exist."
                  "Validating the requirements of '${persistent_image_type}' airootfs image type will not be possible.")
            _msg_warning "${_msg[*]}"
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Unsupported image type for persistent partition: '${persistent_image_type}'" 0
    fi
}

_validate_requirements_buildmode_netboot() {
    local _override_cert_list=()

    if [[ "${sign_netboot_artifacts}" == "y" ]]; then
        # Check if the certificate files exist
        for _cert in "${cert_list[@]}"; do
            if [[ -e "${_cert}" ]]; then
                _override_cert_list+=("$(realpath -- "${_cert}")")
            else
                (( validation_error=validation_error+1 ))
                _msg_error "File '${_cert}' does not exist." 0
            fi
        done
        cert_list=("${_override_cert_list[@]}")
        # Check if there are at least two certificate files
        if (( ${#cert_list[@]} < 2 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "Two certificates are required for codesigning, but '${cert_list[*]}' is provided." 0
        fi
    fi
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    if ! command -v openssl &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': openssl is not available on this host. Install 'openssl'!" 0
    fi
}

# Add boot partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_boot() {
    local _img _xorrisofs_options=("$@")
    boot_guid="${luks_guid}"
    if [[ "${buildmode}" == "dongle" ]]; then
        _img="${dongle_boot_img}"
    else
        _img="${boot_img}"
    fi
    _xorrisofs_options+=('-append_partition' '3' "${boot_guid}" "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add recovery partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_recovery() {
    local _img _xorrisofs_options=("$@")
    recovery_guid="${luks_guid}"
    _img="${recovery_img}"
    _xorrisofs_options+=('-append_partition' '4' "${recovery_guid}" "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add swap partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_swap() {
    local _img _swap_guid _xorrisofs_options=("$@")
    _img="${swap_img}"
    if [[ "${swap_image_type}" == *"luks" ]]; then
        _swap_guid="${luks_guid}"
    else
        _swap_guid="${swap_guid}"
    fi
    _xorrisofs_options+=('-append_partition' '5' "${_swap_guid}" "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add persistent partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_persistent() {
    local _img _xorrisofs_options=("$@")
    if [[ "${persistent_image_type}" == *"luks" ]]; then
        persistent_guid="${luks_guid}"
    else
        persistent_guid="${linux_guid}"
    fi
    if [[ "${buildmode}" == "dongle" ]]; then
        _img="${dongle_persistent_img}"
    else
        _img="${persistent_img}"
    fi
    _xorrisofs_options+=('-append_partition' '6' "${persistent_guid}" "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add GRUB (isohybrid) options to a xorrisofs options array
# $1: root directory for the bootloader
# $@: xorrisofs_options array
_add_xorrisofs_options_bios.grub.mbr() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
        # SYSLINUX MBR bootstrap code; does not work without "-eltorito-boot syslinux/isolinux.bin"
        '--grub2-mbr' "${bootable_dir}/EFI/BOOT/boot_hybrid.img"
        # When GPT is used, create an additional partition in the MBR (besides 0xEE) for sectors 0â€“1 (MBR
        # bootstrap code area) and mark it as bootable
        # May allow booting on some systems
        # https://wiki.archlinux.org/title/Partitioning#Tricking_old_BIOS_into_booting_from_GPT
        '--mbr-force-bootable'
        # Move the first partition away from the start of the ISO to match the expectations of partition editors
        # May allow booting on some systems
        # https://dev.lovelyhq.com/libburnia/libisoburn/src/branch/master/doc/partition_offset.wiki
        '-partition_offset' '16')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.grub.mbr_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_bios.grub.mbr "${isofs_dir}" "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.grub.mbr_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_bios.grub.mbr "${dongle_isofs_dir}" "${dongle_xorrisofs_options[@]}")")
}

# Add GRUB El Torito options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_bios.grub.eltorito() {
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(# El Torito boot image for x86 BIOS
                         '-eltorito-boot' 'EFI/BOOT/BOOTIA32.ELTORITO'
                         # El Torito boot catalog file
                         '-eltorito-catalog' 'EFI/BOOT/boot.catalog'
                         # Required options to boot with GRUB
                         '-no-emul-boot' '-boot-load-size' '4' '-boot-info-table' '--grub2-boot-info')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.grub.eltorito_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_bios.grub.eltorito "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.grub.eltorito_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_bios.grub.eltorito "${dongle_xorrisofs_options[@]}")")
}

# Add SYSLINUX MBR (isohybrid) options to a xorrisofs options array
# $1: root directory for the bootloader
# $@: options array
_add_xorrisofs_options_bios.syslinux.mbr() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
        # SYSLINUX MBR bootstrap code; does not work without "-eltorito-boot syslinux/isolinux.bin"
        '-isohybrid-mbr' "${bootable_dir}/syslinux/isohdpfx.bin"
        # When GPT is used, create an additional partition in the MBR (besides 0xEE) for sectors 0â€“1 (MBR
        # bootstrap code area) and mark it as bootable
        # May allow booting on some systems
        # https://wiki.archlinux.org/title/Partitioning#Tricking_old_BIOS_into_booting_from_GPT
        '--mbr-force-bootable'
        # Move the first partition away from the start of the ISO to match the expectations of partition editors
        # May allow booting on some systems
        # https://dev.lovelyhq.com/libburnia/libisoburn/src/branch/master/doc/partition_offset.wiki
        '-partition_offset' '16'
    )
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.syslinux.mbr_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_bios.syslinux.mbr "${isofs_dir}" "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.syslinux.mbr_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_bios.syslinux.mbr "${dongle_isofs_dir}" "${dongle_xorrisofs_options[@]}")")
}

# Add SYSLINUX El Torito options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_bios.syslinux.eltorito() {
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(# El Torito boot image for x86 BIOS
                         '-eltorito-boot' 'syslinux/isolinux.bin'
                         # El Torito boot catalog file
                         '-eltorito-catalog' 'syslinux/boot.cat'
                         # Required options to boot with ISOLINUX
                         '-no-emul-boot' '-boot-load-size' '4' '-boot-info-table')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.syslinux.eltorito_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_bios.syslinux.eltorito "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.syslinux.eltorito_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_bios.syslinux.eltorito "${dongle_xorrisofs_options[@]}")")
}

# GRUB in an attached EFI system partition
_add_xorrisofs_options_uefi-ia32.grub.esp() {
    local _xorrisofs_options=("$@")
    # TODO: how does the bootmodes systemd-boot vs x64.grub affect ${bootmodes[*]} tests in _add_xorrisofs_options_uefi-x64.systemd-boot.esp etc?
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' && ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]]; then
        # _add_xorrisofs_options_uefi-x64.systemd-boot.esp
        _xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.esp "${_xorrisofs_options[@]}")")
    fi
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-ia32.grub.esp_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-ia32.grub.esp "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-ia32.grub.esp_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-ia32.grub.esp "${dongle_xorrisofs_options[@]}")")
}

# GRUB via El Torito
_add_xorrisofs_options_uefi-ia32.grub.eltorito() {
    local _xorrisofs_options=("$@")
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' && ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.eltorito ' ]]; then
        # _add_xorrisofs_options_uefi-x64.systemd-boot.eltorito
        _xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.eltorito "${_xorrisofs_options[@]}")")
    fi
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-ia32.grub.eltorito_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-ia32.grub.eltorito "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-ia32.grub.eltorito_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-ia32.grub.eltorito "${dongle_xorrisofs_options[@]}")")
}

# systemd-boot in an attached EFI system partition
_add_xorrisofs_options_uefi-x64.systemd-boot.esp() {
    local _xorrisofs_options=("$@")
    # Move the first partition away from the start of the ISO, otherwise the GPT will not be valid and ISO 9660
    # partition will not be mountable
    # shellcheck disable=SC2076
    [[ " ${_xorrisofs_options[*]} " =~ ' -partition_offset ' ]] || _xorrisofs_options+=('-partition_offset' '16')
    # Attach efiboot.img as a second partition and set its partition type to "EFI system partition"
    _xorrisofs_options+=('-append_partition' '2' 'C12A7328-F81F-11D2-BA4B-00A0C93EC93B' "${efi_boot_img}")
    # Ensure GPT is used as some systems do not support UEFI booting without it
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # A valid GPT prevents BIOS booting on some systems, instead use an invalid GPT (without a protective MBR).
        # The attached partition will have the EFI system partition type code in MBR, but in the invalid GPT it will
        # have a Microsoft basic partition type code.
        if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' &&  ! " ${bootmodes[*]} " =~ ' uefi-ia32.grub.eltorito ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
            # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
            if [[ ! " ${_xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
                _xorrisofs_options+=('-isohybrid-gpt-basdat')
            fi
        fi
    else
        # Use valid GPT if BIOS booting support will not be required
        _xorrisofs_options+=('-appended_part_as_gpt')
    fi
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.systemd-boot.esp_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.systemd-boot.esp "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.systemd-boot.esp_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.systemd-boot.esp "${dongle_xorrisofs_options[@]}")")
}

# systemd-boot via El Torito
_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' || " ${bootmodes[*]} " =~ ' uefi-ia32.grub.esp ' ]]; then
        # systemd-boot in an attached EFI system partition via El Torito
        _xorrisofs_options+=(
            # Start a new El Torito boot entry for UEFI
            '-eltorito-alt-boot'
            # Set the second partition as the El Torito UEFI boot image
            '-e' '--interval:appended_partition_2:all::'
            # Boot image is not emulating floppy or hard disk; required for all known boot loaders
            '-no-emul-boot')
    # A valid GPT prevents BIOS booting on some systems, use an invalid GPT instead.
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
        # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
        # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
        if [[ ! " ${_xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
            _xorrisofs_options+=('-isohybrid-gpt-basdat')
        fi
    fi
    else
        # The ISO will not contain a GPT partition table, so to be able to reference efiboot.img, place it as a
        # file inside the ISO 9660 file system
        install -d -m 0755 -- "${bootable_dir}/EFI/archiso"
        cp -a -- "${efi_boot_img}" "${bootable_dir}/EFI/archiso/efiboot.img"
        # systemd-boot in an embedded efiboot.img via El Torito
        _xorrisofs_options+=(
            # Start a new El Torito boot entry for UEFI
            '-eltorito-alt-boot'
            # Set efiboot.img as the El Torito UEFI boot image
            '-e' 'EFI/archiso/efiboot.img'
            # Boot image is not emulating floppy or hard disk; required for all known boot loaders
            '-no-emul-boot')
    fi
    # Specify where to save the El Torito boot catalog file in case it is not already set by bios.syslinux.eltorito
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' bios.' ]] || _xorrisofs_options+=('-eltorito-catalog' 'EFI/boot.cat')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito "${isofs_dir}" "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito "${dongle_isofs_dir}" "${dongle_xorrisofs_options[@]}")")
}

# GRUB in an attached EFI system partition.
# Same as _add_xorrisofs_options_uefi-x64.systemd-boot.esp.
_add_xorrisofs_options_uefi-x64.grub.esp() {
    local _xorrisofs_options=("$@")
    # Move the first partition away from the start of the ISO, otherwise the GPT will not be valid and ISO 9660
    # partition will not be mountable
    # shellcheck disable=SC2076
    [[ " ${_xorrisofs_options[*]} " =~ ' -partition_offset ' ]] || _xorrisofs_options+=('-partition_offset' '16')
    # Attach efiboot.img as a second partition and set its partition type to "EFI system partition"
    _xorrisofs_options+=('-append_partition' '2' 'C12A7328-F81F-11D2-BA4B-00A0C93EC93B' "${efi_boot_img}")
    # Ensure GPT is used as some systems do not support UEFI booting without it
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # A valid GPT prevents BIOS booting on some systems, instead use an invalid GPT (without a protective MBR).
        # The attached partition will have the EFI system partition type code in MBR, but in the invalid GPT it will
        # have a Microsoft basic partition type code.
        if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.eltorito ' &&  ! " ${bootmodes[*]} " =~ ' uefi-ia32.grub.eltorito ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
            # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
            if [[ ! " ${_xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
                _xorrisofs_options+=('-isohybrid-gpt-basdat')
            fi
        fi
    else
        # Use valid GPT if BIOS booting support will not be required
        _xorrisofs_options+=('-appended_part_as_gpt')
    fi
    echo "${_xorrisofs_options[@]}"
}
    
_add_xorrisofs_options_uefi-x64.grub.esp_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.esp "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.grub.esp_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.esp "${dongle_xorrisofs_options[@]}")")
}

# GRUB via El Torito
# Same as _add_xorrisofs_options_uefi-x64.systemd-boot.eltorito.
_add_xorrisofs_options_uefi-x64.grub.eltorito() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' || " ${bootmodes[*]} " =~ ' uefi-ia32.grub.esp ' ]]; then
        # grub in an attached EFI system partition via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set the second partition as the El Torito UEFI boot image
          '-e' '--interval:appended_partition_2:all::'
          # Boot image is not emulating floppy or hard disk; required for all known boot loaders
          '-no-emul-boot'
        )
    # A valid GPT prevents BIOS booting on some systems, use an invalid GPT instead.
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
        # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
        # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
        if [[ ! " ${_xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
            _xorrisofs_options+=('-isohybrid-gpt-basdat')
        fi
    fi
    else
        # The ISO will not contain a GPT partition table, so to be able to reference efiboot.img, place it as a
        # file inside the ISO 9660 file system
        install -d -m 0755 -- "${bootable_dir}/EFI/archiso"
        cp -a -- "${efi_boot_img}" "${bootable_dir}/EFI/archiso/efiboot.img"
        # grub in an embedded efiboot.img via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set efiboot.img as the El Torito UEFI boot image
          '-e' 'EFI/archiso/efiboot.img'
          # Boot image is not emulating floppy or hard disk; required for all known boot loaders
          '-no-emul-boot'
        )
    fi
    # Specify where to save the El Torito boot catalog file in case it is not already set by bios.syslinux.eltorito
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' bios.' ]] || _xorrisofs_options+=('-eltorito-catalog' 'EFI/boot.cat')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.grub.eltorito_iso() {
    xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.eltorito "${isofs_dir}" "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.grub.eltorito_dongle() {
    dongle_xorrisofs_options=("$(_add_xorrisofs_options_uefi-x64.grub.eltorito "${dongle_isofs_dir}" "${dongle_xorrisofs_options[@]}")")
}

# Build bootstrap image
_build_bootstrap_image() {
    local _bootstrap_parent
    _bootstrap_parent="$(dirname -- "${pacstrap_dir}")"

    [[ -d "${out_dir}" ]] || install -d -- "${out_dir}"

    cd -- "${_bootstrap_parent}"

    _msg_info "Creating bootstrap image..."
    bsdtar -cf - "root.${arch}" | gzip -cn9 > "${out_dir}/${image_name}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"
    cd -- "${OLDPWD}"
}

# Builds dongle ISO image
_build_dongle_image() {
    local bootmode dongle_xorriso_cmd_line dongle_xorriso_options=() dongle_xorrisofs_options=()
    dongle_isofs_dir="${work_dir}/dongle_iso"

    # Add required xorrisofs options for each boot mode
    for bootmode in "${bootmodes[@]}"; do
        "_add_xorrisofs_options_${bootmode}_dongle" 
    done

    dongle_xorrisofs_options=("$(_add_xorrisofs_options_boot "${dongle_xorrisofs_options[@]}")")

    if [ "${persistent_size}" != "" ]; then
        dongle_xorrisofs_options=("$(_add_xorrisofs_options_persistent "${dongle_xorrisofs_options[@]}")")
    fi

    if [ "${swap_size}" != "" ]; then
        dongle_xorrisofs_options=("$(_add_xorrisofs_options_swap "${dongle_xorrisofs_options[@]}")")
    fi

    dongle_xorrisofs_options=("$(_add_xorrisofs_options_recovery "${dongle_xorrisofs_options[@]}")")

    [[ -d "${out_dir}" ]] || install -d -- "${out_dir}"

    if [[ "${quiet}" == "y" ]]; then
        # The when xorriso is run in mkisofs compatibility mode (xorrisofs), the mkisofs option -quiet is interpreted
        # too late (e.g. messages about SOURCE_DATE_EPOCH still get shown).
        # Instead use native xorriso option to silence the output.
        dongle_xorriso_options+=('-report_about' 'SORRY' "${dongle_xorriso_options[@]}")
    fi

    # Update SORCE_DATE_EPOCH for dongle ISO UUID
    SOURCE_DATE_EPOCH="$(_get_epoch "dongle")"

    rm -f -- "${out_dir}/${image_name}"
    _msg_info "Creating ISO image..."
    _msg_info "xorriso options: ${dongle_xorriso_options[*]}"
    _msg_info "xorrisofs options: ${dongle_xorrisofs_options[*]}"
    # shellcheck disable=SC2116
    dongle_xorriso_cmd_line=(
        "${dongle_xorriso_options[@]}"
        '-as' 'mkisofs'
        '-iso-level' 3
        '-full-iso9660-filenames'
        '-joliet'
        '-joliet-long'
        '-rational-rock'
        '-volid' "${iso_label}_DONGLE"
        '-appid' "\"${iso_application} dongle CD\""
        '-publisher' "\"${iso_publisher}\"" 
        '-preparer' "\"prepared by ${app_name}\""
        "${dongle_xorrisofs_options[@]}"
        '-output' "\"${out_dir}/${image_name}\""
        "${dongle_isofs_dir}/"
    )
    eval "xorriso ${dongle_xorriso_cmd_line[*]}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"
}

# Builds ISO image
_build_iso_image() {
    local xorriso_cmd_line
    isofs_dir="${work_dir}/iso"
    local bootmode

    [[ -d "${out_dir}" ]] || install -d -- "${out_dir}"

    if [[ "${quiet}" == "y" ]]; then
        # The when xorriso is run in mkisofs compatibility mode (xorrisofs), the mkisofs option -quiet is interpreted
        # too late (e.g. messages about SOURCE_DATE_EPOCH still get shown).
        # Instead use native xorriso option to silence the output.
        xorriso_options+=('-report_about' 'SORRY' "${xorriso_options[@]}")
    fi

    # Add required xorrisofs options for each boot mode
    for bootmode in "${bootmodes[@]}"; do
        "_add_xorrisofs_options_${bootmode}_iso" 
    done

    if [ "${persistent_size}" != "" ]; then
        xorrisofs_options=("$(_add_xorrisofs_options_persistent "${xorrisofs_options[@]}")")
    fi

    if [ "${swap_size}" != "" ]; then
        xorrisofs_options=("$(_add_xorrisofs_options_swap "${xorrisofs_options[@]}")")
    fi

    rm -f -- "${out_dir}/${image_name}"
    # shellcheck disable=SC2116
    xorriso_cmd_line=(
        "${xorriso_options[@]}" '-as' 'mkisofs'
        '-iso-level' 3
        '-full-iso9660-filenames'
        '-joliet'
        '-joliet-long'
        '-rational-rock'
        '-volid' "${iso_label}"
        '-appid' "\"${iso_application}\""
        '-publisher' "\"${iso_publisher}\""
        '-preparer' "\"prepared by ${app_name}\""
        "${xorrisofs_options[@]}"
        '-output' "${out_dir}/${image_name}"
        "${isofs_dir}/"
    )
    _msg_info "Creating ISO image..."
    _msg_info "xorriso args: ${xorriso_cmd_line[*]}"
    eval "xorriso ${xorriso_cmd_line[*]}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"

    if [[ "${airootfs_image_type}" == *"luks"* ]] && [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        cp "${airootfs_encryption_key}" "${out_dir}"
        cp "${persistent_encryption_key}" "${out_dir}"
    fi
}

# Read profile's values from profiledef.sh
_read_profile() {
    if [[ -z "${profile}" ]]; then
        _msg_error "No profile specified!" 1
    fi
    if [[ ! -d "${profile}" ]]; then
        _msg_error "Profile '${profile}' does not exist!" 1
    elif [[ ! -e "${profile}/profiledef.sh" ]]; then
        _msg_error "Profile '${profile}' is missing 'profiledef.sh'!" 1
    else
        cd -- "${profile}"

        # Source profile's variables
        # shellcheck source=configs/releng/profiledef.sh
        . "${profile}/profiledef.sh"

        # Resolve paths of files that are expected to reside in the profile's directory
        [[ -n "$arch" ]] || arch="$(uname -m)"
        [[ -n "$packages" ]] || packages="${profile}/packages.${arch}"
        packages="$(realpath -- "${packages}")"
        pacman_conf="$(realpath -- "${pacman_conf}")"

        # Resolve paths of files that may reside in the profile's directory
        if [[ -z "$bootstrap_packages" ]] && [[ -e "${profile}/bootstrap_packages.${arch}" ]]; then
            bootstrap_packages="${profile}/bootstrap_packages.${arch}"
            bootstrap_packages="$(realpath -- "${bootstrap_packages}")"
            pacman_conf="$(realpath -- "${pacman_conf}")"
        fi

        cd -- "${OLDPWD}"
    fi
}

# Validate set options
_validate_options() {
    local validation_error=0 _buildmode _msg=()

    _msg_info "Validating options..."

    # Check if pacman configuration file exists
    if [[ ! -e "${pacman_conf}" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "File '${pacman_conf}' does not exist." 0
    fi

    # Check if the specified buildmodes are supported
    for _buildmode in "${buildmodes[@]}"; do
        if typeset -f "_build_buildmode_${_buildmode}" &> /dev/null; then
            if typeset -f "_validate_requirements_buildmode_${_buildmode}" &> /dev/null; then
                "_validate_requirements_buildmode_${_buildmode}"
            else
                _msg=("Function '_validate_requirements_buildmode_${_buildmode}' does not exist."
                     "Validating the requirements of '${_buildmode}' build mode will not be possible.")
                _msg_warning "${_msg[*]}"
            fi
        else
            (( validation_error=validation_error+1 ))
            _msg_error "${_buildmode} is not a valid build mode!" 0
        fi
    done

    if (( validation_error )); then
        _msg_error "${validation_error} errors were encountered while validating the profile. Aborting." 1
    fi
    _msg_info "Done!"
}

# Set defaults and, if present, overrides from mkarchiso command line option parameters
_set_overrides() {
    # Set variables that have command line overrides
    [[ ! -v override_buildmodes ]] || buildmodes=("${override_buildmodes[@]}")
    if (( ${#buildmodes[@]} < 1 )); then
        buildmodes+=('iso')
    fi
    if [[ -v override_work_dir ]]; then
        work_dir="$override_work_dir"
    elif [[ -z "$work_dir" ]]; then
        work_dir='./work'
    fi
    work_dir="$(realpath -- "$work_dir")"
    if [[ -v override_out_dir ]]; then
        out_dir="$override_out_dir"
    elif [[ -z "$out_dir" ]]; then
        out_dir='./out'
    fi
    out_dir="$(realpath -- "$out_dir")"
    if [[ -v override_pacman_conf ]]; then
        pacman_conf="$override_pacman_conf"
    elif [[ -z "$pacman_conf" ]]; then
        pacman_conf="/etc/pacman.conf"
    fi
    pacman_conf="$(realpath -- "$pacman_conf")"
    [[ ! -v override_pkg_list ]] || pkg_list+=("${override_pkg_list[@]}")
    # TODO: allow overriding bootstrap_pkg_list
    if [[ -v override_iso_label ]]; then
        iso_label="$override_iso_label"
    elif [[ -z "$iso_label" ]]; then
        iso_label="${app_name^^}"
    fi
    if [[ -v override_iso_publisher ]]; then
        iso_publisher="$override_iso_publisher"
    elif [[ -z "$iso_publisher" ]]; then
        iso_publisher="${app_name}"
    fi
    if [[ -v override_iso_application ]]; then
        iso_application="$override_iso_application"
    elif [[ -z "$iso_application" ]]; then
        iso_application="${app_name} iso"
    fi
    if [[ -v override_install_dir ]]; then
        install_dir="$override_install_dir"
    elif [[ -z "$install_dir" ]]; then
        install_dir="${app_name}"
    fi
    [[ ! -v override_gpg_key ]] || gpg_key="$override_gpg_key"
    [[ ! -v override_gpg_sender ]] || gpg_sender="$override_gpg_sender"
    [[ ! -v override_gpg_home ]] || gpg_home="$override_gpg_home"
    if [[ -v override_cert_list ]]; then
        sign_netboot_artifacts="y"
    fi
    [[ ! -v override_cert_list ]] || cert_list+=("${override_cert_list[@]}")
    if [[ -v override_quiet ]]; then
        quiet="$override_quiet"
    elif [[ -z "$quiet" ]]; then
        quiet="y"
    fi

    # Set variables that do not have overrides
    [[ -n "$airootfs_image_type" ]] || airootfs_image_type="squashfs"
    [[ -n "$boot_image_type" ]] || boot_image_type="ext4+luks"
    [[ -n "$keys_image_type" ]] || keys_image_type="squashfs+luks"
    [[ -n "$persistent_image_type" ]] || persistent_image_type="ext4+luks"
    [[ -n "$dongle_boot_image_type" ]] || dongle_boot_image_type="${boot_image_type}"
    [[ -n "$dongle_persistent_image_type" ]] || dongle_persistent_image_type="${persistent_image_type}"
    [[ -n "$swap_image_type" ]] || swap_image_type="swap+luks"
    [[ -n "$dongle_swap_image_type" ]] || dongle_swap_image_type="${swap_image_type}"
    [[ -n "$dongle_persistent_encryption_key" ]] || dongle_persistent_encryption_key="auto"
    [[ -n "$keys_encryption_key" ]] || keys_encryption_key="auto"
    [[ -n "$recovery_encryption_key" ]] || recovery_encryption_key="auto"
    [[ -n "$recovery" ]] || recovery="false"
    [[ -n "$iso_name" ]] || iso_name="${app_name}"
    [[ -n "$isofs_dir" ]] || isofs_dir="${work_dir}/iso"
    [[ -n "$airootfs_dir" ]] || airootfs_dir="${isofs_dir}/${install_dir}/${arch}"
    [[ -n "$dongle_isofs_dir" ]] || dongle_isofs_dir="${work_dir}/dongle_iso"
    [[ -n "$efi_boot_img" ]] || efi_boot_img="${work_dir}/efiboot.img"
    [[ -n "$persistent_img" ]] || persistent_img="${work_dir}/persistent."$(_get_fs_ext "persistent")
    [[ -n "$dongle_persistent_img" ]] || dongle_persistent_img="${work_dir}/donglepersistent."$(_get_fs_ext "dongle_persistent")
    [[ -n "$dongle_boot_img" ]] || dongle_boot_img="${work_dir}/dongleboot."$(_get_fs_ext "dongle_boot")
    [[ -n "$swap_img" ]] || swap_img="${work_dir}/swap.img"
    [[ -n "$dongle_swap_img" ]] || dongle_swap_img="${work_dir}/dongleswap.img"
    [[ -n "$recovery_img" ]] || recovery_img="${work_dir}/recovery.img"
}

_export_gpg_publickey() {
    rm -f -- "${work_dir}/pubkey.gpg"
    if [ "${gpg_home}" != "" ]; then
        GNUPGHOME="${gpg_home}" gpg --homedir "${gpg_home}" \
                                    --batch --no-armor --output "${work_dir}/pubkey.gpg" \
                                    --export "${gpg_key}"
    else
        gpg --batch --no-armor --output "${work_dir}/pubkey.gpg" \
            --export "${gpg_key}"
    fi
}

_make_version() {
    local _os_release

    _msg_info "Creating version files..."
    # Write version file to system installation dir
    rm -f -- "${pacstrap_dir}/version"
    printf '%s\n' "${iso_version}" > "${pacstrap_dir}/version"

    if [[ "${buildmode}" == @("iso"|"netboot") ]]; then
        install -d -m 0755 -- "${isofs_dir}/${install_dir}"
        # Write version file to ISO 9660
        printf '%s\n' "${iso_version}" > "${isofs_dir}/${install_dir}/version"
        # Write grubenv with version information to ISO 9660
        printf '%.1024s' "$(printf '# GRUB Environment Block\nNAME=%s\nVERSION=%s\n%s' \
            "${iso_name}" "${iso_version}" "$(printf '%0.1s' "#"{1..1024})")" \
            > "${isofs_dir}/${install_dir}/grubenv"
    fi

    # Append IMAGE_ID & IMAGE_VERSION to os-release
    _os_release="$(realpath -- "${pacstrap_dir}/etc/os-release")"
    if [[ ! -e "${pacstrap_dir}/etc/os-release" && -e "${pacstrap_dir}/usr/lib/os-release" ]]; then
        _os_release="$(realpath -- "${pacstrap_dir}/usr/lib/os-release")"
    fi
    if [[ "${_os_release}" != "${pacstrap_dir}"* ]]; then
        _msg_warning "os-release file '${_os_release}' is outside of valid path."
    else
        [[ ! -e "${_os_release}" ]] || sed -i '/^IMAGE_ID=/d;/^IMAGE_VERSION=/d' "${_os_release}"
        printf 'IMAGE_ID=%s\nIMAGE_VERSION=%s\n' "${iso_name}" "${iso_version}" >> "${_os_release}"
    fi

    # Touch /usr/lib/clock-epoch to give another hint on date and time
    # for systems with screwed or broken RTC.
    touch -m -d"@${SOURCE_DATE_EPOCH}" -- "${pacstrap_dir}/usr/lib/clock-epoch"

    _msg_info "Done!"
}

_make_pkglist() {
    _msg_info "Creating a list of installed packages on live-enviroment..."
    case "${buildmode}" in
        "bootstrap")
            pacman -Q --sysroot "${pacstrap_dir}" > "${pacstrap_dir}/pkglist.${arch}.txt"
            ;;
        "iso")
            install -d -m 0755 -- "${isofs_dir}/${install_dir}"
            if [[ ! "${airootfs_image_type}" == *"luks"* ]]; then
                pacman -Q --sysroot "${pacstrap_dir}" > "${isofs_dir}/${install_dir}/pkglist.${arch}.txt"
            fi
            ;;
        "netboot")
            install -d -m 0755 -- "${isofs_dir}/${install_dir}"
            pacman -Q --sysroot "${pacstrap_dir}" > "${isofs_dir}/${install_dir}/pkglist.${arch}.txt"
            ;;
    esac
    _msg_info "Done!"
}

# Builds the base for an ISO and/or a netboot target
_build_dongle_base() {
    local run_once_mode="base"
    local _sig_dir
    _sig_dir="${dongle_isofs_dir}/${install_dir}/${arch}"
    keys_dir="${work_dir}/keys"

    [[ -d "${keys_dir}" ]] || install -d -- "${keys_dir}"
    [[ -d "${dongle_isofs_dir}" ]] || install -d -- "${dongle_isofs_dir}"
    [[ -d "${dongle_persistent_dir}" ]] || install -d -- "${dongle_persistent_dir}"
    [[ -d "${dongle_boot_dir}" ]] || install -d -- "${dongle_boot_dir}"

    if [ "${airootfs_encryption_key}" != "" ]; then
        cp "${airootfs_encryption_key}" "${keys_dir}/airootfs.key"
    fi

    if [[ "${airootfs_image_type}" == *"luks"* ]] && [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _run_once _prepare_keys_image
    fi

    _run_once _make_boot_on_dongle
    _make_bootmodes_dongle
}


# build the base for an ISO and/or a netboot target
_build_iso_base() {
    local run_once_mode="base"
    local buildmode_packages="${packages}"
    # Set the package list to use
    local buildmode_pkg_list=("${pkg_list[@]}")
    # Set up essential directory paths
    pacstrap_dir="${work_dir}/${arch}/airootfs"
    isofs_dir="${work_dir}/iso"
    keys_dir="${work_dir}/keys"
    airootfs_dir="${isofs_dir}/${install_dir}/${arch}"
    persistent_dir="${work_dir}/persistent"
    dongle_persistent_dir="${work_dir}/dongle_persistent"
    dongle_boot_dir="${work_dir}/dongle_boot"

    # Create working directory
    [[ -d "${airootfs_dir}" ]] || install -d -- "${airootfs_dir}"
    [[ -d "${keys_dir}" ]] || install -d -- "${keys_dir}"
    [[ -d "${persistent_dir}" ]] || install -d -- "${persistent_dir}"
    [[ -d "${dongle_persistent_dir}" ]] || install -d -- "${dongle_persistent_dir}"

    # Write build date to file or if the file exists, read it from there
    if [[ -e "${work_dir}/build_date" ]]; then
        SOURCE_DATE_EPOCH="$(<"${work_dir}/build_date")"
    else
        printf '%s\n' "$SOURCE_DATE_EPOCH" > "${work_dir}/build_date"
    fi

    [[ "${quiet}" == "y" ]] || _show_config
    _run_once _make_pacman_conf
    [[ -z "${gpg_key}" ]] || _run_once _export_gpg_publickey
    _run_once _make_custom_airootfs
    _run_once _make_packages
    _run_once _make_version
    _run_once _make_customize_airootfs
    _run_once _make_pkglist
    _run_once _prepare_persistent_image
    _run_once _prepare_swap_image
    _run_once _prepare_dongle_boot_image
    _run_once _prepare_dongle_swap_image
    if [[ "${buildmode}" == 'netboot' ]]; then
        _run_once _make_boot_on_iso9660
    else
        _make_bootmodes_iso
    fi
    _run_once _cleanup_pacstrap_dir
    _run_once _prepare_airootfs_image
    _run_once _prepare_recovery_image
}

# Build the bootstrap buildmode
_build_buildmode_bootstrap() {
    local image_name="${iso_name}-bootstrap-${iso_version}-${arch}.tar.gz"
    local run_once_mode="${buildmode}"
    local buildmode_packages="${bootstrap_packages}"
    # Set the package list to use
    local buildmode_pkg_list=("${bootstrap_pkg_list[@]}")

    # Set up essential directory paths
    pacstrap_dir="${work_dir}/${arch}/bootstrap/root.${arch}"
    [[ -d "${work_dir}" ]] || install -d -- "${work_dir}"
    install -d -m 0755 -o 0 -g 0 -- "${pacstrap_dir}"

    [[ "${quiet}" == "y" ]] || _show_config
    _run_once _make_pacman_conf
    _run_once _make_packages
    _run_once _make_version
    _run_once _make_pkglist
    _run_once _cleanup_pacstrap_dir
    _run_once _build_bootstrap_image
}

# Build the netboot buildmode
_build_buildmode_netboot() {
    local run_once_mode="${buildmode}"

    _build_iso_base
    if [[ -v cert_list ]]; then
        _run_once _sign_netboot_artifacts
    fi
    _run_once _export_netboot_artifacts
}

# Build the ISO buildmode
_build_buildmode_iso() {
    local image_name="${iso_name}-${iso_version}-${arch}.iso"
    local run_once_mode="${buildmode}"
    efi_boot_img="${work_dir}/efiboot.img"
    _build_iso_base
    _run_once _build_iso_image
}

# Build the dongle ISO buildmode
_build_buildmode_dongle() {
    local image_name="${iso_name}-dongle-${iso_version}-${arch}.iso"
    local run_once_mode="${buildmode}"
    efi_boot_img="${work_dir}/efiboot.img"
    _build_dongle_base
    _run_once _build_dongle_image
}

# build all buildmodes
_build() {
    local buildmode
    local run_once_mode="build"

    for buildmode in "${buildmodes[@]}"; do
        _run_once "_build_buildmode_${buildmode}"
    done
}

while getopts 'c:p:C:L:P:A:D:w:m:o:g:G:H:vh?' arg; do
    case "${arg}" in
        p) read -r -a override_pkg_list <<< "${OPTARG}" ;;
        C) override_pacman_conf="${OPTARG}" ;;
        L) override_iso_label="${OPTARG}" ;;
        P) override_iso_publisher="${OPTARG}" ;;
        A) override_iso_application="${OPTARG}" ;;
        D) override_install_dir="${OPTARG}" ;;
        c) read -r -a override_cert_list <<< "${OPTARG}" ;;
        w) override_work_dir="${OPTARG}" ;;
        m) read -r -a override_buildmodes <<< "${OPTARG}" ;;
        o) override_out_dir="${OPTARG}" ;;
        g) override_gpg_key="${OPTARG}" ;;
        G) override_gpg_sender="${OPTARG}" ;;
        H) override_gpg_home="${OPTARG}" ;;
        v) override_quiet="n" ;;
        h|?) _usage 0 ;;
        *)
            _msg_error "Invalid argument '${arg}'" 0
            _usage 1
            ;;
    esac
done

shift $((OPTIND - 1))

if (( $# < 1 )); then
    _msg_error "No profile specified" 0
    _usage 1
fi

if (( EUID != 0 )); then
    _msg_error "${app_name} must be run as root." 1
fi

# get the absolute path representation of the first non-option argument
profile="$(realpath -- "${1}")"

_read_profile
_set_overrides
_validate_options
_build

# vim:ts=4:sw=4:et:
