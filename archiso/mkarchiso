#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later

set -e -u
shopt -s extglob

# Control the environment
umask 0022
export LC_ALL="C.UTF-8"
# LC_ALL=C.UTF-8, unlike LC_ALL=C, does not override LANGUAGE.
# See https://sourceware.org/bugzilla/show_bug.cgi?id=16621 \
# and https://savannah.gnu.org/bugs/?62815
[[ -v LANGUAGE ]] && \
  unset LANGUAGE
[[ -v SOURCE_DATE_EPOCH ]] || \
  printf -v SOURCE_DATE_EPOCH '%(%s)T' -1
export SOURCE_DATE_EPOCH

# Set application name from the script's file name
app_name="${0##*/}"

# Show an INFO message
# $1: message string
_msg_info() {
    local _msg="${1}"
    [[ "${quiet}" == "y" ]] || \
      printf '[%s] INFO: %s\n' "${app_name}" "${_msg}"
}

# Show a WARNING message
# $1: message string
_msg_warning() {
    local _msg="${1}"
    printf '[%s] WARNING: %s\n' "${app_name}" "${_msg}" >&2
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
_msg_error() {
    local _msg="${1}"
    local _error=${2}
    printf '[%s] ERROR: %s\n' "${app_name}" "${_msg}" >&2
    if (( _error > 0 )); then
        exit "${_error}"
    fi
}

# Returns an attribute value for a 
# given object
# $1: an object
# $2: an object attribute
_get() {
    local _obj="${1}" \
          _var="${2}" \
          _msg \
          _ref \
          _type
    _ref="${_image}_${_var}[@]"
    _type="$(declare -p "${_ref}")"
    [[ "${_type}" == *"declare: "*": not found" ]] && \
      _msg=(
        "Attribute '${_var}' is not defined"
        "for object '${_obj}'") && \
      _msg_error "${_msg[*]}" 1
    [[ "${_type}" == "declare -A "* ]] && \
      echo "${_image[${_var}]}" && \
      return
    printf "%s\n" "${!_ref}"
}

# Sets object string attributes
# $1: object
# $2: an object string attribute
# $3: a value
_set() {
    local _obj="${1}" \
          _var="${2}" \
          _value="${3}" \
          _type
    [[ "${_type}" == "declare -A "* ]] && \
      
    printf -v "${_obj}_${_var}" \
              "${_value}"
}

# Sets global variables
_global_variables() {
    local _var \
          _volume \
          _volumes=() \
          _volumes_string_vars=() \
          _volumes_array_vars=()
    pkg_list=()
    bootstrap_pkg_list=()
    quiet=""
    work_dir=""
    out_dir=""
    gpg_key=""
    gpg_sender=""
    gpg_home=""
    iso_name=""
    iso_publisher=""
    iso_application=""
    iso_version=""
    install_dir=""
    arch=""
    pacman_conf=""
    packages=""
    bootstrap_packages=""
    pacstrap_dir=""
    buildmodes=()
    bootmodes=()
    xorriso_options=()
    xorrisofs_options=()
    dongle_xorriso_options=()
    dongle_xorrisofs_options=()
    cert_list=()
    sign_netboot_artifacts=""
    declare -g \
            -A \
            file_permissions=()
    declare -g \
            -A \
            images=()
    _boot_loader_vars=(
      'profile_path'
      'cfg_path'
      'install_path'
    )
    _volumes=(
      'iso'
      'airootfs'
      'persistent'
      'keys'
      'swap'
      'dongle_iso'
      'dongle_boot'
      'dongle_persistent'
      'dongle_swap'
      'recovery'
      'efi_boot')
    _volumes_string_vars=(
      'dir'
      'encryption_key'
      'epoch'
      'image_type'
      'image_tool_options'
      'img'
      'label'
      'size' # All sizes are in kib
             # except when specified
      'uuid')
    _volumes_array_vars=(
      'files'
      'image_tool_options')
    for _var in "${_boot_loader_vars[@]}"; do
        _set "boot_loader" \
             "${_var}" \
             ""
    done
    for _volume in "${_volumes[@]}"; do
        for _var in "${_volumes_string_vars[@]}"; do
            _set "${_volume}" \
                 "${_var}" \
                 ""
        done
        for _var in "${_volumes_array_vars[@]}"; do
            declare -g \
                    -a \
                    "${_volume}_${_var}"
        done
    done
}

# Sets constants
_constants() {
    # adapted from GRUB_EARLY_INITRD_LINUX_STOCK in 
    # https://git.savannah.gnu.org/cgit/grub.git/tree/util/grub-mkconfig.in
    readonly \
      codes=(
        'intel-uc.img'
        'intel-ucode.img'
        'amd-uc.img'
        'amd-ucode.img'
        'early_ucode.cpio'
        'microcode.cpio') \
      epoch_namespace="93a870ff-8565-4cf3-a67b-f47299271a96" \
      luks_guid="CA7D7CCB-63ED-4C53-861C-1742536059CC" \
      linux_guid="0FC63DAF-8483-4772-8E79-3D69D8477DE4" \
      swap_guid="0657fd6d-a4ab-43c4-84e5-0933c84b4f4f" \
      _PI=$((3 * 1415)) \
      _E=$((2 * 71828)) \
      _EL=$((42 * 69)) \
      _RO=$((16 * 1803)) \
      airootfs_const=0 \
      dongle_const="${_EL}" \
      boot_const="${_RO}" \
      persistent_const="${_PI}" \
      swap_const="${_E}" \
      dongle_boot_const=$((
        dongle_const + \
        boot_const)) \
      dongle_persistent_const=$((
        dongle_const + \
        persistent_const)) \
      dongle_swap_const=$((
        dongle_const + \
        swap_const)) \
      keys_const=$((
        dongle_const + \
        boot_const + \
        persistent_const)) \
      recovery_const=$((
        dongle_const + \
        boot_const + \
        keys_const))
}

# Sets global symbols
_read_symbols() {
  _global_variables
  _constants
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
    IFS='' read -r -d '' usagetext <<ENDUSAGETEXT || true
usage: ${app_name} [options] <profile_dir>
  options:
     -A <application> Set an application name for the ISO
                      Default: '${iso_application}'
     -C <file>        pacman configuration file.
                      Default: '${pacman_conf}'
     -D <install_dir> Set an install_dir. All files will by located here.
                      Default: '${install_dir}'
                      NOTE: Max 8 characters, use only [a-z0-9]
     -L <label>       Set the ISO volume label
                      Default: '${iso_label}'
     -P <publisher>   Set the ISO publisher
                      Default: '${iso_publisher}'
     -c [cert ..]     Provide certificates for codesigning of netboot artifacts
                      Multiple files are provided as quoted, space delimited list.
                      The first file is considered as the signing certificate,
                      the second as the key.
     -g <gpg_key>     Set the PGP key ID to be used for signing the rootfs image.
                      Passed to gpg as the value for --default-key
     -G <mbox>        Set the PGP signer (must include an email address)
                      Passed to gpg as the value for --sender
     -H <gpg_home>    Set the gpg home directory.
     -h               This message
     -m [mode ..]     Build mode(s) to use (valid modes are: 'bootstrap',
                      'dongle', 'iso' and 'netboot').
                      Multiple build modes are provided as quoted, space delimited list.
     -o <out_dir>     Set the output directory
                      Default: '${out_dir}'
     -p [package ..]  Package(s) to install.
                      Multiple packages are provided as quoted, space delimited list.
     -v               Enable verbose output
     -w <work_dir>    Set the working directory (can't be a bind mount).
                      Default: '${work_dir}'

  profile_dir:        Directory of the archiso profile to build
ENDUSAGETEXT
    printf '%s' "${usagetext}"
    exit "${1}"
}

# Shows configuration options.
_show_config() {
    local build_date
    TZ=UTC printf -v build_date '%(%FT%R%z)T' "${SOURCE_DATE_EPOCH}"
    _msg_info "${app_name} configuration settings"
    _msg_info "             Architecture:   ${arch}"
    _msg_info "        Working directory:   $(_get "work" "dir")"
    _msg_info "   Installation directory:   $(_get "install" "dir")"
    _msg_info "               Build date:   ${build_date}"
    _msg_info "         Output directory:   ${out_dir}"
    _msg_info "       Current build mode:   ${buildmode}"
    _msg_info "              Build modes:   ${buildmodes[*]}"
    _msg_info "                  GPG key:   ${gpg_key:-None}"
    _msg_info "               GPG signer:   ${gpg_sender:-None}"
    _msg_info "                 GPG Home:   ${gpg_home:-None}"
    _msg_info "           Encryption Key:   $(_get "airootfs" \
                                                   "encryption_key"):-None}"
    _msg_info "Code signing certificates:   ${cert_list[*]:-None}"
    _msg_info "                  Profile:   $(_get "profile" "dir")"
    _msg_info "Pacman configuration file:   ${pacman_conf}"
    _msg_info "          Image file name:   ${image_name:-None}"
    _msg_info "         ISO volume label:   ${iso_label}"
    _msg_info "            ISO publisher:   ${iso_publisher}"
    _msg_info "          ISO application:   ${iso_application}"
    _msg_info "               Boot modes:   ${bootmodes[*]:-None}"
    _msg_info "            Packages File:   ${buildmode_packages}"
    _msg_info "                 Packages:   ${buildmode_pkg_list[*]}"
}

# Helper function to run functions only one time.
# $1: function name
_run_once() {
    if [[ ! -e "${work_dir}/${run_once_mode}.${1}" ]]; then
        "${1}"
        touch "${work_dir}/${run_once_mode}.${1}"
    else
        if [ "${quiet}" != "y"  ]; then
            _msg_info "Command ${1} already run"
        fi
    fi
}

########################################################
# File system making functions
########################################################

## Utility functions

# Returns epoch given a file system image name 
# $1: value in fs_images
_get_epoch() {
    local _name="${1}"
    echo $((SOURCE_DATE_EPOCH + "${_name}_const"))
}

# Returns an unique uuid given a datetime in UNIX time
# $1: UNIX time
_get_epoch_fsuuid() {
    local _epoch="${1}"
    uuidgen --sha1 \
	        --namespace "${epoch_namespace}" \
            --name "${_epoch}"
}

# Gets an ext4-compatible uuid from a date
# $1: datetime in UNIX time
_epoch_to_uuid() {
    local _epoch="${1}"
    local _uuid
    TZ=UTC printf -v _uuid '%(%F-%H-%M-%S-00)T' "${_epoch}"
    echo "${_uuid}"
}

_get_size() {
    local _dir="${1}"
    echo $(du -s "${_dir}" | \
             cut -f 1)
}
## EROFS

# Creates an EROFS image given a directory.
# $1: resulting image
# $2: input directory
# $3: UNIX time (to generate a date-based uuid)
_run_mkerofs() {
    local _image_path="${1}"
    local _dir="${2}"
    local _epoch="${3}"
    local fsuuid
    fsuuid="$(_get_epoch_fsuuid "${_epoch}")"
    [[ ! "${quiet}" == "y" ]] || \
      mkfs_erofs_options+=('--quiet')
    _msg_info "Creating EROFS image"
    _msg_info "Directory: ${_dir}"
    _msg_info "Image path: ${_image_path}"
    _msg_info "UUID: ${fsuuid}"
    _msg_info "this may take a while..."
    mkfs_erofs_options+=(
      '-U' "${fsuuid}"
      "${_mkfs_options[@]}")
    mkfs.erofs "${mkfs_erofs_options[@]}" -- \
               "${_image_path}" \
               "${_dir}"
    _msg_info "Done!"
}

## EXT4

# Creates an ext4 image of given size 
# from a directory with the same name in the same path.
# $1: directory to put into the image
# $2: size of the resulting image
# $3: UNIX time (to generate a date-based uuid)
# $4: partition label
# $5: if true the file system image will be writable
_run_mkext4() {
    local _dir="${1}"
    local _image_path="${1}.img"
    local _size="${2}" \
          _epoch="${3}" \
          _label="${4}" \
          _writable="${5}" \
          _fsuuid \
          ext4_hash_seed \
          mkfs_ext4_options=()
    _fsuuid="$(_epoch_to_uuid "${_epoch}")"

    _msg_info "Creating ext4 image"
    _msg_info "Size: ${_size} KB"
    _msg_info "Directory: ${_dir}"
    _msg_info "Image path: ${_image_path}"
    _msg_info "UUID: ${_fsuuid}"
    _msg_info "Label: ${_label}"
    _msg_info "this may take a while..."

    ext4_hash_seed="$(uuidgen --sha1 \
                              --namespace ${epoch_namespace} \
                              --name "${_epoch} ext4 hash seed")"
    _ext_opts=(
      "lazy_itable_init=0"
      "root_owner=0:0"
      "hash_seed=${ext4_hash_seed}")
    mkfs_ext4_options=(
      '-d' "${_dir}"
      '-O' '^has_journal,^resize_inode'
      '-E' "$(IFS=, ; echo ${_ext_opts[*]})"
      '-m' '0'
      '-F'
      '-b' 4096
      '-U' 'clear')
    [[ "${_label}" != "" ]] && \
      mkfs_ext4_options+=('-L' "${_label}")
    [[ ! "${quiet}" == "y" ]] || \
      mkfs_ext4_options+=('-q')
    if [[ ! "${quiet}" == "y" ]]; then
        E2FSPROGS_FAKE_TIME="${_epoch}" \
          mkfs.ext4 "${mkfs_ext4_options[@]}" -- \
                    "${_image_path}" \
                    "${_size}K"
    else
        E2FSPROGS_FAKE_TIME="${_epoch}" \
          mkfs.ext4 "${mkfs_ext4_options[@]}" -- \
                    "${_image_path}" \
                    "${_size}K" > /dev/null 2>&1
    fi
    tune2fs -c 0 \
            -i 0 -- \
            "${_image_path}" > /dev/null
    if [ "${_writable}" != "true" ]; then
        tunefs -O read-only \
               "${_image_path}"
    fi
    _msg_info "Done!"
}

## FAT

# Creates a FAT image 
# $1: image path
# $2: image size in bytes
# $3: image label
_run_mkfat() {
    local _image_path="${1}" \
          _size_bytes=${2} \
          _label="${3}" \
          _deps=() \
          _mkfs_fat_options=() \
          _fun \
          _size_kib="0" \
          _msg=()
    _deps=(
      'function ceil(x){return int(x)+(x>int(x))}'
      'function byte_to_kib(x){return x/1024}'
      'function mib_to_kib(x){return x*1024}')
    _fun='mib_to_kib(ceil((byte_to_kib($1)+1024)/1024))'
    (( _size_bytes < 2*1024*1024 )) && \
      _msg=("Image size is ${_size_bytes} bytes,"
            "less than 2 MiB! Bumping up to 2 MiB") \
      _msg_info "${_msg[*]}" && \
      _size_bytes=$((20*1024*1024))
    # Where it spills?
    _size_bytes=$((_size_bytes * 10))
    # Convert from bytes to KiB and round up to the next full MiB
    # with an additional MiB for reserved sectors.
    _size_kib="$(awk "${_deps[*]} END {print ${_fun}}" <<< \
                   "${_size_bytes}")"
    # The FAT image must be created with mkfs.fat, not mformat,
    # as some systems have issues with mformat made images:
    # https://lists.gnu.org/archive/html/grub-devel/2019-04/msg00099.html
    _mkfs_fat_options=(
      -C
      -n "${_label}")
    _msg_info "Creating FAT image of size: ${_size_kib} KiB..."
    if [[ "${quiet}" == "y" ]]; then
        # mkfs.fat does not have a -q/--quiet option, so
        # redirect stdout to /dev/null instead
        # https://github.com/dosfstools/dosfstools/issues/103
        mkfs.fat "${_mkfs_fat_options[@]}" \
                 "${_image_path}" \
                 "${_size_kib}" > /dev/null
    else
        mkfs.fat "${_mkfs_fat_options[@]}" \
                 "${_image_path}" \
                 "${_size_kib}"
    fi
}

## LUKS

# Prompts a passphrase to be used as key for a partition
# $1: partition name
# $2: partition label
_ask_passwd() {
    local _name="${1}" \
          _label="${2}" \
          _prompt=() \
          _prompt_cmd \
          _mismatch \
          _mismatch_cmd="echo" \
          _opts=("--timeout=69042")
    local _msg=("Insert new passphrase"
                "for ${_name} (${_label}): ") \
          _confirm_msg="Confirm: " \
          _mismatch_opts=() \
          _mismatch_msg="Passwords mismatch." \
          _confirm
    if command -v zenity &> /dev/null && \
       [ -n "${DISPLAY}" ]; then
        _prompt_cmd="$(which zenity)"
        _mismatch_cmd="${_prompt_cmd}"
        _opts+=(
          "--password")
        _mismatch_opts+=(
          "--info"
          "--icon" "dialog-password"
          "--text")
    else
        _prompt_cmd=$(which systemd-ask-password)
    fi
    _prompt=("${_prompt_cmd}" "${_opts[@]}")
    _mismatch=("${_mismatch_cmd}" "${_mismatch_opts[@]}"
                                  "${_mismatch_msg}")
    while true; do
        _passphrase=$("${_prompt[@]}" "${_msg[*]}")
        echo "${_confirm_msg}"
        _confirm=$("${_prompt[@]}" "${_confirm_msg}")
        [[ "${_passphrase}" == "${_confirm}" ]] && \
          break
        "${_mismatch[@]}"
    done
}

# Determines correct fallocate options for an image at a chosen path
# $1: path of the fallocate resulting image to verify options for
_validate_fallocate_opts() {
    local _image_path="${1}"
    local _posix_error=("fallocate:"
                        "fallocate failed:"
                        "Operation not supported")
    local _msg
    _msg="$(fallocate -l "100K" \
                      "${_image_path}.test" 2>&1)" 
    if [ "${_msg}" == "${_posix_error[*]}" ]; then
        rm "${_image_path}.test"
        echo '--posix' 
    elif [ "${_msg}" != "" ]; then
        _msg_error "${_msg}" 1
    fi
}

# Closes a LUKS device mapper
# $1: device mapper to close
_close_luks_device() {
    local _device="${1}"
    local _mapper
    _mapper=$(basename "${_device}")
    blockdev --flushbufs \
             "${_device}" > /dev/null 2>&1 || true
    cryptsetup luksClose "${_mapper}" > /dev/null 2>&1 || true
    if [ -e "${_device}" ]; then
        dmsetup remove "${_device}" > /dev/null 2>&1 || true
    fi
    sync
}

# Creates and opens a LUKS image of the size
# of the pacstrap directory plus 200MB.
# $1: image to write on
# $2: partition size
# $3: encryption key
# $4: UNIX time (to generate a date-based uuid)
# $5: partition label
# $6: if true, the partition will be writable
# $7: if true, dm-verity layer will be disabled
#     to be able to be opened by GRUB
_run_mkluks() {
    local _image_path="${1}" \
          _size="${2}" \
          _encryption_key="${3}" \
          _epoch="${4}" \
          _label="${5}" \
          _writable="${6}" \
          _grub="${7}"
    local _activation_cmd=() \
          _activation_opts=() \
          _config_cmd=() \
          _cryptsetup_opts=(
            '--type' 'luks2'
            '--timeout=69042') \
          _fallocate_opts=(
            '--length'
            "${_size}K") \
          _format_opts=() \
          _format_cmd=() \
          _fsuuid \
          _key_msg="" \
          _key_opts=() \
          _key_size='512' \
          _mapper \
          _msg=() \
          _pbkdf_memory='256' \
          _sector_size='4096' \
          _uuid_set_cmd=()

    _fsuuid="$(_get_epoch_fsuuid "${_epoch}")"
    _mapper=$(basename "${_image_path}")".map"
    image_device="/dev/mapper/${_mapper}"

    if [[ "${_encryption_key}" != "" ]]; then
        _key_opts=("--key-file=${_encryption_key}")
        _cryptsetup_opts+=("${_key_opts[@]}")
        _key_msg="with key $(basename "${_encryption_key}")"
    fi

    _activation_opts+=("${_cryptsetup_opts[@]}")
    _format_opts+=(
      "${_cryptsetup_opts[@]}"
      '--sector-size' "${_sector_size}"
      '--key-size' "${_key_size}")

    # Remove as soon as gcrypt adds support for argon2i
    # and GRUB for the dm-integrity layer
    if [ "${_grub}" == "true" ]; then
        _format_opts+=(
          '--pbkdf' 'pbkdf2')
    else
        _format_opts+=(
          '--pbkdf-memory' "${_pbkdf_memory}"
          '--integrity' 'hmac-sha512')
    fi

    if [ "${_writable}" != "true" ]; then
        _msg_info "Integrity journal disabled"
        _activation_opts+=(
          '--persistent' \
          '--integrity-no-journal' \
          '--key-size' "${_key_size}")
    fi
    _msg=("Creating LUKS image $(basename "${_image_path}")"
          "with cryptsetup (${_size}KB) ${_key_msg}")
    _msg_info "${_msg[*]}"
    _fallocate_opts+=(
      "$(_validate_fallocate_opts "${_image_path}")")
    fallocate "${_fallocate_opts[@]}" \
              "${_image_path}"
    _format_cmd=(
      "cryptsetup" "-q"
                   "-y" "luksFormat" "${_format_opts[*]}"
                                     "${_image_path}")
    while ! eval "${_format_cmd[*]}"; do
        sleep 1
    done

    _msg_info "Setting label ${_label}"
    _config_cmd=("cryptsetup" "config" "${_cryptsetup_opts[*]}"
                                       "${_image_path}"
                                         "--label" "${_label}")
    while ! eval "${_config_cmd[*]}"; do
        _close_luks_device "${image_device}"
    done

    _msg_info "Setting UUID ${_fsuuid}"
    _uuid_set_cmd=(
      "cryptsetup" "-q"
                   "-y"
                   "luksUUID" "--uuid ${_fsuuid}"
                              "${_image_path}")
    while ! eval "${_uuid_set_cmd[*]}"; do
        _close_luks_device "${image_device}"
    done

    _close_luks_device "${image_device}"

    _msg_info "Opening device on mapper ${_mapper}"
    _activation_cmd=(
      "cryptsetup" "${_activation_opts[*]}"
                   "open" "${_image_path}"
                          "${_mapper}")
    while ! eval "${_activation_cmd[*]}"; do
        _close_luks_device "${image_device}"
    done
    _msg_info "Done!"
}


## RAID

# Creates and opens a RAID device
# $1: RAID name
# $2: RAID type (only '1' for now)
_run_mkraid() {
    # local _image_path="${1}"
    # local _dev_path="${1}"
    local _name="${1}"
    # local _size="${2}" # should go into the array
    local _type="${2}"
    shift 3
    local _devices=("$@")
    mdadm --create "/dev/md${_name}.map" \
          --level="${_type}" \
          --run \
          "${_devices[@]}"
}

## SQUASHFS

# Creates a squashfs image from a
# file system image or directory.
# $1: directory or a file system image
# $2: path of the result image
_run_mksquashfs() {
    local _directory_or_fs="${1}" \
          _image_path="${2}" \
          _msg=() \
          mksquashfs_options=("${_mkfs_options[@]}")
    [[ ! "${quiet}" == "y" ]] || \
      mksquashfs_options+=(
        '-no-progress'
        '-quiet')
    _msg=("Creating SQUASHFS image,"
          "this may take some time...")
    _msg_info "${_msg[*]}"
    mksquashfs "${_directory_or_fs}" \
               "${_image_path}" \
               -noappend \
               "${mksquashfs_options[@]}"
}


## SWAP

# Creates a swap image
# $1: resulting image
# $2: image size
# $3: UNIX time (to generate a date-based uuid)
# $4: partition label
_run_mkswap() {
    local _image_path="${1}"
    local _size="${2}"
    local _epoch="${3}"
    local _label="${4}"
    local _fsuuid
    _fsuuid="$(_get_epoch_fsuuid "${_epoch}")"
    dd if=/dev/zero \
       of="${_image_path}" \
       bs=1K count="${_size}" \
       status=progress
    chmod 0600 "${_image_path}"
    sync
    mkswap -L "${_label}" \
           -U "${_fsuuid}" \
           "${_image_path}"
}

#################################################
# Image making functions
#################################################

### Utility functions

# Returns internal size for an internal partition 
# from the outer image size
# $1: outer partition size
_get_internal_size() {
    local _size="${1}" _ratio
    local _s=50 _S=200 _l=1000 _L=5000
    if [[ "${_size}" -lt $((_s * 1000)) ]]; then
        _ratio=60
    elif [[ "${_size}" -gt $((_s * 1000)) ]] && \
         [[ "${_size}" -lt $((_S * 1000)) ]]; then
        _ratio=70
    elif [[ "${_size}" -gt $((_S * 1000)) ]] && \
         [[ "${_size}" -lt $((_l * 1000)) ]]; then
        _ratio=75
    elif [[ "${_size}" -gt $((_l * 1000)) ]] && \
         [[ "${_size}" -lt $((_L * 1000)) ]]; then
        _ratio=80
    else
        _ratio=85
    fi
    echo $(((_size * _ratio)/100))
}

### Base types

## EROFS (compressed read-only image type)

# Create an EROFS image containing the root file system and saves it on the ISO 9660 file system.
# $1: image path
# $2: directory to be put onto the image
# $3: UNIX time (for a date-based uuid)
_mkimg_erofs() {
    local _image_path="${1}"
    local _dir="${2}"
    local _epoch="${3}"
    _run_mkerofs "${_image_path}" \
                 "${_dir}" \
                 "${_epoch}"
    _msg_info "Done!"
}

## EXT4 (easily readable file system)

# Creates an ext4 file system image
# $1: directory to use to generate the image
# $2: image path
# $3: image size
# $4: UNIX time (for a date-based uuid)
# $5: partition label
_mkimg_ext4() {
    local _dir="${1}"
    local _image_path="${2}"
    local _size="${3}"
    local _epoch="${4}"
    local _label="${5}"
    local _writable="true"
    _run_mkext4 "${_dir}" \
                "$(_get_internal_size "${_size}")" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}"
    mv "${_dir}.img" "${_image_path}"
    sync
    _msg_info "Done!"
}

## FAT

# Creates a fat image.
# $1: image path
# $2: image size in bytes
# $3: image label
_mkimg_fat() {
    _run_mkfat "${@}"
}

## LUKS (encrypted file system container)

# Steps shared by the mkimg+<fs_image_type>+luks functions
# $1: name for the device mapper
# $2: an encryption key (prompts for one if empty)
# $3: partition label
_mkluks_common() {
    local _name="${1}" \
          _key="${2}" \
          _label="${3}"
    local _out="${work_dir}/${_label}.key"
    if [ "${_key}" = "" ]; then
        _ask_passwd "${_name}" "${_label}"
        printf "%s" "${_passphrase}" > "${_out}"
        _encryption_key="${_out}"
    elif [ "${_key}" = "auto" ]; then
        printf "%s" "$(tr -dc A-Za-z0-9 </dev/urandom | \
                         head -c 20 ; \
                       echo '')" > "${_out}"
        _encryption_key="${_out}"
    fi
}

## SQUASHFS (compressed read-only image type)

# Creates a squash fs image.
# $1: directory to create the squashfs image with
# $2: resulting image path
_mkimg_squashfs() {
    local _dir="${1}"
    local _image_path="${2}"
    _run_mksquashfs "${_dir}" \
                    "${_image_path}"
}

## SWAP (on-disk virtual memory)

# Creates a swap image.
# $1: path of the resulting image
# $2: partition size
# $3: UNIX time (for a date-based uuid)
# $4: partition label
_mkimg_swap() {
    _run_mkswap "${@}"
}

### 2-layered types

## EROFS over LUKS (encrypted compressed
#                   read-only image type)

# Create an EROFS image containing the root file system and saves it on the LUKS image.
# Save the LUKS image on the ISO 9660 file system.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the dm-verity layer will be disabled so that the image can be opened from GRUB
_mkimg_erofs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _grub="${8}"
    local _writable="false"
    local _tmp_img="${work_dir}/tmp.erofs" _tmp_size
    if [[ "${_size}" == "" ]]; then
	_msg_info "Running mkerofs in advance to determine LUKS partition size"
        _run_mkerofs "${_tmp_img}" \
                     "${_dir}" \
                     "${_epoch}"
        _tmp_size=$(_get_size "${_tmp_img}")
        _size=$(( 69420 + _tmp_size * 12 / 10))
    fi
    _mkluks_common "${_name}" \
                   "${_encryption_key}" \
                   "${_label}"
    _run_mkluks "${_image_path}" \
                "${_size}" \
                "${_encryption_key}" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}" \
                "${_grub}"
    if [[ "${_tmp_size}" != "" ]]; then
        _msg_info "Copying erofs image"
	if [[ "${quiet}" == "y" ]]; then
            dd if="${_tmp_img}" \
               of="${image_device}" > /dev/null 2>&1
	else
            dd if="${_tmp_img}" \
               of="${image_device}"
	fi
    else
	msg_info "Writing erofs image"
        _run_mkerofs "${image_device}" \
                     "${_dir}" \
                     "${_epoch}"
    fi 
    sync
    _close_luks_device "${image_device}"
}

## EXT4 over LUKS (encrypted image type)

# Creates an ext4 fs inside a LUKS container image file.
# $1: device mapper name
# $2: directory to be put onto the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a date-based uuid)
# $7: partion label
# $8: if true, the dm-verity will be disabled to let GRUB open it
_mkimg_ext4+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _grub="${8}"
    local _writable="true"
    _mkluks_common "${_name}" \
                   "${_encryption_key}" \
                   "${_label}"
    _run_mkluks "${_image_path}" \
                "${_size}" \
                "${_encryption_key}" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}" \
                "${_grub}"
    _run_mkext4 "${_dir}" \
                "$(_get_internal_size "${_size}")" \
                "${_epoch}" \
                "${_name}" \
                "${_writable}"
    dd if="${_dir}.img" \
       of="${image_device}" > /dev/null 2>&1
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

## EXT4 over RAID (high-availability/high-performance
#                  image type)

# Creates or expand an ext4-formatted RAID array
# $1: RAID name
# $2: files to be put onto the RAID
# $@: devices, in the following format <todo>
_mkimg+ext4+raid1() {
  local _name="${1}"
  local _dir="${2}"
  shift 2
  local _array=("${@}")
  _run_mkraid "${_name}"
  echo "${_array[@]}"
}

## EXT4 over SQUASHFS (easily supported file system over
##                     read-only compressed container)

# Creates an ext4 file system inside a squashfs image.
# $1: partition label
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: UNIX time (for a datetime-based uuid)
_mkimg_ext4+squashfs() {
    local _label="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _epoch="${5}"
    local _writable="false"
    _run_mkext4 "${_dir}" \
                "$(_get_internal_size "${_size}")" \
                "${_epoch}" \
                "${_name}" \
                "${_writable}"
    _run_mksquashfs "${_dir}.img" \
                    "${_image_path}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

# SQUASHFS over LUKS (encrypted compressed
#                     read-only image type)

# Creates a squashfs image and saves it on a LUKS image.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the image will be writable
# $9: if true, the dm-verity layer will be disabled 
#     so that the image can be opened from GRUB
_mkimg_squashfs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _writable="${8}"
    local _grub="${9}"
    _mkluks_common "${_name}" \
                   "${_encryption_key}" \
                   "${_label}"
    _run_mkluks "${_image_path}" \
                "${_size}" \
                "${_encryption_key}" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}" \
                "${_grub}"
    _run_mksquashfs "${_dir}" \
                    "${image_device}"
    sync
    _close_luks_device "${image_device}"
}

## SWAP over LUKS (encrypted swap)

# Creates a swap partition inside a LUKS container image file.
# $1: device mapper name
# $2: LUKS image path
# $3: image size
# $4: encryption key
# $5: UNIX time (for a date-based uuid)
# $6: partition label
# $7: if true, dm-verity layer will be disabled to open the image from GRUB
_mkimg_swap+luks() {
    local _name="${1}"
    local _image_path="${2}"
    local _size="${3}"
    local _encryption_key="${4}"
    local _epoch="${5}"
    local _label="${6}"
    local _grub="${7}"
    local _writable="true"
    _mkluks_common "${_name}" \
                   "${_encryption_key}" \
                   "${_label}"
    _run_mkluks "${_image_path}" \
                "${_size}" \
                "${_encryption_key}" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}" \
                "${_grub}"
    _run_mkswap "${image_device}" \
                "$(_get_internal_size "${_size}")" \
                "${_epoch}" \
                "${_name}"
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
}

### 3-layered types

## EXT4 over RAID over LUKS (encrypted high-performance/high-availability
#                            image type)

# Creates an ext4-formatted RAID1 on a LUKS images array
# $1: RAID name
# $2: directory to fill the RAID with
# $3: encryption key
# $4: UNIX time (to get a date-based UUID)
# $@: LUKS image paths array
_mkimg_ext4+raid1+luks() {
  local _name="${1}"
  local _dir="${2}"
  # local _image_path="${3}"
  # local _size="${4}"
  local _encryption_key="${3}"
  local _epoch="${4}"
  # local _label="${5}"
  # local _grub="${6}"
  local _writable="true"
  shift 4
  local _images=("$@")
  local _image
  for _image in "${_images[@]}"; do
      echo "${_device}"
      _mkluks_common "${_name}" \
                     "${_encryption_key}" \
                     "${_label}"
      _run_mkluks "${_image_path}" \
                  "${_size}" \
                  "${_encryption_key}" \
                  "${_epoch}" \
                  "${_label}" \
                  "${_writable}" \
                  "${_grub}"
  done

  for _device in "${_devices[@]}"; do
    _close_luks_device "${image_device}"
  done
}

## EXT4 OVER SQUASHFS OVER LUKS (encrypted compressed
#                                read-only image type) 

# Creates an ext4 image and packs it inside a squashfs image.
# Packs the squash image inside a LUKS image.
# $1: device mapper name
# $2: directory to put inside the image
# $3: image path
# $4: image size
# $5: encryption key
# $6: UNIX time (for a datetime-based uuid)
# $7: partition label
# $8: if true, the image will be writable
# $9: if true, the dm-verity layer will be disabled 
#     so that the image can be opened from GRUB
_mkimg_ext4+squashfs+luks() {
    local _name="${1}"
    local _dir="${2}"
    local _image_path="${3}"
    local _size="${4}"
    local _encryption_key="${5}"
    local _epoch="${6}"
    local _label="${7}"
    local _writable="${8}"
    local _grub="${9}"
    _mkluks_common "${_name}" \
                   "${_encryption_key}" \
                   "${_label}"
    _run_mkluks "${_image_path}" \
                "${_size}" \
                "${_encryption_key}" \
                "${_epoch}" \
                "${_label}" \
                "${_writable}" \
                "${_grub}"
    _run_mkext4 "${_dir}" \
                "$(_get_internal_size "${_size}")" \
                "${_epoch}" \
                "${_name}" \
                "${_writable}"
    _run_mksquashfs "${_dir}.img" \
                    "${image_device}"
    sync
    _close_luks_device "${image_device}"
    _msg_info "Done!"
    rm -- "${_dir}.img"
}

## Image making funtions arguments generation function

# Get opts for a mkimg<fs_type> function
# $1: file system composed type (ie. ext4+squashfs+luks)
_get_mkimg_opts() {
    local fs_type="${1}" \
          _erofs_opts=() \
          _erofs+luks_opts=() \
          _ext4_opts=() \
          _ext4+luks_opts=() \
          _ext4+squashfs+luks_opts=() \
          _fat_opts=() \
          _squashfs_opts=() \
          _squashfs+luks_opts=() \
          _swap_opts=() \
          _swap+luks_opts=() \
    _erofs_opts=(
      "${_image_path}"
      "${_dir}"
      "${_epoch}")
    _ext4_opts=(
      "${_dir}"
      "${_image_path}"
      "${_size}"
      "${_epoch}"
      "${_label}")
    _fat_opts=(
      "${_image_path}"
      "${_size}"
      "${_label}")
    _squashfs_opts=( 
      "${_dir}"
      "${_image_path}")
    _swap_opts=(
      "${_image_path}"
      "${_size}"
      "${_epoch}"
      "${_label}")
    _erofs+luks_opts=(
      "${_name}"
      "${_dir}"
      "${_image_path}"
      "${_auto_size}"
      "${_encryption_key}"
      "${_epoch}"
      "${_label}"
      "${_grub}")
    _ext4+luks_opts=(
      "${_name}"
      "${_dir}"
      "${_image_path}"
      "${_size}"
      "${_encryption_key}"
      "${_epoch}"
      "${_label}"
      "${_grub}")
    _ext4+squashfs_opts=(
      "${_name}"
      "${_dir}"
      "${_image_path}"
      "${_size}"
      "${_epoch}"
      "${_label}"
      "${_writable}")
    _squashfs+luks_opts=(
      "${_name}"
      "${_dir}"
      "${_image_path}"
      "${_size}"
      "${_encryption_key}"
      "${_epoch}"
      "${_label}"
      "${_writable}"
      "${_grub}")
    _swap+luks=(
      "${_name}"
      "${_image_path}"
      "${_size}"
      "${_encryption_key}"
      "${_epoch}"
      "${_label}"
      "${_grub}")
    _ext4+squashfs+luks_opts=(
      "${_name}"
      "${_dir}"
      "${_image_path}"
      "${_size}"
      "${_encryption_key}"
      "${_epoch}"
      "${_writable}"
      "${_grub}")
    echo "$(_get "${_fs_image}" \
                 "opts")"
}

# Produces a file system image
# $1: value in 'fs_images'
_mkimg() {
    local _image="${1}" \
          _image_type \
          _mkimg_opts=()
    rm -f -- "${_image_path}"
    _image_type="$(_get "${_image_type}" \
                        "image_type")")
    _mkimg_opts=("$(_get_mkimg_opts "${_image_type}")")
    "_mkimg_${_image_type}" "${_mkimg_opts[@]}"
}

##################################
# Volumes functions
###################################

# Install directories to a given volume
# at a given path
# $1: volume
# $@: files
# $#: destination as path in volume
_install_dir_cmd(){
    local _volume="${1}" \
          _cmd \
          _dir \
          _dir_array=() \
          _path=() \
          _dirs=() \
          _total_dirs=()
    shift
    _dirs=("${@}")
    for _dir in "${_dirs[@]}"; do
        _path=()
        IFS="/" \
          read -ra \
               _dir_array <<< \
            "${_dir}" 
        for _dir in "${_dir_array[@]}"; do
            _path+=(
              "${_dir}")
            _total_dirs+=(
              "$(IFS="/" ; \
                 echo "${_path[*]}")")
        done
    done
    _dirs=(
      "${_total_dirs[@]}")
    _cmd=(
      install -d
              -m 0755 --)
    [[ "${_volume}" == "efi_boot" ]] && \
      _cmd=(
        mmd -D o
            -i "$(_get "efi_boot" \
                       "img")" --) \
      _dirs=(
        "${_dirs[@]/#/::}")
    "${_cmd[@]}" "${_dirs[@]}"
}

# Install public files to a given volume
# $1: volume
# $@: files
# $#: destination as path in volume 
_install_cmd(){
    local _volume="${1}" \
          _cmd \
          _dest \
          _files=() \
          _root
    shift
    while [ "${#}" -gt 1 ]; do
        _files+=(
          "${1}")
        shift
    done
    printf -v _dest \
           '%s\n' \
           "${1}"
    [[ ! -d "${_dest}" ]] && \
    [[ ! -d "$(dirname "${_dest}")" ]] && \
      _install_dir_cmd "${_volume}" \
                       "${_dest}"
    if [[ "${_volume}" == "efi_boot" ]]; then
        _root="$(_get "${_volume}" \
                      "img")"
          _cmd=(
            mcopy -D o \
                  -i "${_root}" --)
          _dest="::${_dest}"
    else
        _root="$(_get "${_volume}" \
                      "dir")"
        _cmd=(
          install -D
                  -m 0644 --)
        _dest="${_root}${_dest}"
    fi
    "${_cmd[@]}" "${_files[@]}" \
                 "${_dest}"
}

# Install an encryption key in its
# canonical path in a volume
# $1: file system volume (value in
#     'fs_images')
# $2: encryption key to install
_install_key() {
    local _volume="${1}" \
          _key="${2}" \
          _dest
    _dest="$(_get "${_dest}" \
                  "dir")"
    _install_dir_cmd "${_volume}" \
                     "/etc"
    install -d \
            -m 700 \
            "${_dest}/etc/cryptsetup-keys.d"
    install -D \
            -m 400 \
            "${_key}" \
            "${_dest}/etc/cryptsetup-keys.d"
}

### Utility fuctions

# Returns the outest file system type for
# a given file system image, ignoring LUKS
# $1: a value in the 'fs_images' array
_get_fs_type() {
    local _volume="${1}" \
          _tmp
    _tmp="$(_get "${_volume}" \
                 "image_type")"
    _tmp="${_tmp%%+luks}"
    echo "${_tmp##*"+"}"
}

# Returns the extension for a given file system image
# $1: a value in 'fs_images' (airootfs, persistent, ...)
_get_fs_ext() {
    local _volume="${1}"
    local _fs_type
    _fs_type=$(_get_fs_type "${_volume}")
    if [ "${_fs_type}" = "squashfs" ]; then
        echo "sfs"
    else
        echo "${_fs_type}"
    fi
}

# Returns <image filename/device mapper name>
# for a given file system image.
# $1: a value in 'fs_images' array
_get_volume_name() {
    local _volume="${1}"
    echo "${_volume}" | tr -d '_'
}

# Produces canonical path for an image file
# given volume name
# (i.e. efi_boot -> <work_dir>/efiboot.img)
# $1: value in fs_images
_get_volume_img() {
    local _volume="${1}" \
          _ext \
          _volume_name
    _volume_name="$(_get_volume_name "${_volume}")"
    _ext="$(_get_fs_ext "${_volume}")"
    echo "$(_get "work" \
                 "dir")/${_volume_name}.${_ext}"
}

# Returns partition label for a physical partition
# $1: value in fs_images
_get_iso_partition_label() {
    local _image="${1}" \
          _label=("${iso_label}") \
          _suffix
    _suffix="$(echo "${_image}" | \
                 tr '[:lower:]' '[:upper:]')"
    [[ "${_suffix}" != "" ]] && \
    [[ "${_suffix}" != "airootfs" ]] && \
      _label+=("${_suffix}")
    echo "$(IFS=, ; \
            echo "${_label[*]}")" 
}

_set_volume_dir() {
    local _volume="${1}"
    _set "${_volume}" \
         "dir" \
         "$(_get "work" \
                 "dir")/${_volume}"
}

# Sets correct file system guid given type
_set_volume_guid() {
    local _volume="${1}" \
          _guid \
          _image_type
    _image_type="$(_get "${_volume}" \
                        "image_type")"
    if [[ "${_image_type}" == *"luks" ]]; then
        _guid="${luks_guid}"
    elif [[ "${_image_type}" == *swap ]]; then
        _guid="${swap_guid}"
    elif [[ "${_image_type}" == *ext4 ]]; then
        _guid="${linux_guid};"
    fi
    _set "${_volume}" \
         "guid" \
         "${_guid}"
}

# Sets parameters for _mk<fs_image> functions
# $1: value in fs_images
_mkfs_common() {
    local _volume="${1}"
    _name="$(_get_volume_name "${_volume}")"
    _dir="$(_get "${_volume}" \
                 "dir")"
    _epoch="$(_get_epoch "${_fs_image}")"
    _encryption_key="$(_get "${_volume}" \
                            "encryption_key")"
    _label="$(_get_iso_partition_label "${_volume}")"
    _size="$(_get "${_volume}" \
                  "size")"
    _image_path="$(_get_volume_img "${_volume}")"
    _grub="false"
    _writable="false"
    _set_volume_guid "${_volume}"
}

### Main ISO volumes

## Airootfs (the root file system image)

# Returns destination airootfs image path
_get_airootfs_dir() {
    echo "$(_get "iso" \
                 "dir")/$(_get "install" \
                               "dir")/${arch}"
}

# Returns path of airootfs image in work directory
_get_airootfs_img(){
    echo "$(_get_airootfs_dir)/airootfs.$(_get_fs_ext "airootfs")"
}

# Returns ISO airootfs image path
_get_airootfs_path(){
    echo "$(_get "install" \
                 "dir")/${arch}/airootfs.$(_get_fs_ext "airootfs")"
}

# Evaluate expected airootfs size given an input volume
# $1: volume from which to guess the airootfs size
_get_airootfs_size() {
    local _volume="${1}"
    echo $(( $(_get_size "$(_get "${_volume}" \
                                 "dir")") + 200000 ))
}

# Sets correct airootfs given an input volume
# $1: volume to use to set the airootfs size
_set_airootfs_size() {
    local _root="${1}" \
          _volume="airootfs"
    _set "${_volume}" \
         "size" \
         "$("_get_${_volume}_size" "${_root}")"
}

# Produces airootfs image
_mkairootfs() {
    _mkfs_common "airootfs"
    _mkfs_options=("${airootfs_image_tool_options[@]}")
    _dir="$(_get "pacstrap" \
                 "dir")"
    _image_path="$(_get_airootfs_img)"
    _auto_size=""
    [[ -e "${_dir}" ]] || \
      _msg_error "The path '${_dir}' does not exist" 1
    install -d -m 0755 -- "$(_get "airootfs" \
                                  "dir")"
    _mkimg "airootfs"
}

## EFI System Partition (ESP)

# Creates a FAT image (efiboot.img) which 
# will serve as the EFI system partition
# $1: image size in bytes
_mkefi_boot() {
    _mkfs_common "efi_boot"
    _label="ARCHISO_EFI"
    _size="$(du -bcs -- \
                "${efi_boot_files[@]}" 2>/dev/null | \
               awk 'END { print $1 }')"
    _mkimg "efi_boot"
    # Create the default/fallback boot path in
    # which boot loaders will be placed later.
    # _install_dir_cmd "efi_boot" \
    #                  "/EFI" \
    #                  "/EFI/BOOT"
    # ^ These should not be needed anymore due
    #   to directory recursively created
    #   in _install_dir_cmd
}

## Persistent (the user data partition)

# Builds persistent partition image
_mkpersistent() {
    _mkfs_common "persistent"
    _writable="true"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _grub="false"
    else
        _grub="true"
    fi
    _auto_size=""
    persistent_epoch="${_epoch}"
    _mkimg "persistent"
}

## Swap (on-disk virtual memory partition)

# Parameters for _mkswap_<fs_type> functions
_mkswap() {
    _mkfs_common "swap"
    _writable="true"
    _auto_size=""
    _mkimg "swap"
}

### Dongle ISO volumes

## Keys (the keys file system image)

# Returns workdir airootfs image path
_get_keys_img(){
    echo "$(_get "dongle_isofs" \
                 "dir")/${_name}.$(_get_fs_ext "keys")"
}

# Builds keys image
_mkkeys() {
    _mkfs_common "keys"
    _mkfs_options=("${keys_image_tool_options[@]}")
    _image_path="$(_get_keys_img)"
    _auto_size=""
    _mkimg "keys"
}

## Dongle boot (encrypted boot partition)

# Builds dongle boot partition image
_mkdongle_boot() {
    _mkfs_common "dongle_boot"
    _grub="true"
    _mkimg "boot"
}

## Dongle persistent (user data partition)

# Parameters for _mkdongle_persistent_<fs_type> functions
_mkdongle_persistent() {
    _mkfs_common "dongle_persistent"
    _writable="true"
    _mkimg "dongle_persistent"
}

## Dongle swap (on-disk virtual memory partition)

# Parameters for _mkdongle_swap_<fs_type> functions
_mkdongle_swap() {
    _mkfs_common "dongle_swap"
    _writable="true"
    _auto_size=""
    _mkimg "dongle_swap"
}

## Recovery (airootfs but onto a partition to boot
#            the dongle without the main ISO)

# Parameters for _mkrecovery_<fs_type> functions
_mkrecovery() {
    _mkfs_common "recovery"
    _mkfs_options=("${airootfs_image_tool_options[@]}")
    _dir="${pacstrap_dir}"
    _grub=true
    _auto_size=""
    [[ -e "${_dir}" ]] || \
      _msg_error "The path '${_dir}' does not exist" 1
    _mkimg "dongle_swap"
}

### Image integrity checking functions

# Returns a file SHA512 checksum
_mkchecksum() {
    local _file
    local _dir
    local _name
    _file="${1}"
    _dir=$(dirname "${_file}")
    _name=$(basename "${_file%.*}")

    cd -- "${_dir}"
    if [[ -e "${_file}" ]]; then
        _msg_info "Creating checksum of ${_file} for self-test..."
        sha512sum "$(basename "${_file}")" > "${_name}.sha512"
    fi
    cd -- "${OLDPWD}"
}

# GPG signs a file
_mksignature() {
    local _file="${1}"
    rm -f -- "${_file}.sig"
    local gpg_options=(
      --batch
      --no-armor
      --no-include-key-block
      --output "${_file}.sig"
      --detach-sign
      --default-key "${gpg_key}")
    # Add gpg sender option if the value is provided
    [[ -z "${gpg_sender}" ]] || \
      gpg_options+=('--sender' "${gpg_sender}")
    if [ -e "${_file}" ]; then
        _msg_info "Signing $(basename "${_file}")..."
        # always use the .sig file extension, as that is what 
        # mkinitcpio-archiso's hooks expect
        _msg_info "GPG home: ${gpg_home}"
        if [ "${gpg_home}" != "" ]; then
            gpg_options+=('--homedir' "${gpg_home}")
            GNUPGHOME="${gpg_home}" \
              gpg "${gpg_options[@]}" \
                  "${_file}"
        else
            gpg "${gpg_options[@]}" \
                "${_file}"
        fi
    fi
    _msg_info "Done!"
}

###################################
# Airootfs making utilities functions
###################################

#### Pre-install

### Encryption

# Fill a templatized crypttab
# $1: crypttab template
# $2: out file
_build_crypttab() {
    local _template="${1}"
    local _out="${2}"
    if [[ "$(_get "persistent" \
                  "image_type")" == *"luks" ]]; then
        sed "s|%PERSISTENT_UUID%|${persistent_uuid}|g" \
            "${_template}" > "${_out}"
    else
        sed '/%PERSISTENT_UUID%/d' \
            "${_template}" > "${_out}"
    fi
    if [[ "$(_get "dongle_persistent" \
                  "image_type")" == *"luks" ]]; then
        sed -i "s|%DONGLE_PERSISTENT_UUID%|${dongle_persistent_uuid}|g" \
            "${_out}"
    else
        sed -i '/%DONGLE_PERSISTENT_UUID%/d' \
            "${_out}"
    fi
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        sed -i "s|%SECURE_MOUNT%|/run/archiso/donglepersistent|g" \
            "${_out}"
    else
        sed -i "s|%SECURE_MOUNT%||g" \
            "${_out}"
    fi
    if [[ "${swap_image_type}" == *"luks" ]]; then
        sed -i "s|%SWAP_UUID%|$(_get_swap_uuid)|g" \
            "${_out}"
    else
        sed -i '/%SWAP_UUID%/d' \
            "${_out}"
    fi
    if [[ "${swap_size}" != "" ]] && \
       [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        sed -i "s|%DONGLE_SWAP_UUID%|$(_get_dongle_swap_uuid)|g" \
            "${_out}"
    else
        sed -i '/%DONGLE_SWAP_UUID%/d' "${_out}"
    fi
}

_get_crypttab() {
    local _volume="${1}"
    echo "($(_get "${_volume}"
                  "dir")/airootfs/etc/crypttab"
}

_make_crypttab() {
    local _src="${1}"
    local _root="${2}" \
    _build_crypttab "$(_get_crypttab "${1}")" \
                    "$(_get "${_root}" \
                            "dir")/etc/crypttab"
}

# Generates an encryption key when the "auto" value
# has been specified for an <image>_encryption_key
# variable in profiledef.sh
# $1: output file path
# $2: mode (binary/random plain)
_gen_key() {
    local _out="${1}" \
          _mode="${2}" \
          _Mode
    if [ "${_mode}" == "binary" ]; then
        _Mode="Binary key file"
        dd if=/dev/random \
           bs=512 \
           count=1 \
           of="${_out}" > /dev/null 2>&1
    elif [ "${_mode}" == "plain" ]; then
        _Mode="Random plaitext password"
        printf "%s" \
               "$(tr -dc A-Za-z0-9 </dev/urandom | \
                    head -c 20 ; \
                    echo '')" > "${_out}"
    fi
    _msg_info "${_Mode} for ${_volume}"
}

# Parse encryption key variable value for a
# file system image.
# If the variable is set to "auto" it will
# generate a key at a selected location
# $1: a value in fs_images
# $2: auto-generated output key path
_resolve_fs_encryption_key(){
    local _volume="${1}" \
          _auto_key="${2}"
    local _encryption_key \
          _msg=() \
          _out_dir
    _encryption_key="$(_get "${_volume}" \
                            "encryption_key")"
    _out_dir="$(dirname "${_auto_key}")"
    [ ! -f "${_encryption_key}" ] && \
      if [ "${_encryption_key}" = 'auto' ]; then
          _set "${_volume}" \
               "encryption_key" \
               "${_auto_key}"
          [ ! -d "${_out_dir}" ] && \
            install -d -m 700 "${_out_dir}"
          _gen_key "${_auto_key}" \
                   "binary"
      elif [ "${_encryption_key}" != 'auto' ]; then
          _msg=("File '${_encryption_key}'"
                "does not exist.")
          _msg_error "${_msg[*]}" 0
      fi
}

# Returns encryption key destination volume and
# generation mode for a given file system volume
# $1 file system volume
_get_secondary_key_opts() {
    local _volume="${1}" \
          _dest \
          _encryption_key \
          _image_type \
          _mode="binary" \
          _public_image_type
    _public_image_type="$(_get "airootfs" \
                               "image_type")"
    _image_type="$(_get "${_volume}" \
                        "image_type")"
    _encryption_key="$(_get "${_volume}" \
                            "encryption_key")"
    if [[ "${_encryption_key}" == "auto" ]]; then
        [[ "${_public_image_type}" != *"luks" ]] && \
        [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
          _dest="dongle_persistent" \
          _mode="plain"
    elif [[ "${_public_image_type}" == *"luks" ]] && \
         [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _dest="pacstrap"
    elif [[ "${_public_image_type}" != *"luks" ]] && \
         [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _dest="dongle_persistent"
    elif [[ "${_public_image_type}" != *"luks" ]] && \
         [[ "${_volume}" != "persistent" ]] && \
         ( ! [[ " ${buildmodes[*]} " =~ ' dongle ' ]] ); then
        _dest="persistent"
    else
        _dest="seedphrase"
        _mode="plain"
    fi
    echo "${_dest}" "${_mode}"
}

# Resolves the value of an image encryption key from an
# <image>_encryption_key profiledef.sh variable
# $1: a value in volumes
_resolve_secondary_key() {
    local _volume="${1}"
    local _auto_key="${work_dir}/${_volume}.key" \
          _dest \
          _msg \
          _key_opts=() \
          _mode
    _key_opts=(
      $(_get_secondary_key_opts "${_volume}"))
    _dest="${_key_opts[0]}"
    _mode="${_key_opts[1]}"
    [[ "${_dest}" == "seedphrase" ]] && \
      _msg=("Rootfs encryption and dongle buildmode disabled."
            "You will be prompted to insert a password for"
            "the ${_volume} partition.") && \
      _msg_warning "${_msg[*]}" && \
      _set "${_volume}" \
           "encryption_key" \
           "" && \
      return
    _set "${_volume}" \
         "encryption_key" \
         "${_auto_key}"
    _gen_key "$(_get "${_volume}" \
                     "encryption_key")" \
             "${_mode}"
    _install_key "${_dest}" \
                 "${_auto_key}"
}

# Adds archiso hooks to profile's mkinitcpio.conf
# $1: mkinitcpio.conf file to edit
# $2: an encryption key to add to resulting initrd image
_build_archiso_mkinitcpio_conf() {
    local _mkinitcpio_conf="${1}"
    local _encryption_key="${2}"
    local _files=() _hooks=() _modules=()
    local _mkinitcpio_conf_tmp="${work_dir}/mkinitcpio.conf"
    [[ "$(_get "airootfs" \
               "image_type")" == *luks ]] || \
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
      _hooks+=("encrypt") && \
      [[ "${_encryption_key}" != "" ]] && \
        _files+=("${_encryption_key}")
    _hooks+=("archiso")
    [[ "${airootfs_image_type}" == *"ext4"* ]] && \
      _modules+=("ext4")
    cp "${_mkinitcpio_conf}" "${_mkinitcpio_conf_tmp}"
    sed "s|%ARCHISO_FILES%|${_files[*]}|g;
         s|%ARCHISO_HOOKS%|${_hooks[*]}|g;
         s|%ARCHISO_MODULES%|${_modules[*]}|g" \
        "${_mkinitcpio_conf_tmp}" > "${_mkinitcpio_conf}"
}

_make_archiso_mkinitcpio_conf() {
    local _root="${1}" \
          _volume="${2}"
    cp "$(_get "profile" \
               "dir")/etc/mkinitcpio.conf" \
       "$(_get "${_root}" \
               "dir")/etc/mkinitcpio.${_volume}.conf"
    _build_archiso_mkinitcpio_conf \
       "$(_get "${_root}" \
               "dir")/etc/mkinitcpio.${_volume}.conf" \
       "$(_get "${_volume}" \
               "encryption_key")"
}

# Sets up custom pacman.conf with custom cache and pacman hook directories.
_make_pacman_conf() {
    local _cache_dirs \
          _default_cache="/var/cache/pacman/pkg" \
          _hooks="${pacstrap_dir}/etc/pacman.d/hooks" \
          _profile_cache_dirs \
          _system_cache_dirs \
    _system_cache_dirs="$(pacman-conf CacheDir | \
                            tr '\n' ' ')"
    _profile_cache_dirs="$(pacman-conf --config "${pacman_conf}" \
                                       CacheDir | \
                             tr '\n' ' ')"

    # Only use the profile's CacheDir, if it is not the
    # default and not the same as the system cache dir.
    if [[ "${_profile_cache_dirs}" != "${_default_cache}" ]] && \
       [[ "${_system_cache_dirs}" != "${_profile_cache_dirs}" ]]; then
        _cache_dirs="${_profile_cache_dirs}"
    else
        _cache_dirs="${_system_cache_dirs}"
    fi

    _msg_info "Copying custom pacman.conf to work directory..."
    _msg_info "Using pacman CacheDir: ${_cache_dirs}"
    # take the profile pacman.conf and strip all settings 
    # that would break in chroot when using pacman -r.
    # append CacheDir and HookDir to [options] section
    # HookDir is *always* set to the airootfs' override directory
    # see `man 8 pacman` for further info
    pacman-conf --config "${pacman_conf}" | \
        sed "/CacheDir/d;/DBPath/d;/HookDir/d;/LogFile/d;/RootDir/d;/\[options\]/a CacheDir = ${_cache_dirs}
             /\[options\]/a HookDir = ${_hooks}/" > \
          "$(_get "work" \
                  "dir")/${buildmode}.pacman.conf"
}

#### Install

# Checks whether an image's file system path
# is present in the profile directories
# $1: file system path
_is_file_in_work_paths() {
    local _filename="${1}"
    local _dir
    local _dirs=("$(_get "profile" \
                         "dir")/airootfs"
                 "$(_get "profile" \
                         "dir")/persistent")
    _pass="false"
    for _dir in "${_dirs[@]}"; do
        if [ -e "${_dir}${_filename}" ]; then
            _pass=""
        fi
    done
}

# Checks if an image's file system path can be
# applied permissions on
# $1: filename path
# $2: image name (airootfs, persistent)
_validate_file_path() {
    local _filename="${1}" \
          _storage="${2}"
    local _msg \
          _on_storage="${_storage}${_filename}" \
          pacstrap_dir="$(_get "work" \
                               "dir")/${arch}/airootfs" \
          persistent_dir="$(_get "work" \
                                 "dir")/persistent"
    _validate_file_result="false"
    _validate_file_err=""
    _validate_file_warn=""
    _is_file_in_work_paths "${_filename}"
    if [[ "${_pass}" != "" ]]; then
        _msg=("Cannot change permissions of '${_filename}'."
              "The file or directory does not exist.")
        _validate_file_err="${_msg[*]}"
        return
    fi
    if [[ ! -e "${_on_storage}" ]]; then
        _msg=("Cannot change permissions of '${_on_storage}'."
              "The file or directory does not exist on this storage.")
        _validate_file_warn="${_msg[*]}"
    elif [[ "$(realpath -q -- "${_on_storage}")" != "${_storage}"* ]]; then
        _msg=("Failed to set permissions on '${_on_storage}'."
              "Outside of valid path.")
        _validate_file_err="${_msg[*]}"
    else
        _validate_file_result=""
    fi
}

# Apply file permissions on files 
# copied to a directory, with paths relative
# to that directory
# $1: file path as on the host file
#     system (ie. /etc/fstab)
# $2: permissions string
# $3: directory where files are being put into
_apply_permissions() {
    local _filename="${1}" \
          _permissions="${2}" \
          _volume="${3}"
          _chmod_opts=() \
          _chown_opts=() \
          _dir \
          _group \
          _msg_type="warning" \
          _opts=('-f')
          _mode \
          _permissions_array=()
          _recur=() \
          _user
    _dir="$(_get "${_volume}" \
                 "dir")"
    _validate_file_err=""
    _validate_file_warn=""
    _validate_file_result=""
    IFS=':' \
      read -ra _permissions_array <<< \
        "${_permissions}"
    _user="${_permissions_array[0]}" \
    _group="${_permissions_array[1]}" \
    _mode="${_permissions_array[2]}"
    _validate_file_path "${_filename}" \
                        "${_dir}"
    if [[ "${_validate_file_result}" == "" ]]; then
        _msg=(
          "Setting ${_mode} permissions for"
          "${_user}:${_group} on ${_filename}")
        [[ "${_filename: -1}" == "/" ]] && \
          _recur+=(
            '-R') \
          _msg+=(
            "recursively")
        [[ "${quiet}" != "y" ]] && \
          _msg_info "${_msg[*]}"
        _chown_opts=(
          "${_opts[@]}"
          '-h'
          "${_recur[@]}")
        _chmod_opts=(
          "${_opts[@]}"
          "${_recur[@]}")
        chown "${_chown_opts[@]}" -- \
              "${_user}:${_group}" \
              "${_dir}${_filename}"
        chmod "${_chmod_opts[@]}" -- \
              "${_mode}" \
              "${_dir}${_filename}"
    else
	    [ "${_validate_file_err}" != "" ] && \
	      _msg_type="error" \
	      _error_code=1
        [[ "${_validate_file_err}" != "" ]] && \
          "_msg_${_msg_type}" "${_validate_file_err}" \
                              "${_error_code}"
        [[ "${quiet}" != "y" ]] && \
        [[ "${_validate_file_warn}" != "" ]] && \
          "_msg_${_msg_type}" "${_validate_file_warn}"
    fi
}

# Copies custom files onto an image, reading and 
# applying permissions parsed from the `file_permissions'
# array
# $1: archiso profile-tracked file system
#     image name (airootfs, persistent)
# $2: work directory for that file system
_copy_profile_files() {
    local _volume="${1}" \
          _dest="${2}" \
          _cp_opts=() \
          _error_code \
          _file_name \
          _msg=()
    _cp_opts=(
      -af
      --no-preserve=ownership,mode)
    _msg_info "Copying custom ${_volume} files..."
    cp "${_cp_opts[@]}" -- \
       "$(_get "profile" \
               "dir")/${_volume}/." \
       "$(_get "${_dest}" \
               "dir")"
    for _file_name in "${!file_permissions[@]}"; do
        _apply_permissions "${_file_name}" \
                           "${file_permissions[${_file_name}]}" \
                           "${_dest}"
    done
}

# Sets up an empty root directory for
# a root file system
# $1: directory
_install_root_dir() {
    local _root="${1}"
    install -d \
            -m 0755 \
            -o 0 \
            -g 0 -- \
            "${_root}"
} 

# Prepares working directory and copies custom root file system files.
_make_custom_airootfs() {
    _validate_file_err="" _validate_file_warn=""
    local _etc \
          _root="pacstrap" \
          _volume="airootfs"

    install_root_dir "$(_get "${_root}" \
                             "dir")"
    [[ -d "$(_get "profile" \
                  "dir")/${_volume}" ]] && \
      _copy_profile_files "${_volume}" \
                          "${_root}" && \
      _build_archiso_mkinitcpio_conf \
          "$(_get "${_root}" \
                  "dir")/etc/mkinitcpio.conf" && \
      [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
          _resolve_secondary_key "keys" && \
          if [[ "$(_get "${_volume}" \
                        "image_type")" == *luks ]]; then
              # shellcheck disable=SC2034
              _set "dongle_boot" \
                   "encryption_key" \
                   "$(_get "keys" \
                           "encryption_key")"
              _make_archiso_mkinitcpio_conf "${_root}" \
                                            "dongle_boot"
              _resolve_secondary_key "recovery"
              _make_archiso_mkinitcpio_conf "${_root}" \
                                            "recovery"
          fi
}

# Install desired packages to the root file system
_make_packages() {
    local _root="${1}" \
          _msg=()  \
          _opts=()
    _opts=(
      -C "$(_get "work" \
                 "dir")/${buildmode}.pacman.conf"
      -c
      -G
      -M)
    _msg=(
      "Installing packages to '$(_get "${_root}" \
                                      "dir")/'...")
    _msg_info "${_msg[*]}"
    # Unset TMPDIR to work around
    # https://bugs.archlinux.org/task/70580
    [[ "${quiet}" = "y" ]] && \
      env -u TMPDIR \
        pacstrap "${_opts[@]}" -- \
                 "$(_get "${_root}" \
                         "dir")" \
                 "${buildmode_pkg_list[@]}" > \
          /dev/null 2>&1 && \
      return
    env -u TMPDIR \
      pacstrap "${_opts[@]}" -- \
               "$(_get "${_root}" \
                       "dir")" \
               "${buildmode_pkg_list[@]}"
    _msg=(
      "Done! Packages installed successfully.")
    _msg_info "${_msg[*]}"
}


# Install desired packages to the root file system
# for airootfs
_make_packages_airootfs() {
    local _root="pacstrap"
    [[ -n "${gpg_key}" ]] && \
      exec {ARCHISO_GNUPG_FD}<>"$(_get "work" \
                                       "dir")/pubkey.gpg" && \
      export ARCHISO_GNUPG_FD
    _make_packages "${_root}"
    [[ -n "${gpg_key}" ]] && \
      exec {ARCHISO_GNUPG_FD}<&- && \
      unset ARCHISO_GNUPG_FD
    _msg_info "Done! Packages installed successfully."
}

# Write version file to ISO 9660
_make_version_iso() {
    local _buildmode="${1}"
    [[ "${_buildmode}" == @("iso"|"netboot") ]] && \
      install_dir_cmd "iso" \
                      "/$(_get "install" \
                               "dir")" && \
      printf '%s\n' \
             "${iso_version}" > \
        "$(_get "iso" \
                "dir")/$(_get "install" \
                              "dir")/version" && \
      # Write grubenv with version information to ISO 9660
      printf '%.1024s' \
             "$(printf '# GRUB Environment Block\nNAME=%s\nVERSION=%s\n%s' \
                       "${iso_name}" \
                       "${iso_version}" \
                       "$(printf '%0.1s' \
                                 "#"{1..1024})")" > \
        "$(_get "iso" \
                "dir")/$(_get "install" \
                              "dir")/grubenv"
}

# Append IMAGE_ID & IMAGE_VERSION to os-release
_make_os_release() {
    local _root="${1}"
    local _msg=()
    # Append IMAGE_ID & IMAGE_VERSION to os-release
    _os_release="$(realpath -- "$(_get "${_root}" \
                                       "dir")/etc/os-release")"
    [[ ! -e "$(_get "${_root}" \
                    "dir")/etc/os-release" ]] && \
    [[ -e "$(_get "${_root}" \
                  "dir")/usr/lib/os-release" ]] && \
      _os_release="$(realpath -- "$(_get "${_root}" \
                                         "dir")/usr/lib/os-release")"
    if [[ "${_os_release}" != "$(_get "${_root}" \
                                      "dir")"* ]]; then
        _msg=("os-release file '${_os_release}'"
              "is outside of valid path.")
        _msg_warning "${_msg[*]}"
    else
        [[ ! -e "${_os_release}" ]] || \
          sed -i '/^IMAGE_ID=/d;/^IMAGE_VERSION=/d' \
              "${_os_release}"
        printf 'IMAGE_ID=%s\nIMAGE_VERSION=%s\n' \
               "${iso_name}" \
               "${iso_version}" >> \
          "${_os_release}"
    fi
}

# Touch /usr/lib/clock-epoch to give another
# hint on date and time for systems
# with screwed or broken RTC.
# $1: location of a root file system
_make_clock_epoch() {
    local _root="${1}"
    touch -m \
          -d"@${SOURCE_DATE_EPOCH}" -- \
          "$(_get "${_root}" \
                  "dir")/usr/lib/clock-epoch"
}

# Produces version files
_make_version() {
    local _root="pacstrap" \
          _dest="iso" \
          _os_release
    _msg_info "Creating version files..."
    rm -f -- \
       "$(_get "${_root}" \
               "dir")/version"
    printf '%s\n' \
           "${iso_version}" > \
      "$(_get "${_root}" \
              "dir")/version"
    _make_version_iso "${buildmode}"
    _make_os_release "${_root}"
    _make_clock_epoch "${_root}"
    _msg_info "Done!"
}

### Post-install

# Sets up home directories for users from a 
# passwd file in a root directory
# $1: volume name for the root file system
# $2: passwd file path
_user_setup_passwd() {
   local _volume="${1}" \
         _passwd="${2}" \
         _chroot \
         _gid \
         _home \
         _msg=() \
         _passwd_array \
         _path \
         _uid \
   _chroot="$(_get "${_volume}" \
                   "dir")"
   [[ "${_passwd}" == "" ]] && \
     _passwd="${_chroot}/etc/passwd"
   _msg_info "Copying /etc/skel/* to user homes..."
   while IFS=':' read -a _passwd_array -r; do
       _uid="${_passwd_array[2]}"
       _gid="${_passwd_array[3]}"
       _home="${_passwd_array[5]}"
       # Only operate on UIDs in range 100059999
       (( _uid >= 1000 && _uid < 60000 )) || \
         continue
       # Skip invalid home directories
       [[ "${_home}" == '/' ]] && \
         continue
       [[ -z "${_home}" ]] && \
         continue
       # Prevent path traversal outside of $pacstrap_dir
       _path="$(realpath -q -- \
                         "${_chroot}${_home}")"
       if [[ "${_path}" == "${_chroot}"* ]]; then
           [[ ! -d "${_chroot}${_home}" ]] && \
             install -d \
                     -m 0750 \
                     -o "${_uid}" \
                     -g "${_gid}" -- \
                     "${_chroot}${_home}"
           cp -dnRT \
              --preserve=mode,timestamps,links -- \
              "${_chroot}/etc/skel/." \
              "${_chroot}${_home}"
           chmod -f 0750 -- \
                 "${_chroot}${_home}"
           chown -hR -- \
                 "${_uid}:${_gid}" \
                 "${_chroot}${_home}"
       else
           _msg=("Failed to set permissions on"
                 "'${_chroot}${_home}'."
                 "Outside of valid path.")
           _msg_error "${_msg[*]}" 1
       fi
   done < "${_passwd}"
}

# Runs a script in a chroot
# $1: chroot path
# $2: custom script path (relative to chroot)
_run_chroot_script() {
    local _volume="${1}" \
          _custom_script="${2}" \
          _deprecation_msg=(
            "customize_airootfs.sh is deprecated!"
            "Support for it will be removed in a"
            "future archiso version.")
    local _start_msg=(
            "Running customize_airootfs.sh in"
            "'$(_get "${_volume}" \
                     "dir")' chroot...")
    _msg_info "${_start_msg[@]}"
    _msg_warning "${_deprecation_msg[*]}"
    chmod -f -- \
          +x \
          "$(_get "${_volume}" \
                  "dir")${_custom_script}"
    # Unset TMPDIR to work around 
    # https://bugs.archlinux.org/task/70580
    eval -- env -u TMPDIR \
              arch-chroot "$(_get "${_volume}" \
                                  "dir")" \
                          "${_custom_script}"
    rm -- "$(_get "${_volume}" \
                  "dir")${_custom_script}"
    _msg_info "Done! ${_custom_script} run successfully."
}

# Customize installation.
_make_customize_airootfs() {
    local _root="pacstrap"
          _custom_script="/root/customize_airootfs.sh"
    [[ -e "${_passwd}" ]] &&
      _user_setup_passwd "${_root}"
    [[ -e "${_custom_script_path}" ]] && \
      _run_chroot_script "${_root}" \
                         "${_custom_script}"
}

# $1: Root file system from which to generate the
#     list
# $2: Destination volume
# $3: Directory path in the destination volume
_gen_pkglist() {
    local _root="${1}" \
          _volume="${2}"
          _dest="${3}"
    _install_dir_cmd "${_volume}" \
                     "${_dest}"
    pacman -Q \
           --sysroot "$(_get "${_root}" \
                             "dir")" > \
      "$(_get "${_volume}" \
              "dir")${_dest}/pkglist.${arch}.txt"
}

# Produces a list of the installed packages
_make_pkglist() {
    local _dest \
          _msg=() \
          _flag \
          _path \
          _root="pacstrap" \
          _volume="airootfs"
    _msg=("Creating a list of installed"
          "packages on live-enviroment..."
    _msg_info "${_msg[*]}"
    case "${buildmode}" in
        "bootstrap")
            _flag=true
            _dest="${_root}"
            _path="/"
            ;;
        "iso")
            [[ ! "$(_get "${_volume}" \
                         "image_type")" == *"luks"* ]] && \
              _flag=true \
              _dest="iso" \
              _path="/$(_get "install" \
                             "dir")"
            ;;
        "netboot")
            _flag=true
            _dest="iso"
            _path="$(_get "install" \
                          "dir")"
            ;;
    esac
    [[ "${_flag}" == "true" ]] && \
      _gen_pkglist "${_root}" \
                   "${_dest}" \
                   "${_path}"
    _msg_info "Done!"
}

# Cleanup airootfs
_cleanup_pacstrap_dir() {
    local _root="pacstrap" \
          _images=() \
          _boot \
          _cp_opts=() \
          _log \
          _machine_id \
          _pacman_db \
          _pacman_cache \
          _tmp \
   _images=(
     "initramfs-*"
     "vmlinuz-*"
     "${ucodes[@]}")
    _cp_opts=(
      '-af'
      '--no-preserve=ownership,mode')
    _boot="$(_get "${_root}"\
                  "dir")/boot" \
    _log="$(_get "${_root}" \
                       "dir")/var/log" \
    _machine_id="$(_get "${_root}" \
                        "dir")/etc/machine-id" \
    _pacman_db="$(_get "${_root}" \
                       "dir")/var/lib/pacman" \
    _pacman_cache="$(_get "${_root}" \
                          "dir")/var/cache/pacman/pkg" \
    _tmp="$(_get "${_root}" \
                 "dir")/var/tmp" \
    _msg_info "Cleaning up in pacstrap location..."

    # Move kernel, initramfs and microcodes for later usage
    _install_dir_cmd "work" \
                     "/boot"
    for _query in "${_images[@]}"; do
        find "${_boot}" \
             -iname "${_query}" \
             -exec cp "${_cp_opts[@]}" \
                      {} \
                      "${work_dir}/boot" \; \
             -quit
    done
    [[ -d "${_boot}" ]] && \
      find "${_boot}" \
           -maxdepth 1 \
           -type f \
           -delete
    # Delete pacman database sync cache files (*.tar.gz)
    [[ -d "${_pacman_db}" ]] && \
      find "${_pacman_db}" \
           -maxdepth 1 \
           -type f \
           -delete
    # Delete pacman database sync cache
    [[ -d "${_pacman_db}/sync" ]] && \
      find "${_pacman_db}/sync" \
           -delete
    # Delete pacman cache files
    [[ -d "${_pacman_cache}" ]] && \
      find "${_pacman_cache}" \
           -type f \
           -delete
    # Delete all log files, keeps empty dirs.
    [[ -d "${_log}" ]] && \
      find "${_log}" \
           -type f \
           -delete
    # Delete all temporary files and dirs
    [[ -d "${_tmp}" ]] && \
      find "${_tmp}" \
           -mindepth 1 \
           -delete
    # Delete package pacman related files.
    find "$(_get "work" \
                 "dir")" \
          \( -name '*.pacnew' \
             -o -name '*.pacsave' \
             -o -name '*.pacorig' \) \
          -delete
    if [[ "$(_get "persistent" \
                  "size")" != "" ]]; then
        dbus-uuidgen --ensure="${_machine_id}"
    else
        # Create an empty /etc/machine-id
        rm -f -- "${_machine_id}"
        printf '' > "${_machine_id}"
    fi
    _msg_info "Done!"
}

################
# UUID getters
################

### Constant UUIDs

## Main ISO

# Returns UUID for the GRUB plain mount
_get_archiso_uuid() {
    #shellcheck disable=SC2005
    echo "$(_epoch_to_uuid "$(_get_epoch airootfs)")"
}

# Swap partition

# Returns UUID for the dongle swap mount
_get_swap_uuid() {
    local _epoch
    _epoch="$(_get_epoch swap)"
    [[ "${buildmode}" == 'dongle' ]] && \
      _epoch="$(_get_epoch dongle_swap)"
    _get_epoch_fsuuid "${_epoch}"
}

## Dongle ISO

# Returns UUID for the dongle GRUB plain mount
_get_dongle_uuid() {
    #shellcheck disable=SC2005
    echo "$(_epoch_to_uuid "$(_get_epoch dongle)")"
}

# Dongle persistent partition

# Returns dongle persistent partition uuid
_get_dongle_persistent_uuid() {
    local _epoch
    _epoch=$(_get_epoch dongle_persistent)
    _get_epoch_fsuuid "${_epoch}"
}

# Dongle swap partition

# Returns dongle swap partition uuid
_get_dongle_swap_uuid() {
    local _epoch
    _epoch="$(_get_epoch dongle_swap)"
    _get_epoch_fsuuid "${_epoch}"
}

## Variable UUIDs

# Boot device UUID

# Returns ISO image uuid for current buildmode
_get_bootable_uuid() {
    local _uuid
    _uuid="$(_get_archiso_uuid)"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _uuid=$(_get_dongle_uuid)
    fi
    echo "${_uuid}"
}

# Encrypted boot

# Converts UUID in a format compatible with GRUB cryptomount 
_get_cryptomount_uuid() {
    local _epoch
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _epoch="$(_get_epoch dongle_boot)"
    else
        _epoch="$(_get_epoch persistent)"
    fi
    _get_epoch_fsuuid "${_epoch}" | sed "s|-||g"
}

###############################################
# Bootloaders related functions
###############################################

# Returns the correct device selection command line for use in a templatized GRUB
# configuration file
_get_device_select_cmdline() {
    local _cmd=(
      search --no-floppy
             --set=root
             --fs-uuid "$(_get_bootable_uuid)")
    #shellcheck disable=SC2005
    [[ "$(_get "persistent" \
               "image_type")" == *luks ]] && \
      _cmd=(cryptomount -u "$(_get_cryptomount_uuid)")
    echo "${_cmd[*]}"
}

# Produces the 'encrypt' hook's kernel parameters
# needed to boot an encrypted ISO.
_get_crypto_params() {
    local _volume="airootfs" \
          _cryptdevice=() \
          _cryptkey=() \
          _cparams=()
    [[ "$(_get "${_volume}" \
               "image_type")" == *luks ]] && \
      _cryptdevice=(
        "UUID=$(_get_archiso_uuid),$(_get_airootfs_path)"
        "root"
        "readonly") && \
      _cparams+=(
        "root=/dev/mapper/root"
        "cryptdevice=$(IFS=: ; \
                       echo "${_cryptdevice[*]}")") && \
      [ "$(_get "${_volume}" \
                "encryption_key")" != "" ] && \
        _cryptkey=(
          "UUID=$(_get_dongle_uuid)"
          "iso9660,$(_get_fs_type "keys")"
          "keys.$(_get_fs_ext "keys"),${volume}.key") && \
        _cparams+=(
          "cryptkey=$(IFS=: ; \
                      echo "${_cryptkey[*]}")")
    echo "${_cparams[@]}"
}

# Produces kernel parameters.
_get_kernel_params() {
    local _volume="airootfs" \
          _kparams=() \
          _sigdevice=()
    _kparams+=(
      "archisobasedir=$(_get "install" \
                             "dir")"
      "archisolabel=${iso_label}"
      "archisouuid=$(_get_archiso_uuid)"
      "$(_get_crypto_params)")
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
      _sigdevice=(
        "UUID=$(_get_dongle_uuid)"
        "iso9660"
        "$("_get_${_volume}_path").sig") && \
      _kparams+=("sigdevice=$(IFS=: ; \
                              echo "${_sigdevice[*]}")"
                 "verify=y")
    echo "${_kparams[@]}"
}

# Fill a bootloader configuration template and copy the result in a file
# $1: bootloader configuration file (templatized, see profile directory)
# $2: bootloader (empty?)
_gen_bootloader_config() {
    local _template="${1}"
    sed "s|%DEVICE_SELECT_CMDLINE%|$(_get_device_select_cmdline)|g;
         s|%ARCH%|${arch}|g;
         s|%INSTALL_DIR%|/${install_dir}|g;
         s|%KERNEL_PARAMS%|$(_get_kernel_params)|g;
         s|%BOOTABLE_UUID%|$(_get_bootable_uuid)|g;
         s|%FALLBACK_UUID%|$(_get_archiso_uuid)|g" \
        "${_template}"
}

### GRUB

# generate an 'external loader' embedded GRUB
# configuration file for use on UEFI platforms
_gen_grub_embed_cfg() {
    local _boot_loader="grub" \
          _embed_cfg
    IFS='' \
      read -r \
           -d '' \
           _embed_cfg <<'EOF' || true
if ! [ -d "$cmdpath" ]; then
    # On some firmware, GRUB has a wrong cmdpath
    # when booted from an optical disc.
    # https://gitlab.archlinux.org/archlinux/archiso/-/issues/183
    if regexp --set=1:isodevice '^(\([^)]+\))\/?[Ee][Ff][Ii]\/[Bb][Oo][Oo][Tt]\/?$' "$cmdpath"; then
        cmdpath="${isodevice}/EFI/BOOT"
    fi
fi
configfile "${cmdpath}/grub.cfg"
EOF
    printf '%s\n' \
           "${_embed_cfg}" > \
      "$(_get \
             "profile" \
             "dir")/$(_get_bl \
                          "${_boot_loader}")/${_boot_loader}-embed.cfg"
}

## Copy configuration files
# Prepare bootloader configuration files
_make_common_bootloader_cfg(){
    local _volume="${1}" \
          _boot_loader="${2}"
    _make_bootloader_config \
        "${_volume}" \
        "/$(_get_bl \
                "${_boot_loader}")/$(_get_bl_cfg \
                                         "${_boot_loader}")" \
        $(_get_bl_cfg_files \
              "profile" \
              "${_boot_loader}")
}

## GRUB configuration files
# Prepare GRUB configuration files
_make_common_bootloader_grub_cfg(){
    _make_common_bootloader_cfg "work" \
                                "grub"
    _gen_grub_embed_cfg
}

# Get correct GRUB module list for a given platform
# Module list from 
# https://bugs.archlinux.org/task/71382#comment202911
# $1: 'bios' or 'efi'
_get_grub_modules(){
    local _mode="${1}"
    _modules=(
      afsplitter boot bufio chain configfile
      disk echo ext2
      gcry_sha256 halt iso9660 linux
      loadenv loopback minicmd  normal 
      part_apple part_gpt part_msdos
      reboot search search_fs_uuid test usb)
    # Encryption specific modules
    _modules+=(
      cryptodisk gcry_rijndael gcry_sha512
      luks2 password_pbkdf2)
    if [[ "${_mode}" != "pc" ]] && \
       [[ "${_mode}" != "pc-eltorito" ]]; then
        _modules+=(
          at_keyboard all_video btrfs cat echo
          diskfilter echo efifwsetup f2fs fat
          font gcry_crc gfxmenu gfxterm gzio
          hfsplus jpeg keylayouts ls lsefi
          lsefimmap lzopio ntfs png read regexp
          search_fs_file search_label serial sleep
          tpm trig usbserial_common usbserial_ftdi
          usbserial_pl2303 usbserial_usbdebug video
          xfs zstd)
    elif [[ "${_mode}" == "pc" ]] || \
         [[ "${_mode}" == "pc-eltorito" ]]; then
        _modules+=(biosdisk)
    fi
    echo "${_modules[*]}"
}

# Install bootloader configurations
# $1: install volume
# $2: destination directory path
#     in the volume
# $@: configuration files
_make_bootloader_config() {
    local _bootable="${1}" \
          _dest="${2}"
    shift
    local _cfgs=("${@}")
    local _tmp_cfg="$(_get "work" \
                           "dir")/bl_tmp.cfg"
    for _cfg in "${_cfgs[@]}"; do
        _gen_bootloader_config "${_cfg}" > \
          "${_tmp_cfg}"
        _install_cmd "${_bootable}" \
                     "${_tmp_cfg}" \
                     "${_dest}/${_cfg##*/}"
        rm "${_tmp_cfg}"
    done
}

# Produces a standalone GRUB binary
# $1: architecture (x86_64, i386)
# $2: platform (efi, pc)
# $3: output file or directory
#     default name: BOOT<IA32/X64>.EFI
_make_grub() {
    local _out="${1}"
    local _bootmode="${2}"
    local _cfg="$(_get "work" \
                       "dir")/grub.cfg" \
          _embed_cfg="$(_get "work" \
                             "dir")/grub-embed.cfg" \
          _grub_options=()
          _modules
    _modules="$(_get_grub_modules \
                    "$(_get_platform \
                           "${_bootmode}")")"
    _grub_options=(
      -O "$(_get_arch \
                "${_bootmode}")-$(_get_platform \
                                      "${_bootmode}")"
      --modules="${_modules}"
      --locales="en@quot"
      --themes=""
      --sbat=/usr/share/grub/sbat.csv
      --disable-shim-lock
      --compress=xz)
    [[ "$(_get_platform "${_bootmode}")" == "pc"* ]] && \
      _embed_cfg="${_cfg}" \
      _grub_options+=(
        --install-modules="${_modules}"
        --fonts="")
    [ -d "${_out}" ] && \
      _out="${_out}/BOOT$(_get_arch_CODE \
                              "${_bootmode}").$(_get_PLATFORM "${_bootmode}")"
    _run_once "_make_common_bootmode_grub_cfg"
    _grub_options+=(
      -o "${_out}")
    grub-mkstandalone "${_grub_options[@]}" \
                      "boot/grub/grub.cfg=${_embed_cfg}"
}

### SYSLINUX

## SYSLINUX install

# Install SYSLINUX on a volume
# $1: volume
_make_syslinux() {
    local _volume="${1}"
          _boot_loader="syslinux" \
          _root="pacstrap"
    _install_dir_cmd "${_volume}" \
                     "/${_boot_loader}"
    [[ -e "$(_get "profile" \
                  "dir")/${_boot_loader}/splash.png" ]] && \
      _install_cmd "${_volume}" \
                   "$(_get "profile" \
                           "dir")/${_boot_loader}/splash.png" \
                   "/${_boot_loader}"
    _install_cmd "${_volume}" \
                 "$(_get "${_root}" \
                         "dir")/usr/lib/${_boot_loader}/bios/"*.c32 \
                 "/${_boot_loader}"
    _install_cmd "${_volume}" \
                 "$(_get "${_root}" \
                         "dir")/usr/lib/${_boot_loader}/bios/lpxelinux.0" \
                 "/${_boot_loader}"
    _install_cmd "${_volume}" \
                 "$(_get "${_root}" \
                         "dir")/usr/lib/${_boot_loader}/bios/memdisk" \
                 "/${_boot_loader}"
    if [[ -e "$(_get "${_volume}" \
                     "dir")/${_boot_loader}/hdt.c32" ]]; then
        _install_dir_cmd "${_volume}" \
                         "/${_boot_loader}/hdt"
        [[ -e "$(_get "${_root}" \
                      "dir")/usr/share/hwdata/pci.ids" ]] && \
          gzip -cn9 "$(_get "${_root}" \
                            "dir")/usr/share/hwdata/pci.ids" > \
            "$(_get "${_volume}" \
                    "dir")/${_boot_loader}/hdt/pciids.gz"
        find "$(_get "${_root}" \
                     "dir")/usr/lib/modules" \
             -name 'modules.alias' \
             -print \
             -exec gzip \
             -cn9 '{}' ';' > \
          "$(_get "${_volume}" \
                  "dir")/${_boot_loader}/hdt/modalias.gz"
    fi
}

_make_systemd-boot_common() {
    local _bootable="${1}"
    _install_dir_cmd "${_bootable}" \
                     "/loader" \
    _install_cmd "${_bootable}" \
                 "${profile_dir}/efiboot/loader/loader.conf" \
                 "/loader"
}

###########################
# Kernel install functions
###########################

# Copy files in a volume corresponding to a query
# in the work directory to a directory in a
# destination volume
# $1: destination (bootable) volume
# $2: source volume
# $3: query
# $2: destination directory in the volume
_query_install() {
    local _bootable="${1}"\
          _volume="${2}"
          _query="${3}" \
          _dest="${4}" \
          _first="${5}" \
          _find_opts=() \
          _results=()
    _find_opts=(
      -iname "${_query}")
    [[ "${_first}" != "" ]] && \
    [[ "${_first}" == "true" ]] && \
      _find_opts+=(
        -exec echo {} \;
        -quit)
    _results=(
      $(find "$(_get "${_volume}" \
                      "dir")" \
             "${_find_opts}"))
     _install_cmd "${_bootable}" \
                  "${_results[@]}" \
                  "${_dest}"
}


# Install ucodes in a given volume at
# a given directory
# $1: volume (value in 'fs_images')
# $2: path of the boot directory in the volume
_make_ucodes() {
    local _bootable="${1}" \
          _boot_dir="${2}"
    local _first \
          _licenses_dest="${_boot_dir}/licenses" \
          _licenses_src="$(_get "pacstrap" \
                                "dir")/usr/share/licenses"
    [[ "${_volume}" == "efi_boot" ]] && \
      _first="true"
    for _ucode in "${ucodes[@]}"; do
        _query_install "${_bootable}" \
                       "work" \
                       "${_ucode}" \
                       "${_boot_dir}" \
                       "true"
        [[ -e "${_licenses_src}/${_ucode%.*}/" ]] && \
          _install_dir_cmd "${_bootable}" \
                           "${_licenses_dest}/${_ucode%.*}/" && \
          _install_cmd "${_bootable}" \
                       "${_licenses_src}/${_ucode%.*}/"* \
                       "${_licenses_dest}/${_ucode%.*}"
    done
}

# Copy kernel, microcodes and initramfs to a volume
# $1: volume on which to install the files
# $2: path of the boot directory in the volume
_make_kernel() {
    local _bootable="${1}"
          _boot_dir="/${install_dir}/boot"
    local _kernel_dir="${_boot_dir}/${arch}" \
          _image \
          _images=(
            "initramfs-*"
            "vmlinuz-*") \
          _msg=(
            "Preparing kernel and initramfs for the"
            "${_bootable} volume...")
    _msg_info "${_msg[*]}"
    _install_dir_cmd "${_bootable}" \
                     "/${install_dir}" \
                     "${_boot_dir}" \
                     "${_kernel_dir}"
    for _image in  "${_images[@]}"; do
        _query_install "${_bootable}" \
                       "work" \
                       "${_image}" \
                       "${_kernel_dir}"
    done
    _make_ucodes "${_bootable}" \
                 "${_boot_dir}"
    _msg_info "Done!"
}

# Copy kernel and initramfs to ISO 9660
_make_kernel_on_iso() {
    iso_dir="${work_dir}/iso"
    _make_kernel "iso"
    _make_kernel "persistent"
}

# Copy kernel and initramfs to dongle ISO 9660
_make_kernel_on_dongle_iso() {
    dongle_iso_dir="${work_dir}/dongle_iso"
    _make_kernel "dongle_iso"
    _make_kernel "dongle_boot"
    _make_kernel "dongle_persistent"
}

_make_kernel_on_isos() {
    if [[ "${_bootable}" == "iso" ]]; then
        _run_once _make_kernel_on_iso
        [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
          _run_once _make_kernel_on_dongle_iso
    elif [[ "${_bootable}" == "dongle" ]]; then
        _run_once _make_kernel_on_dongle_iso
    fi
}

##################################
# Bootmodes utility functions
#################################

# $1: (single character) separator
# $2: string to split
_split() {
    local _separator="${1}" \
          _string="${2}" \
          _array=()
    IFS="${_separator}" \
      read -ra \
           _array <<< \
        "${_string}" 
    echo "${_array[@]}"
}

_get_platformcode() {
    local _bootmode="${1}" \
          _array=()
    _array=(
      $(_split "." \
               "${_bootmode}"))
    echo "${_array[0]}"
}


_get_boot_loader() {
    local _bootmode="${1}" \
          _array=()
    _array=(
      $(_split "." \
               "${_bootmode}"))
    echo "${_array[1]}"
}

_get_boot_method() {
    local _bootmode="${1}" \
          _array=()
    _array=(
      $(_split "." \
               "${_bootmode}"))
    echo "${_array[2]}"
}

_get_platform() {
    local _bootmode="${1}" \
          _array=() \
    _array=(
      $(_split "-" \
               "$(_get_platformcode "${_bootmode}")"))
    _platform="${_array[0]}"
    [[ "${_platform}" == "uefi" ]] && \
      _platform="efi"
    [[ "${_platform}" == "bios" ]] && \
      _platform="pc" \
      [[ "$(_get_boot_method "${_bootmode}")" == "eltorito" ]] && \
        _platform="pc-eltorito"
    echo "${_platform}"
}

_get_arch_code() {
    local _bootmode="${1}" \
          _array=() \
          _code
    _array=(
      $(_split "-" \
               "$(_get_platformcode "${_bootmode}")"))
    _code="${_array[1]}"
    [[ "$(_get_platform "${_bootmode}")" == "bios" ]] && \
      _code="ia32" \
    echo "${_code}"
}

_get_arch_CODE() {
    local _bootmode="${1}" \
          _CODE="x64"
    [[ "$(_get_arch_code "${_bootmode}")" == "ia32" ]] || \
    [[ "$(_get_platform "${_bootmode}")" == "bios" ]] && \
       _CODE="IA32"
    echo "${_CODE}"
}

_get_PLATFORM() {
    local _PLATFORM="EFI"
    [[ "$(_get_platform "${_bootmode}")" == "bios" ]] && \
      _PLATFORM="MBR" \
      [[ "$(_get_boot_method "${_bootmode}")" == "eltorito" ]] && \
        _PLATFORM="ELTORITO"
    echo "${_PLATFORM}"
}

_get_arch() {
    local _bootmode="${1}" \
          _arch="x86_64" \
          _arch_code
    [[ "$(_get_arch_code "${_bootmode}")" == "ia32" ]] && \
      _arch="i386"
    [[ "$(_get_platform "${_bootmode}")" == "bios" ]] && \
      _arch="i386"
    echo "${_arch}"
}

_get_standalone_name() {
    echo "BOOT$(_get_CODE \
                    "${_bootmode}").$(_get_PLATFORM \
                                          "${_bootmode}")"
}

### GRUB

# Install GRUB configuration files on volume
# $1: volume on which to install grub configuration files
_make_common_bootmode_grub_cfg_install() {
    local _volume="${1}" \
          _boot_loader="grub" \
    _install_cmd "${_volume}" \
                 "$(_get_bl_cfg_files "work" \
                                      "${_boot_loader}")" \
                 "/EFI/BOOT"
}

# Copies GRUB files to dongle ISO file sysem
_make_common_bootmode_grub_cfg_iso() {
    _make_common_bootmode_grub_cfg_install "iso"
}

# Copies GRUB files to dongle ISO file system
_make_common_bootmode_grub_cfg_dongle_iso() {
    _make_common_bootmode_grub_cfg_install "dongle_iso"
}

# Copies GRUB files to ESP FAT image
_make_common_bootmode_grub_cfg_efi_boot() {
    _make_common_bootmode_grub_cfg_install "efi_boot"
}

## GRUB Eltorito

# Install GRUB Eltorito hybrid image
# $1: volume on which to install the loader
_make_grub_hybrid() {
    local _bootable="${1}"
    _install_dir_cmd "${_bootable}" \
                     "/EFI" \
                     "/EFI/BOOT"
    _install_cmd "${_bootable}" \
                 "${pacstrap_dir}/usr/lib/grub/i386-pc/boot_hybrid.img" \
                 "/EFI/BOOT"
}

### BIOS

## MEMTEST

# Install memtest86+ in a volume
# $1: destination volume
#     (a value in 'fs_images')
_make_memtest() {
    local _bootable="${1}" \
          _memtest="/boot/memtest86+/memtest.bin" \
          _gpl2
    _gpl2="/usr/share/licenses/common/GPL2/license.txt"
    [[ -e "${pacstrap_dir}${_memtest}" ]] && \
        # rename for PXE:
        # https://wiki.archlinux.org/title/Syslinux#Using_memtest
        _install_cmd "${_bootable}" \
                     "${pacstrap_dir}${_memtest}" \
                     "/${install_dir}/boot/memtest" && \
        _install_dir_cmd "${_bootable}" \
                         "/${install_dir}/boot/licenses/memtest86+" && \
        _install_cmd "${_bootable}" \
                     "${pacstrap_dir}${_gpl2}" \
                     "/${install_dir}/boot/licenses/memtest86+"
}

### UEFI

## EFI Shell

# Returns source path for the edk2 UEFI shell
# $1: efi architecture code (ia32, x64)
_get_efi_sh() {
    local _code="${1}" \
          _efi_sh
    _efi_sh="/usr/share/edk2-shell/${_code}/Shell_Full.efi"
    echo "${pacstrap_dir}${_efi_sh}"
}

# Install the edk2 UEFI shell on a volume
# $1: volume to install efi shell
#     (value in 'fs_images')
# $2: efi architecture code (ia32, x64)
_make_efi_sh() {
    local _volume="${1}" \
          _code="${2}"
    [[ -e "$(_get_efi_sh "${_code}")" ]] && \
      _install_cmd "${_volume}" \
                   "$(_get_efi_sh "${_code}")" \
                   "/shell${_code}.efi"
}

## Common functions

# Install a bootloader binary onto a volume
# $1: value in 'fs_images'
# $2: architecture code in UEFI format (ia32, x64)
# $3: extension representing the platform for which
#     the bootloader is targeted to (MBR, ELTORITO,
#     EFI)
# $4: source bootloader binary
_make_bl_standalone() {
    local _volume="${1}" \
          _bootmode="${2}"
    _install_dir_cmd "${_volume}" \
                     "/EFI"
                     "/EFI/BOOT"
    _install_cmd "${_volume}" \
                 "$(_get_boot_loader \
                        "${_bootmode}")" \
                 "/EFI/BOOT/$(_get_standalone_name \
                                  "${_bootmode}")"
}

# Common bootmode making routine
_make_common_bootmode() {
    local _bootmode="${1}"
    [[ "$(_get_boot_loader "${_bootmode}")" != "syslinux"* ]] && \
      _make_bl_standalone \
          "${_volume}" \
          "${_bootmode}"
    [[  "$(_get_platform "${_bootmode}")"  == "efi" ]] && \
      _make_efi_sh "${_volume}" \
                   "$(_get_code "${_bootmode}")"
    [[ "$(_get_boot_loader "${_bootmode}")" != "grub" ]] && \
      _make_bootloader_config \
          "${_volume}" \ 
          "/$(_get_bl \
                  "${_boot_loader}")/$(_get_bl_cfg \
                                           "${_boot_loader}")" \
          $(_get_bl_cfg_files "profile" \
                              "${_boot_loader}")
    [[ "$(_get_boot_loader "${_bootmode}")" == "grub" ]] && \
        [[ "$(_get_boot_method "${_bootmode}")" == "esp" ]] && \
      _run_once "_mkefi_boot" && \
      _run_once "_make_common_bootmode_$(_get_boot_loader \
                                             "${_bootmode}")_cfg_${_volume}"
}

##################################
# Bootmodes
##################################

#### Main callers

_sort_bootmodes() {
    local _bootmodes=("${@}") \
          _sorted=() 
    _sorted+=(
      $(_get_bootmodes_boot_method "mbr")
      $(_get_bootmodes_boot_method "esp")
      $(_get_bootmodes_boot_method "eltorito"))
    echo "${_sorted[@]}"
}

# Set up boot loaders
_make_bootmodes_iso() {
    local bootmode
    for bootmode in $(_sort_bootmodes "${bootmodes[@]}"); do
        _run_once "_make_bootmode_${bootmode}_iso"
    done
}

# Set up boot loaders
_make_bootmodes_dongle_iso() {
    local bootmode
    for bootmode in $(_sort_bootmodes "${bootmodes[@]}"); do
        _run_once "_make_bootmode_${bootmode}_dongle_iso"
    done
}

#### BIOS

### BIOS MBR

## GRUB BIOS MBR

_make_bootmode() {
    local _volume="${1}" \
          _msg=()
    _make_common_bootloader "${bootmode}"
    _msg=(
      "Setting up '${_boot_loader}' for '${_PLATFORM}' booting"
      "booting from a disk...")
}

# Prepares GRUB for booting from MBR (isohybrid)
_make_bootmode_bios.grub.mbr() {
    local _volume="${1}" \
          _msg=()
    _msg=(
      "Setting up '$(_get_boot_loader "${bootmode}")' for"
      "'$(_get_PLATFORM "${bootmode}")'"
      "booting from a disk...")
    _msg_info "${_msg[*]}"
    "_make_$(_get_boot_loader "${bootmode}")" \
        "$(_get "work" \
                "dir")"
        "${bootmode}"
    _make_common_bootmode "${bootmode}"
    _make_kernel_on_isos
    _msg=("Done! '$(_get_boot_loader "${bootmode}")'"
          "set up for '$(_get_PLATFORM "${_bootmode}")'"
          "booting from a disk successfully.")
    _msg_info "${_msg[*]}"
}

# Prepares GRUB for booting from MBR on the ISO
_make_bootmode_bios.grub.mbr_iso() {
    _make_bootmode_bios.grub.mbr "iso"
}

# Prepares GRUB for booting from MBR on the dongle ISO
_make_bootmode_bios.grub.mbr_dongle_iso() {
    _make_bootmode_bios.grub.mbr "dongle_iso"
}

## SYSLINUX BIOS MBR

# Prepares syslinux for booting from MBR (isohybrid)
# $1: volume on which to install syslinux
#     (value is fs_images)
# $2: device type (iso, dongle)
_make_bootmode_bios.syslinux.mbr() {
    local _volume="${1}" \
          _cfg_files=() \
          _msg=() \
    _cfg_files=(
      $(_get_bl_cfg_files \
            "profile" \
            "$(_get_boot_loader \
                   "${bootmode}")"))
    _msg=("Setting up '$(_get_boot_loader "${bootmode}")'"
          "for '$(_get_PLATFORM "${bootmode}")'"
          "booting from a disk...")
    _msg_info "${_msg[*]}"
    "_make_$(_get_boot_loader \
                 "${bootmode}")" \
        "${_volume}"
    _make_common_bootmode "${bootmode}"
    _make_kernel_on_isos
    _make_memtest "${_volume}"
    _msg=("Done! SYSLINUX set up for BIOS"
          "booting from a disk successfully.")
    _msg_info "${_msg[*]}"
}

# Prepares syslinux for booting from MBR on the ISO
_make_bootmode_bios.syslinux.mbr_iso() {
    _make_bootmode_bios.syslinux.mbr "iso"
}

# Prepares syslinux for booting from MBR on the ISO
_make_bootmode_bios.syslinux.mbr_dongle_iso() {
    _make_bootmode_bios.syslinux.mbr "dongle_iso"
}

### BIOS ELTORITO

## GRUB BIOS ELTORITO

# Prepares GRUB for El-Torito booting on BIOS systems
# $1: root file system for grub
_make_bootmode_bios.grub.eltorito() {
    local _volume="${1}" \
          _bl \
          _msg
    _make_common_bootloader "${bootmode}"
    # _bl="${work_dir}/BOOT${_CODE}.${_PLATFORM}" \
    _msg=("Setting up '${_boot_loader}' for '${_PLATFORM}' booting"
          "from an optical disc...")
    _msg_info "${_msg[*]}"
    _make_grub_hybrid "${_volume}"
    _make_grub "$(_get "work" \
                       "dir")"
    _make_common_bootmode
    _make_kernel_on_isos
}

# Prepares GRUB El Torito on BIOS for the ISO image
_make_bootmode_bios.grub.eltorito_iso() {
    _make_bootmode_bios.grub.eltorito "iso"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.grub.mbr_iso
}

# Prepares GRUB El Torito on BIOS for the dongle ISO image
_make_bootmode_bios.grub.eltorito_dongle_iso() {
    _make_bootmode_bios.grub.eltorito "dongle_iso"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.grub.mbr_dongle_iso
}

## SYSLINUX BIOS ELTORITO

# Prepares syslinux for El-Torito booting
# $1: volume on which to install syslinux
_make_bootmode_bios.syslinux.eltorito() {
    local _volume="${1}" \
          _root="pacstrap" \
          _msg=()
    _make_common_bootloader "${bootmode}"
    _msg=(
      "Setting up '${_boot_loader}' for '${_PLATFORM}'"
      "booting from an optical disc...")
    _msg_info "${_msg[*]}"
    _install_dir_cmd "${_volume}" \
                     "/${_boot_loader}"
    _install_cmd "${_volume}" \
                 "$(_get "${_root}" \
                         "dir")/usr/lib/${_boot_loader}/bios/isolinux.bin" \
                 "/${_boot_loader}"
    _install_cmd "${_volume}"
                 "$(_get "${_root}" \
                         "dir")/usr/lib/${_boot_loader}/bios/isohdpfx.bin" \
                 "/${_boot_loader}"
    _msg=(
      "Done! '${_boot_loader}' set up for '${_PLATFORM}' booting"
      "from an optical disc successfully.")
    _msg_info "${_msg[*]}"
}

# Prepares syslinux for El-Torito booting on BIOS on the ISO
_make_bootmode_bios.syslinux.eltorito_iso() {
    _make_bootmode_bios.syslinux.eltorito "iso"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.syslinux.mbr_iso
}

# Prepares syslinux for El-Torito booting on BIOS on the dongle ISO
_make_bootmode_bios.syslinux.eltorito_dongle_iso() {
    _make_bootmode_bios.syslinux.eltorito "dongle_iso"
    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.syslinux.mbr_dongle_iso
}

#### UEFI

### UEFI IA32

## GRUB UEFI IA32 ESP

# Prepares GRUB (32-bit) for EFI boot
# $1: device type ('iso', 'dongle')
_make_bootmode_uefi-ia32.grub.esp() {
    local _volume="${1}"
    _make_common_bootloader "${bootmode}"
    _make_grub "$(_get "work" \
                       "dir")"
    # Add GRUB to the list of files used to
    # calculate the required FAT image size.
    if [[ " ${bootmodes[*]} " =~ uefi-x64.systemd-boot.esp ]]; then
        _run_once "_make_bootmode_uefi-x64.systemd-boot.esp_${_bootable}"
    elif [[ " ${bootmodes[*]} " =~ uefi-x64.grub.esp ]]; then
        _run_once "_make_bootmode_uefi-x64.grub.esp_${_bootable}"
    else
        _run_once "_mkefi_boot"
    fi
    _make_common_bootmode
    _msg_info "Done! '${_boot_loader}' set up for '${_PLATFORM}' booting successfully."
}

# Prepares GRUB (32 bit) for UEFI the ISO image
_make_bootmode_uefi-ia32.grub.esp_iso() {
    _make_bootmode_uefi-ia32.grub.esp "iso"
}

# Prepares GRUB (32 bit) for UEFI the dongle ISO image
_make_bootmode_uefi-ia32.grub.esp_dongle_iso() {
    _make_bootmode_uefi-ia32.grub.esp "dongle_iso"
}

### UEFI IA32 ELTORITO

## GRUB UEFI IA32 ELTORITO

# Prepares GRUB (32 bit) for El Torito booting
# $1: root file system for GRUB
# $2: device type ('iso' or 'dongle')
_make_bootmode_uefi-ia32.grub.eltorito() {
    local _volume="${1}" \
          _bl \
          _msg=()
    _make_common_bootloader "${bootmode}"
    _bootmode="u${_platform}-${_code}.${_boot_loader}.esp_${_volume}"
    _run_once "_make_bootmode_${_bootmode}"
    _msg=(
      "Preparing an /EFI directory for"
      "the ISO 9660 file system...")
    _msg_info "${_msg[*]}"
    _make_common_bootmode
    _msg_info "Done!"
}

# Prepares GRUB (32 bit) El Torito for UEFI on the ISO image
_make_bootmode_uefi-ia32.grub.eltorito_iso() {
    _make_bootmode_uefi-ia32.grub.eltorito "iso"
}
 
# Prepares GRUB (32 bit) El Torito for UEFI on the dongle ISO image
_make_bootmode_uefi-ia32.grub.eltorito_dongle_iso() {
    _make_bootmode_uefi-ia32.grub.eltorito "dongle_iso"
}

#### UEFI x64

### UEFI x64 ESP

## GRUB UEFI x64 ESP

# Prepares GRUB for EFI boot
_make_bootmode_uefi-x64.grub.esp() {
    local _bl \
          _volume="efi_boot"
    _make_common_bootloader "${bootmode}"
    _make_grub "$(_get "work" \
                       "dir")"
    _run_once "_mk${_volume}"
    _make_common_bootmode
    _msg_info "Done! GRUB set up for UEFI booting successfully."
}
 
# Prepares GRUB for the ISO image
_make_bootmode_uefi-x64.grub.esp_iso() {
    _make_bootmode_uefi-x64.grub.esp
}

# Prepares GRUB for the dongle ISO image
_make_bootmode_uefi-x64.grub.esp_dongle_iso() {
    _make_bootmode_uefi-x64.grub.esp
}

## SYSTEMD-BOOT UEFI x64 ESP

_make_systemd-boot() {
    local _out="${1}" \
          _bl \
          _lib \
          _root \
          _systemd_boot \
    _lib="/usr/lib/systemd/boot"
    _root="pacstrap" \
    _systemd_boot="systemd-boot${_code}.${_platform}"
    _bl="$(_get "${_root}" \
                "dir")${_lib}/${_platform}/${_systemd_boot}"
    [ -d "${_out}" ] && \
      _out="${_out}/BOOT${_CODE}.${_PLATFORM}"
    cp "${_bl}" \
       "${_out}"
}

# Returns bootloader configuration files directory
_get_bl_cfg() {
    local _boot_loader="${1}" \
          _cfg_path
    [[ "${_boot_loader}" == "systemd-boot" ]] && \
      _cfg_path="entries"
    echo "${_cfg_path}"
}

# Get bootloader path in profile
# $1: boot loader
_get_bl() {
    local _volume="${1}" \
          _boot_loader="${2}" \
    [[ "${_boot_loader}" == "systemd-boot" ]] && \
      _boot_loader="efiboot/loader"
    echo "${_boot_loader}"
}

# Returns profile configuration files for a bootloader
_get_bl_cfg_files() {
    local _volume="${1}" \
          _boot_loader="${2}" \
          _path
    _path="$(_get_bl "${_boot_loader}")/$(_get_bl_cfg "${_boot_loader}")/"*".conf"
    echo "$(_get "${_volume}" \
                 "dir")/${_path}/"*".conf"
}

# Prepares systemd-boot for booting when written to a disk (isohybrid)
_make_bootmode_uefi-x64.systemd-boot.esp() {
    local _available_ucodes=() \
          _boot_loader="systemd-boot" \
          _bootable="efi_boot" \
          _cfg_files=() \
          _file \
          # _lib="/usr/lib/systemd/boot" \
          _results \
          _root="pacstrap"
          _systemd_boot \
    # _bl="${pacstrap_dir}${_lib}/${_platform}/${_systemd_boot}"
    _cfg_files=(
      $(_get_bl_cfg_files "profile" \
                          "${_boot_loader}"))
    _msg_info "Setting up systemd-boot for UEFI booting..."
    for _file in "${ucodes[@]}"; do
        [[ -e "$(_get "${_root}" \
                      "dir")/boot/${_file}" ]] && \
          _available_ucodes+=(
            "$(_get "${_root}" \
                    "dir")/boot/${_file}")
    done
    # Calculate the required FAT image size in bytes
    efi_boot_files+=(
      # "$(_get "profile" \
      #         "dir")/$(_get_bl "${_boot_loader}")/"
      "${_available_ucodes[@]}")
    _images=(
      "initramfs-*"
      "vmlinuz-*")
    for _query in "${_images[@]}"; do
        mapfile -t efi_boot_files < \
          <(find "$(_get "work" \
                         "dir")" \
                 -iname "${_query}" \
                 -exec echo {} \; \
                 -quit)
    done
    # Create a FAT image for the EFI system partition
    # _run_once "_mkefi_boot"
    # _make_systemd-boot_common "${_bootable}"
    # _install_dir_cmd "${_bootable}" \
    #                  "/${_cfg_path}"
    # _make_common_bootmode
    _make_kernel "${_bootable}"
    # _msg_info "Done! systemd-boot set up for UEFI booting successfully."
}

# Prepares systemd-boot for the ISO image
_make_bootmode_uefi-x64.systemd-boot.esp_iso() {
    _make_bootmode_uefi-x64.systemd-boot.esp
}

# Prepares systemd-boot for the dongle ISO image
_make_bootmode_uefi-x64.systemd-boot.esp_dongle() {
    _make_bootmode_uefi-x64.systemd-boot.esp
}

### UEFI x64 ELTORITO

## GRUB UEFI x64 ELTORITO

# Prepares GRUB for El Torito booting
# $1: root file system for GRUB
# $2: device type ('iso' or 'dongle')
_make_bootmode_uefi-x64.grub.eltorito() {
    local _bootable="${1}"\
          _bl \
    _make_common_bootloader "${bootmode}"
    _bl="${work_dir}/BOOT${_CODE}.${_PLATFORM}"
    # _run_once "_make_bootmode_uefi-${_code}.grub.esp_${_bootable}"
    # _run_once "_make_common_bootmode_grub_cfg"
    # _msg=(
    #   "Preparing an /EFI directory for"
    #   "the ISO 9660 file system...")
    # _msg_info "${_msg[*]}"
    # _make_common_bootmode "${bootmode}"
    # _run_once "_make_common_bootmode_grub_cfg_${_bootable}"
    # _msg_info "Done!"
}

# Prepares GRUB El Torito for UEFI on the ISO image
_make_bootmode_uefi-x64.grub.eltorito_iso() {
    _make_bootmode_uefi-x64.grub.eltorito "iso"
}

# Prepares GRUB El Torito for UEFI the dongle ISO image
_make_bootmode_uefi-x64.grub.eltorito_dongle_iso() {
    _make_bootmode_uefi-x64.grub.eltorito "dongle_iso"
}

## SYSTEMD-BOOT UEFI x64 ELTORITO

# Prepares systemd-boot for El Torito booting
_make_bootmode_uefi-x64.systemd-boot.eltorito() {
    local _bootable="${1}" \
          _bl \
          _cfg_path="loader/entries"
          _code="x64" \
          _PLATFORM="EFI" \
          _cfg_files=() \
          _msg=()
    _systemd_boot="/usr/lib/systemd/boot/efi/systemd-boot${_code}.efi"
    _bl="${pacstrap_dir}${_systemd_boot}"
    _cfg_files=(
      "${profile_dir}/efiboot/${_cfg_path}/"*".conf"
    # _run_once "_make_bootmode_uefi-${_code}.systemd-boot.esp_${_bootable}"
    # _msg=("Preparing an /EFI directory"
    #       "for the ISO 9660 file system...")
    # _msg_info "${_msg[*]}"
    # _make_systemd-boot_common "${_bootable}"
    # _install_dir_cmd "${_bootable}" \
    #                  "/${_cfg_path}"
    # _make_common_bootmode
    _msg_info "Done!"
}

# Prepares systemd-boot for El Torito booting on the ISO
_make_bootmode_uefi-x64.systemd-boot.eltorito_iso() {
    _make_bootmode_uefi-x64.systemd-boot.eltorito "iso"
}

# Prepares systemd-boot for El Torito booting on the dongle ISO
_make_bootmode_uefi-x64.systemd-boot.eltorito_dongle_iso() {
    _make_bootmode_uefi-x64.systemd-boot.eltorito "dongle_iso"
}

##################################
# File system validate functions
##################################

# Checks for a missing program and suggests to install a package
# $1: the command to check
# $2: package to install if the command is missing
_check_missing_cmd() {
    local _cmd="${1}" \
          _pkg="${2}"
          _msg=() \
    _msg=("Validating build mode '${_buildmode}':"
          "${_cmd} is not available on this host."
          "Install '${_pkg}'!")
    [[ "${_pkg}" == "" ]] && \
      _pkg="${_cmd}"
    ( ! command -v "${_cmd}" &> /dev/null ) && \
      (( validation_error=validation_error+1 )) \
      _msg_error "${_msg[*]}" 0
}

## File systems type support

# EROFS
_validate_requirements_image_type_erofs() {
    _check_missing_cmd "mkfs.erofs" "erofs-utils"
}

# EXT4
_validate_requirements_image_type_ext4() {
    _check_missing_cmd "mkfs.ext4" "e2fsprogs"
    _check_missing_cmd "tune2fs" "e2fsprogs"
}

# FAT
_validate_requirements_image_type_fat() {
    _check_missing_cmd "mkfs.fat" "dosfstools"
    _check_missing_cmd "mmd" "mtools"
}

# LUKS
_validate_requirements_image_type_luks() {
    _check_missing_cmd "cryptsetup"
}

# SQUASHFS
_validate_requirements_image_type_squashfs() {
    _check_missing_cmd "mksquashfs" "squashfs-tools"
}

##################################################
# Volumes file systems support validate functions
##################################################

### Airootfs

## Base image types

# EROFS airootfs
_validate_requirements_airootfs_image_type_erofs() {
    _validate_requirements_image_type_erofs
}

# EXT4 airootfs
_validate_requirements_airootfs_image_type_ext4() {
    _validate_requirements_image_type_ext4
}

# LUKS airootfs
_validate_requirements_airootfs_image_type_luks() {
    local _encryption_key \
          _key_auto
    _encryption_key="$(_get "airootfs" \
                            "encryption_key")"
    _key_auto="$(_get "airootfs" \
                      "encryption_key_auto")"
    _validate_requirements_image_type_luks
    [[ -n "${_encryption_key}" ]] && \
      _resolve_fs_encryption_key "airootfs" \
                                 "${_key_auto}"
}

# SQUASHFS airootfs
_validate_requirements_airootfs_image_type_squashfs() {
    _validate_requirements_image_type_squashfs
}

## 2-layered image types

# EROFS over LUKS airootfs
_validate_requirements_airootfs_image_type_erofs+luks() {
    _validate_requirements_image_type_luks
    _validate_requirements_image_type_erofs
}

# EXT4 over SQUASHFS airootfs
_validate_requirements_airootfs_image_type_ext4+squashfs() {
    _validate_requirements_image_type_ext4
    _validate_requirements_image_type_squashfs
}

# SQUASHFS over LUKS airootfs
_validate_requirements_airootfs_image_type_squashfs+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_airootfs_image_type_squashfs
}

## 3-layered image types

# EXT4 over SQUASHFS over LUKS airootfs
_validate_requirements_airootfs_image_type_ext4+squashfs+luks() {
    _validate_requirements_airootfs_image_type_luks
    _validate_requirements_image_type_squashfs
    _validate_requirements_image_type_ext4
}

### Persistent

## Base image types

# EXT4 persistent
_validate_requirements_persistent_image_type_ext4() {
    local _msg=() \
          _etc="${profile_dir}/airootfs/etc"
    local _ro_rule="${_etc}/udev/rules.d/98_persistent.rules"
    local _dongle_ro_rule="${_etc}/udev/rules.d/99_donglepersistent.rules"
    _validate_requirements_image_type_ext4
    if [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _msg=("Persistent image not encrypted."
              "Be sure not to put sensitive data"
              "on it and write the resulting image"
              "on a write-once device.")
        _msg_warning "${_msg[*]}"
    fi
    if [ ! -e "${_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg=("Validating '${persistent_image_type}' "
              "for persistent partition: udev rule not found!")
        _msg_error "${_msg[*]}" 0
    fi
    if [ ! -e "${_dongle_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg=("Validating '$(_get "dongle_persistent" \
                                  "image_type")' "
              "for dongle persistent partition: udev rule not found!")
        _msg_error "${_msg[*]}" 0
    fi
}

## 2-layered image types

# EXT4 over LUKS persistent
_validate_requirements_persistent_image_type_ext4+luks() {
    local _volume="persistent" \
          _msg=()
    "_validate_requirements_image_type_luks"
    "_validate_requirements_${_volume}_image_type_ext4"
    [ ! -e "$(_get_crypttab "profile")" ] && \
      (( validation_error=validation_error+1 )) \
      _msg=(
        "Validating '$(_get "${_volume}" \
                            "image_type")'"
        "for "${_volume}" partition:"
        "crypttab not found!") && \
      _msg_error "${_msg[*]}" 0
}

#######################################
# Bootmodes support validate functions
#######################################

## Common

# MBR
_validate_common_requirements_mbr() {
    [[ ]] \
    if [[ ! " ${bootmodes[*]} " =~ ' bios.grub.eltorito ' ]]; then
    if [[ ! " ${bootmodes[*]} " =~ ' bios.grub.eltorito ' ]]; then
}

# GRUB common
_validate_common_requirements_grub() {
    local _no_cfg_msg=() \
          _no_dir_msg=() \
          _no_cfgs_msg=() \
          _conf_file
    _no_cfg_mgs=(
      "Validating '${bootmode}':"
      "File '${profile_dir}/grub/grub.cfg' not found!")
    _no_dir_msg=(
      "Validating '${bootmode}':"
      "The '${profile_dir}/grub' directory is missing!")
    _no_cfgs_msg=(
      "Validating '${bootmode}':"
      "No configuration file found in '${profile_dir}/grub/'!"
    _check_missing_cmd "grub-mkstandalone" "grub"
    # Check if GRUB configuration files exist
    if [[ ! -d "${profile_dir}/grub" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "${_no_dir_msg[*]}" 0
    else
        [[ ! -e "${profile_dir}/grub/grub.cfg" ]] && \
          (( validation_error=validation_error+1 ))
          _msg_error "${_no_cfg_msg[*]}" 0
        for _conf_file in "${profile_dir}/grub/"*'.cfg'; do
            if [[ -e "${_conf_file}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "${_no_cfgs_msg[*]}" 0
            fi
        done
    fi
}

#### BIOS

### GRUB

# GRUB BIOS MBR
_validate_requirements_bootmode_bios.grub.mbr() {
    local _msg=()
    # bios.syslinux.mbr requires bios.grub.eltorito
    # actually I'm not sure this is true
    _validate_common_requirements_grub
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' bios.grub.eltorito ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg=("Using 'bios.grub.mbr' boot mode without"
              "'bios.grub.eltorito' is not supported.")
        _msg_error "${_msg[*]}" 0
    fi

    # Check if the grub package is in the package list
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' grub ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg=("Validating '${bootmode}':"
              "The 'grub' package is missing"
              "from the package list!")
        _msg_error "${_msg[*]}" 0
    fi
}

# GRUB BIOS ELTORITO
_validate_requirements_bootmode_bios.grub.eltorito() {
    # bios.grub.eltorito has the exact same requirements as bios.grub.mbr
    _validate_requirements_bootmode_bios.grub.mbr
}

### SYSLINUX

# SYSLINUX BIOS MBR
_validate_requirements_bootmode_bios.syslinux.mbr() {
    local _msg
    # bios.syslinux.mbr requires bios.syslinux.eltorito
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' bios.syslinux.eltorito ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg=(
          "Using 'bios.syslinux.mbr' boot mode"
          "without 'bios.syslinux.eltorito'"
          "is not supported.")
        _msg_error "${_msg[*]}" 0
    fi

    # Check if the syslinux package is in the package list
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' syslinux ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg=(
          "Validating '${bootmode}':"
          "The 'syslinux' package is missing"
          "from the package list!")
        _msg_error "${_msg[*]}" 0
    fi

    # Check if syslinux configuration files exist
    if [[ ! -d "${profile_dir}/syslinux" ]]; then
        (( validation_error=validation_error+1 ))
        _msg=(
          "Validating '${bootmode}':"
          "The '${profile_dir}/syslinux' directory is missing!")
        _msg_error "${_msg[*]}" 0
    else
        local cfgfile
        for cfgfile in "${profile_dir}/syslinux/"*'.cfg'; do
            if [[ -e "${cfgfile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg=(
                  "Validating '${bootmode}':"
                  "No configuration file found"
                  "in '${profile_dir}/syslinux/'!")
                _msg_error "${_msg[*]}" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' memtest86+ ' ]]; then
        _msg=("Validating '${bootmode}': 'memtest86+'"
              "is not in the package list."
              "Memory testing will not be available"
              "from syslinux.")
        _msg_info "${_msg[*]}"
    fi
}

# SYSLINUX BIOS ELTORITO
_validate_requirements_bootmode_bios.syslinux.eltorito() {
    # bios.syslinux.eltorito has the exact same requirements as bios.syslinux.mbr
    _validate_requirements_bootmode_bios.syslinux.mbr
}

#### UEFI

_validate_common_requirements_bootmode_uefi(){
    _validate_requirements_image_type_fat
}

### UEFI x64

# GRUB UEFI x64 ESP
_validate_requirements_bootmode_uefi-x64.grub.esp() {
    local _conflict_msg=() \
          _no_efi_shell_msg=()
    _conflict_msg=(
      "Validating '${bootmode}':"
      "cannot be used with bootmode"
      "uefi-x64.systemd-boot.esp!")
    _no_efi_shell_msg=(
      "'edk2-shell' is not in the package list."
      "The ISO will not contain a bootable UEFI shell.")
    _validate_common_requirements_bootmode_uefi
    _validate_common_requirements_grub
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]]; then
        _msg_error "${_conflict_msg[*]}" 0
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' edk2-shell ' ]]; then
        _msg_info "${_no_efi_shell_msg[*]}'"
    fi
}

# GRUB UEFI x64 ELTORITO
_validate_requirements_bootmode_uefi-x64.grub.eltorito() {
    local _msg=()
    _msg=(
      "Validating '${bootmode}': cannot be used with bootmode"
      "uefi-x64.systemd-boot.eltorito!")
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' ]]; then
        _msg_error "${_msg[*]}" 0
    fi
    # uefi-x64.grub.eltorito has the exact same requirements
    # as uefi-x64.grub.esp
    _validate_requirements_bootmode_uefi-x64.grub.esp
}

## SYSTEMD-BOOT

## SYSTEMD-BOOT UEFI x64 ESP
_validate_requirements_bootmode_uefi-x64.systemd-boot.esp() {
    local _msg=()
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]] && \
      _msg=(
        "Validating '${bootmode}':"
        "cannot be used with bootmode uefi-x64.grub.esp!") && \
      _msg_error "${_msg[*]}" 0

    _validate_common_requirements_bootmode_uefi

    # Check if systemd-boot configuration files exist
    if [[ ! -d "${profile_dir}/efiboot/loader/entries" ]]; then
        (( validation_error=validation_error+1 ))
        _msg=(
          "Validating '${bootmode}':"
          "The '${profile_dir}/efiboot/loader/entries'"
          "directory is missing!"
        _msg_error "${_msg[*]}" 0
    else
        [[ ! -e "${profile_dir}/efiboot/loader/loader.conf" ]] && \
          (( validation_error=validation_error+1 )) \
          _msg=(
            "Validating '${bootmode}':"
            "File '${profile_dir}/efiboot/loader/loader.conf'"
            "not found!") && \
          _msg_error "${_msg[*]}" 0
        local conffile
        for conffile in "${profile_dir}/efiboot/loader/entries/"*'.conf'; do
            if [[ -e "${conffile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg=(
                  "Validating '${bootmode}':"
                  "No configuration file found in"
                  "'${profile_dir}/efiboot/loader/entries/'!")
            _msg_error "${_msg[*]}" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' edk2-shell ' ]]; then
        _msg=(
          "'edk2-shell' is not in the package list."
          "The ISO will not contain a bootable UEFI shell.")
        _msg_info "${_msg[*]}"
    fi
}

# SYSTEMD-BOOT UEFI64 ELTORITO
_validate_requirements_bootmode_uefi-x64.systemd-boot.eltorito() {
    local _bootmode="uefi-x64.grub.eltorito"  \
          _msg=()
    _msg=("Validating '${bootmode}':"
          "cannot be used with bootmode"
          "${_bootmode}!")
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ " ${_bootmode} " ]]; then
        _msg_error "${_msg[*]}" 0
    fi

    # uefi-x64.systemd-boot.eltorito has the exact
    # same requirements as uefi-x64.systemd-boot.esp
    _validate_requirements_bootmode_uefi-x64.systemd-boot.esp
}

### UEFI IA32

# GRUB UEFI IA32 ESP
_validate_requirements_bootmode_uefi-ia32.grub.esp() {
    local _msg=()
    _msg=("Validating '${bootmode}': requires one of bootmode"
          "uefi-x64.systemd-boot.esp or uefi-x64.grub.esp")
    _validate_common_requirements_grub
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]]; then
        _validate_requirements_bootmode_uefi-x64.systemd-boot.esp
    elif [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]]; then
        _validate_requirements_bootmode_uefi-x64.grub.esp
    else
        # Please someone remembers me why 32-bit grub needs
        # a 64-bit bootmode enabled
        _msg_error "${_msg[*]}" 0
    fi
}

# GRUB UEFI IA32 ELTORITO
_validate_requirements_bootmode_uefi-ia32.grub.eltorito() {
    # uefi-ia32.grub.eltorito has the exact 
    # same requirements as uefi-ia32.grub.esp
    _validate_requirements_bootmode_uefi-ia32.grub.esp
}

# Fills templatized udev rules for the persistent partitions
# $1: template udev rule file
_make_rule_persistent() {
    local _template="${1}" \
          _sed_cmd
    # shellcheck disable=SC2154
    _sed_cmd='/%DONGLE_PERSISTENT_UUID%/d'
    [[ "${persistent_size}" != "" ]] && \
      _sed_cmd="s|%DONGLE_PERSISTENT_UUID%|${dongle_persistent_uuid}|g"
    sed -i "${_sed_cmd}" "${_template}"
    _sed_cmd='/%PERSISTENT_UUID%/d'
    [[ "${persistent_size}" != "" ]] && \
        _sed_cmd="s|%PERSISTENT_UUID%|${persistent_uuid}|g" \
    sed -i "${_sed_cmd}" "${_template}"
}

#################################
# Volume preparing functions
################################

# Gets max between two integers
_get_max() {
    local _a="${1}" \
          _b="${2}"
    echo $(( A > B ? \
             A : B ))
}

## Airootfs

# Builds airootfs filesystem image
_prepare_airootfs_image() {
    local _volume="airootfs" \
          _root="pacstrap" \
          _sig_dir
    "_set_${_volume}_size" "${_root}"
    _run_once "_mk${_volume}"
    _mkchecksum "$("_get_${_volume}_img")"
    [[ -n "${gpg_key}" ]] && \
      _mksignature "$("_get_${_volume}_img")" && \
      [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
        _set_volume_dir "dongle_iso" && \
        _set_volume_dir "dongle_persistent" && \
        _set_volume_dir "dongle_boot" && \
        _install_dir_cmd "dongle_iso" \
                         "${install_dir}/${arch}"
        _install_cmd "dongle_iso" \
                     "$("_get_${_volume}_img").sig" \
                     "/${install_dir}/${arch}"
}

_get_bootmodes_boot_method() {
    local _boot_method="${1}" \
          _bootmodes=()
    for _bootmode in "${bootmodes[@]}"; do
        [[ "${_bootmode}" == *"${_boot_method}" ]] && \
          _bootmodes+=(
            "${_bootmode}")
    done
    echo "${_bootmodes[@]}"
}

_prepare_efi_boot_image() {
    local _bootmode \
          _code \
          _boot_loader \
          _volume="efi_boot" \
          _root="pacstrap" \
          _bootmodes=()
    _bootmodes=(
      $(_get_bootmodes_boot_method "esp"))
    for _code in ('ia32'
                  'x64'); do
        [[ " ${_bootmodes[*]} " =~ ' '*"${_code}"*' ' ]] && \
          efi_boot_files+=(
            "$(_get_efi_sh "${_code}")"
    done
    [[ " ${_bootmodes[*]} " =~ ' '*'systemd-boot'*' ' ]] && \
      efi_boot_files+=(
        "$(_get "profile" \
                "dir")/$(_get_bl "systemd-boot")/loader.conf")
    [[ " ${_bootmodes[*]} " =~ ' '*'grub'*' ' ]] && \
      run_once "_make_common_bootmode_grub_cfg" && \
      efi_boot_files+=(
        $(_get_bl_cfg_files "work" \
                            "grub")
        $(_get_bl_cfg_files "profile" \
                            "grub"))
    for _bootmode in "${_bootmodes[@]}"; do
        _make_common_bootloader 
        "_make_${_boot_loader}" "$(_get "work" \
                                        "dir")"
        _bl="$(_get "work" \
                    "dir")/BOOT${_CODE}.${_PLATFORM}"
        efi_boot_files+=(
          "${_bl}")
    done
}

## Keys

# Builds keys filesystem image
_prepare_keys_image() {
    local _volume="keys"
    _set "${_volume}" \
         "size" \
         69420
    _run_once "_mk${_volume}"

    _mkchecksum "$("_get_${_volume}_img")"
    [[ -n "${gpg_key}" ]] \
      _mksignature "$("_get_${_volume}_img")"
}

## Persistent

# Build persistent filesystem image
_prepare_persistent_image() {
    local _volume="persistent" \
          _volume_rule \
          _dongle_volume_rule \
          _root="pacstrap" \
          _rules \
          persistent_dir_size
    _set "${_root}" \
          "dir" \
         "$(_get "work" \
                 "dir")/${arch}/airootfs" \
    _set_volume_dir "${_volume}"
    _set "${_volume}" \
         "epoch" \
         "$(_get_epoch "${_volume}")"
    _set "${_volume}" \
         "uuid" \
         "$(_get_epoch_fsuuid "$(_get "${_volume}" \
                                      "epoch")")"
    _set "dongle_${_volume}" \
         "uuid" \
         $("_get_dongle_${_volume}_uuid")
    if [ -d "${profile_dir}/${_volume}" ]; then
        _copy_profile_files "${_volume}" \
                            "${_volume}"
        _set "${_volume}_dir" \
             "size" \
             "$(_get_size "$(_get "${_volume}" \
                                  "dir")")"
        _set "${_volume}" \
             "size" \
             $(_get_max "$(_get "${_volume}_dir" \
                                "size")" \
                        "$(_get "${_volume}" \
                                "size")")
        _msg_info "Done!"
    fi
    _rules="$(_get "${_root}" \
                   "dir")/etc/udev/rules.d"
    _volume_rule="${_rules}/98_${_volume}.rules"
    _dongle_volume_rule="${_rules}/99_dongle${_volume}.rules"
    _make_crypttab "profile" \
                   "${_root}"
    "_make_rule_${_volume}" "${_volume_rule}"
    "_make_rule_${_volume}" "${_dongle_volume_rule}"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]] || \
       [ "$(_get "${_volume}" \
                 "size")" != "" ]; then
        _resolve_secondary_key "${_volume}"
        _run_once _make_kernel_on_dongle_iso
        _run_once "_mk${_volume}"
        if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
            [ "$(_get "dongle_${_volume}" \
                      "size")" = "" ] && \
              _set "dongle_${_volume}" \
                   "size" \
                   $(_get "${_volume}" \
                          "size")
            _run_once "_mkdongle_${_volume}"
        fi
    fi
}

## SWAP

# Builds swap filesystem image
_prepare_swap_image() {
    _volume="swap"
    [ "$(_get "${_volume}" \
                 "size")" != "" ] || \
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
        _resolve_secondary_key "${_volume}" && \
        _run_once "_mk${_volume}"
}

# Dongle boot

_prepare_dongle_boot_image() {
    local _volume="dongle_boot"
    if [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        dongle_boot_size=169042 # 169.042 MB
        _run_once "_mk${_volume}"
    fi
}

# Recovery

# Builds recovery filesystem image
_prepare_recovery_image() {
    local _main="airootfs"
    local _volume="recovery"
    local _root="pacstrap"
    # shellcheck disable=SC2154
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
    [[ "${recovery}" == "true" ]] && \
      if [ "$(_get "${_main}" \
                   "size")" = "" ]; then
          "_set_${_main}_size" "${_root}"
          set "${_volume}" \
              "size" \
              "$(_get "${_main}" \
                      "size")" &&
        _run_once "_mk${_volume}"
      fi && \
      _run_once "_mk${_volume}"
}

# Dongle boot

_prepare_dongle_boot_image() {
    _volume="dongle_boot"
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
        _set "dongle_boot" \
             "size" \
             169042 && \ # 169.042 MB
        _run_once "_mkdongle_boot"
}

# Dongle swap

# Builds dongle swap filesystem image
_prepare_dongle_swap_image() {
    local _volume="dongle_swap"
    if [ "$(_get "swap" \
                 "size")" != "" ] && \
       [[ " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _resolve_secondary_key "${_volume}"
        [[ "$(_get "${_volume}" \
                   "size")" == "" ]] && \
          _set "${_volume}" \
               "size" \
               "$(_get "swap" \
                       "size")"
        _run_once "_mk${_volume}"
    fi
}

# export build artifacts for netboot
_export_netboot_artifacts() {
    _msg_info "Exporting netboot artifacts..."
    install_dir_cmd "out"
                    "/"
    cp -a -- \
        "${iso_dir}/${install_dir}/" \
        "${out_dir}/"
    _msg_info "Done!"
    du -hs -- \
       "${out_dir}/${install_dir}"
}

# sign build artifacts for netboot
_sign_netboot_artifacts() {
    local _volume="iso" \
          _boot \
          _file \
          _files_to_sign=() \
          _openssl_options=()
    _openssl_options=()
      -sign
      -binary
      -noattr
      -signer "${cert_list[0]}"
      -inkey "${cert_list[1]}"
      -outform DER)
    _msg_info "Signing netboot artifacts..."
    _boot="$(_get "${_volume}" \
                  "dir")/${install_dir}/boot"
    for _file in "${ucodes[@]}"; do
        [[ -e "${_boot}/${_file}" ]] && \
          _files_to_sign+=("${_boot}/${_file}")
    done
    for _file in "${_files_to_sign[@]}" \
                 "${_boot}/${arch}/vmlinuz-"* \
                 "${_boot}/${arch}/initramfs-"*.img; do
        openssl cms "${openssl_options[@]}" \
                    -in "${_file}" \
                    -out "${_file}".ipxe.sig
    done
    _msg_info "Done!"
}

_validate_requirements_persistent_image_type_ext4() {
    local _msg=() \
          _etc="${profile_dir}/airootfs/etc"
    local _rules="${_etc}/udev/rules.d"
    local _ro_rule="${_rules}/98_persistent.rules"
    local _dongle_ro_rule="${_rules}/99_donglepersistent.rules"
    _validate_requirements_image_type_ext4
    if [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        _msg=("Persistent image not encrypted."
              "Be sure not to put sensitive data"
              "on it and write the resulting image"
              "on a write-once device.")
        _msg_warning "${_msg[*]}"
    fi
    if [ ! -e "${_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg=("Validating '${persistent_image_type}' "
              "for persistent partition: udev rule not found!")
        _msg_error "${_msg[*]}" 0
    fi
    if [ ! -e "${_dongle_ro_udev_rule}" ]; then
        (( validation_error=validation_error+1 ))
        _msg=("Validating '$(_get "dongle_persistent" \
                                  "image_type")' "
              "for dongle persistent partition: udev rule not found!")
        _msg_error "${_msg[*]}" 0
    fi
}

_validate_requirements_persistent_image_type_ext4+luks() {
    local _crypttab="${profile_dir}/airootfs/etc/crypttab" \
          _msg=()
    _validate_requirements_image_type_luks
    _validate_requirements_persistent_image_type_ext4
    [ ! -e "${_crypttab}" ] && \
      (( validation_error=validation_error+1 )) \
      _msg=("Validating '${persistent_image_type}'"
            "for persistent partition: crypttab not found!") && \
      _msg_error "${_msg[*]}" 0
}

### Buildmodes

_validate_common_requirements_buildmode_all() {
    local _msg=()
    _check_missing_cmd "pacman"
    _check_missing_cmd "find" "findutils"
    _check_missing_cmd "gzip"
    if [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]] && \
       [[ "$(_get "persistent" \
                  "image_type")" != *"luks" ]]; then
        _msg=("Validating build mode '${_buildmode}':"
              "'dongle' build mode not selected;"
              "persistent partition encryption disabled."
              "Be sure to use the resulting image on a write-once"
              "device to not be vulnerable to 'evil maids'.")
        _msg_warning "${_msg[*]}"
    fi
}

_validate_requirements_buildmode_bootstrap() {
    local bootstrap_pkg_list_from_file=() \
          _msg=() \
          _regexp='/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d'
    # Check if packages for the bootstrap image are specified
    if [[ -e "${bootstrap_packages}" ]]; then
        mapfile -t bootstrap_pkg_list_from_file < \
            <(sed "${_regexp}" "${bootstrap_packages}")
        bootstrap_pkg_list+=("${bootstrap_pkg_list_from_file[@]}")
        if (( ${#bootstrap_pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg=("No package specified in '${bootstrap_packages}'.")
            _msg_error "${_msg[*]}" 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg=("Bootstrap packages file '${bootstrap_packages}' "
              "does not exist.")
        _msg_error "${_msg[*]}" 0
    fi

    _validate_common_requirements_buildmode_all
    _check_missing_cmd "bsdtar" "libarchive"
}

# Check whether the specified file system type
# is supported for a given file system image
# $1: a value in fs_images
_validate_requirements() {
    local _action="${1}" \
          _object="${2}" \
          _value=${3} \
          _error_msg="${4}" \
          _validate_fun_error_msg="${5}"
    local _msg=() \
          _validate_fun
    _validate_fun="validate_requirements_${_object}_${_value}"
    if typeset -f "${_action}" &> \
         /dev/null; then
        if typeset -f "${_validate_fun}" &> /dev/null; then
            "${_validate_fun}"
        else
            _msg=("Function '${_validate_fun}' does not exist."
                  "${_validate_fun_error_msg}")
            _msg_warning "${_msg[*]}"
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "${_error_msg}" 0
    fi
}

# Check whether the specified file system type
# is supported for a given file system image
# $1: a value in fs_images
_validate_requirements_fs_image_type() {
    local _fs_image="${1}"
    local _error_msg \
          _image_type
          _validate_fun_error_msg=()
    _image_type="$(_get "${_fs_image}" \
                        "image_type")"
    _error_msg="Unsupported image type: '${_image_type}'"
    _validate_fun_error_msg=(
      "Validating the requirements"
      "of '${_image_type}' for ${_fs_image}"
      "image type will not be possible.")
    _validate_requirements "_mkimg_${_image_type}" \
                           "${_fs_image}_image_type" \
                           "${_image_type}" \
                           "${_error_msg}" \
                           "${_validate_fun_error_msg[*]}"
}

_validate_common_requirements_buildmode_iso_netboot() {
    local bootmode \
          pkg_list_from_file=() \
          _msg=() \
          _regexp='/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d'
    # Check if the package list file exists and read packages from it
    if [[ -e "${packages}" ]]; then
        mapfile -t pkg_list_from_file < <(sed "${_regexp}" "${packages}")
        pkg_list+=("${pkg_list_from_file[@]}")
        if (( ${#pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "No package specified in '${packages}'." 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Packages file '${packages}' does not exist." 0
    fi

    # Check if the specified airootfs_image_type is supported
    _validate_requirements_fs_image_type "airootfs"
}

_validate_requirements_buildmode_dongle() {
    _validate_common_requirements_buildmode_all
    _validate_requirements_image_type_luks
    [[ ! "${airootfs_image_type}" == *luks ]] && \
      _msg=("Dongle buildmode active but root file system "
            "encryption disabled.") && \
      _msg_warning "${_msg[*]}"
}

_validate_requirements_buildmode_iso() {
    local _error_msg \
          _msg=()
          _validate_fun_error_msg=()
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    # Check if the specified bootmodes are supported
    if (( ${#bootmodes[@]} < 1 )); then
        (( validation_error=validation_error+1 ))
        _msg=("No boot modes specified in"
              "'${profile_dir}/profiledef.sh'.")
        _msg_error "${_msg[*]}" 0
    fi
    for bootmode in "${bootmodes[@]}"; do
        _error_msg="${bootmode} is not a valid boot mode!"
        _validate_fun_error_msg=(
          "Validating the requirements of '${bootmode}' "
          "boot mode will not be possible.")
        _validate_requirements "make_bootmode_${bootmode}" \
                               "bootmode" \
                               "${bootmode}" \
                               "${_error_msg}" \
                               "${_validate_fun_error_msg[*]}"
    done

    _check_missing_cmd "awk"

    # Check if the profile supports
    # the specified persistent_image_type
    _validate_requirements_fs_image_type "persistent"
}

_validate_requirements_buildmode_netboot() {
    local _msg=() _override_cert_list=()

    if [[ "${sign_netboot_artifacts}" == "y" ]]; then
        # Check if the certificate files exist
        for _cert in "${cert_list[@]}"; do
            if [[ -e "${_cert}" ]]; then
                _override_cert_list+=(
                  "$(realpath -- "${_cert}")")
            else
                (( validation_error=validation_error+1 ))
                _msg_error "File '${_cert}' does not exist." 0
            fi
        done
        cert_list=("${_override_cert_list[@]}")
        # Check if there are at least two certificate files
        if (( ${#cert_list[@]} < 2 )); then
            (( validation_error=validation_error+1 ))
            _msg=("Two certificates are required for codesigning,"
                  "but '${cert_list[*]}' is provided.")
            _msg_error "${_msg[*]}" 0
        fi
    fi
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    _check_missing_cmd "openssl"
}

# Add boot partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_boot() {
    local _img _xorrisofs_options=("$@")
    boot_guid="${luks_guid}"
    _img="$(_get_volume_img boot)"
    [[ "${buildmode}" == "dongle" ]] && \
      _img="$(_get_volume_img dongle_boot)"
    _xorrisofs_options+=(
      '-append_partition' '3'
      "${boot_guid}"
      "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add recovery partition options to a
# xorrisofs options array
# $@: array
_add_xorrisofs_options_recovery() {
    local _img _xorrisofs_options=("$@")
    recovery_guid="${luks_guid}"
    _img="$(_get_volume_img recovery)"
    _xorrisofs_options+=(
      '-append_partition' '4'
      "${recovery_guid}"
      "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add swap partition options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_swap() {
    local _img _swap_guid _xorrisofs_options=("$@")
    _img="$(_get_volume_img swap)"
    _swap_guid="${swap_guid}"
    [[ "${swap_image_type}" == *"luks" ]] && \
      _swap_guid="${luks_guid}"
    _xorrisofs_options+=(
      '-append_partition' '5'
      "${_swap_guid}"
      "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add persistent partition options to a
# xorrisofs options array
# $@: array
_add_xorrisofs_options_persistent() {
    local _img _xorrisofs_options=("$@")
    persistent_guid="${linux_guid}"
    [[ "${persistent_image_type}" == *"luks" ]] && \
      persistent_guid="${luks_guid}"
    _img="$(_get_volume_img persistent)"
    [[ "${buildmode}" == "dongle" ]] && \
      _img="$(_get_volume_img dongle_persistent)"
    _xorrisofs_options+=(
      '-append_partition' '6'
      "${persistent_guid}"
      "${_img}")
    echo "${_xorrisofs_options[@]}"
}

# Add GRUB (isohybrid) options to a xorrisofs options array
# $1: root directory for the bootloader
# $@: xorrisofs_options array
_add_xorrisofs_options_bios.grub.mbr() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
      # SYSLINUX MBR bootstrap code; does not work
      # without "-eltorito-boot syslinux/isolinux.bin"
      '--grub2-mbr' "${bootable_dir}/EFI/BOOT/boot_hybrid.img"
      # When GPT is used, create an additional partition in the
      # MBR (besides 0xEE) for sectors 01 (MBR
      # bootstrap code area) and mark it as bootable
      # May allow booting on some systems
      # https://wiki.archlinux.org/title/Partitioning#Tricking_old_BIOS_into_booting_from_GPT
      '--mbr-force-bootable'
      # Move the first partition away from the start of the ISO
      # to match the expectations of partition editors
      # May allow booting on some systems
      # https://dev.lovelyhq.com/libburnia/libisoburn/src/branch/master/doc/partition_offset.wiki
      '-partition_offset' '16')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.grub.mbr_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.grub.mbr \
             "${iso_dir}" \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.grub.mbr_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.grub.mbr \
             "${dongle_iso_dir}" \
             "${dongle_xorrisofs_options[@]}")")
}

# Add GRUB El Torito options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_bios.grub.eltorito() {
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
      # El Torito boot image for x86 BIOS
      '-eltorito-boot' 'EFI/BOOT/BOOTIA32.ELTORITO'
      # El Torito boot catalog file
      '-eltorito-catalog' 'EFI/BOOT/boot.catalog'
      # Required options to boot with GRUB
      '-no-emul-boot'
      '-boot-load-size' '4'
      '-boot-info-table'
      '--grub2-boot-info')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.grub.eltorito_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.grub.eltorito \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.grub.eltorito_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.grub.eltorito \
             "${dongle_xorrisofs_options[@]}")")
}

# Add SYSLINUX MBR (isohybrid) options to a xorrisofs options array
# $1: root directory for the bootloader
# $@: options array
_add_xorrisofs_options_bios.syslinux.mbr() {
    local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
      # SYSLINUX MBR bootstrap code; does not work 
      # without "-eltorito-boot syslinux/isolinux.bin"
      '-isohybrid-mbr' "${bootable_dir}/syslinux/isohdpfx.bin"
      # When GPT is used, create an additional partition
      # in the MBR (besides 0xEE) for sectors 01 (MBR
      # bootstrap code area) and mark it as bootable
      # May allow booting on some systems
      # https://wiki.archlinux.org/title/Partitioning#Tricking_old_BIOS_into_booting_from_GPT
      '--mbr-force-bootable'
      # Move the first partition away from the start of
      # the ISO to match the expectations of partition editors
      # May allow booting on some systems
      # https://dev.lovelyhq.com/libburnia/libisoburn/src/branch/master/doc/partition_offset.wiki
      '-partition_offset' '16'
    )
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.syslinux.mbr_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.syslinux.mbr \
             "${iso_dir}" \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.syslinux.mbr_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.syslinux.mbr \
             "${dongle_iso_dir}" \
             "${dongle_xorrisofs_options[@]}")")
}

# Add SYSLINUX El Torito options to a xorrisofs options array
# $@: array
_add_xorrisofs_options_bios.syslinux.eltorito() {
    local _xorrisofs_options=("$@")
    _xorrisofs_options+=(
      # El Torito boot image for x86 BIOS
      '-eltorito-boot' 'syslinux/isolinux.bin'
      # El Torito boot catalog file
      '-eltorito-catalog' 'syslinux/boot.cat'
      # Required options to boot with ISOLINUX
      '-no-emul-boot' '-boot-load-size' '4' '-boot-info-table')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_bios.syslinux.eltorito_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.syslinux.eltorito \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_bios.syslinux.eltorito_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_bios.syslinux.eltorito \
             "${dongle_xorrisofs_options[@]}")")
}

# GRUB in an attached EFI system partition
_add_xorrisofs_options_uefi-ia32.grub.esp() {
    local _xorrisofs_options=("$@")
    # TODO: how does the bootmodes systemd-boot vs x64.grub affect 
    # ${bootmodes[*]} tests in
    # _add_xorrisofs_options_uefi-x64.systemd-boot.esp etc?
    # shellcheck disable=SC2076
    [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]] && \
    [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]] && \
      # _add_xorrisofs_options_uefi-x64.systemd-boot.esp
      _xorrisofs_options=(
        "$(_add_xorrisofs_options_uefi-x64.grub.esp \
               "${_xorrisofs_options[@]}")")
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-ia32.grub.esp_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-ia32.grub.esp \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-ia32.grub.esp_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-ia32.grub.esp \
             "${dongle_xorrisofs_options[@]}")")
}

# GRUB via El Torito
_add_xorrisofs_options_uefi-ia32.grub.eltorito() {
    local _bootable="${1}"
    shift
    local _xorrisofs_options=("$@")
    # shellcheck disable=SC2076
    [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' ]] && \
    [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.eltorito ' ]] && \
      _xorrisofs_options=(
        "$(_add_xorrisofs_options_uefi-x64.grub.eltorito \
               "${_bootable}"
               "${_xorrisofs_options[@]}")")
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-ia32.grub.eltorito_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-ia32.grub.eltorito \
             "iso" \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-ia32.grub.eltorito_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-ia32.grub.eltorito \
             "dongle_iso" \
             "${dongle_xorrisofs_options[@]}")")
}

# systemd-boot in an attached EFI system partition
_add_xorrisofs_options_uefi-x64.systemd-boot.esp() {
    local _opt _xorrisofs_options=("$@")
    # Move the first partition away from the start of the ISO,
    # otherwise the GPT will not be valid and ISO 9660
    # partition will not be mountable
    # shellcheck disable=SC2076
    [[ " ${_xorrisofs_options[*]} " =~ ' -partition_offset ' ]] || \
      _xorrisofs_options+=('-partition_offset' '16')
    # Attach efiboot.img as a second partition and set its 
    # partition type to "EFI system partition"
    _xorrisofs_options+=(
      '-append_partition' '2'
      'C12A7328-F81F-11D2-BA4B-00A0C93EC93B'
      "${efi_boot_img}")
    # Ensure GPT is used as some systems do not support 
    # UEFI booting without it
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # A valid GPT prevents BIOS booting on some systems, 
        # instead use an invalid GPT (without a protective MBR).
        # The attached partition will have the EFI system 
        # partition type code in MBR, but in the invalid GPT it will
        # have a Microsoft basic partition type code.
        if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' ]] && \
           [[ ! " ${bootmodes[*]} " =~ ' uefi-ia32.grub.eltorito ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the
            # appended EFI system partition will have the EFI system 
            # partition type ID/GUID in both MBR and GPT.
            # If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have the
            # Microsoft basic data type GUID in GPT.
            _opt="-isohybrid-gpt-basdat"
            [[ ! " ${_xorrisofs_options[*]} " =~ " ${_opt} " ]] && \
              _xorrisofs_options+=("${_opt}")
        fi
    else
        # Use valid GPT if BIOS booting support will not be required
        _xorrisofs_options+=('-appended_part_as_gpt')
    fi
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.systemd-boot.esp_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.systemd-boot.esp \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.systemd-boot.esp_dongle() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.systemd-boot.esp \
             "${dongle_xorrisofs_options[@]}")")
}

# systemd-boot via El Torito
_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito() {
    # local bootable_dir="${1}"
    local _bootable="${1}"
    shift
    local _xorrisofs_options=("$@")
    local _opt
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' uefi-ia32.grub.esp ' ]]; then
        # systemd-boot in an attached EFI system partition via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set the second partition as the El Torito UEFI boot image
          '-e' '--interval:appended_partition_2:all::'
          # Boot image is not emulating floppy or hard disk;
          # required for all known boot loaders
          '-no-emul-boot')
    # A valid GPT prevents BIOS booting on some systems,
    # use an invalid GPT instead.
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # If '-isohybrid-gpt-basdat' is specified before '-e',
        # then the appended EFI system partition will have the
        # EFI system partition type ID/GUID in both MBR and GPT.
        # If '-isohybrid-gpt-basdat' is specified after '-e',
        # the appended EFI system partition will have the 
        # Microsoft basic data type GUID in GPT.
        _opt="-isohybrid-gpt-basdat"
        [[ ! " ${_xorrisofs_options[*]} " =~ " ${_opt} " ]] && \
          _xorrisofs_options+=("${_opt}")
    fi
    else
        # The ISO will not contain a GPT partition table,
        # so to be able to reference efiboot.img, place it as a
        # file inside the ISO 9660 file system
        _install_dir_cmd "${_bootable}" \
                         "/EFI/archiso"
        _install_cmd "${_bootable}" \
                     "$(_get "efi_boot" \
                             "img")" \
                     "/EFI/archiso/efiboot.img"
        # systemd-boot in an embedded efiboot.img via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set efiboot.img as the El Torito UEFI boot image
          '-e' 'EFI/archiso/efiboot.img'
          # Boot image is not emulating floppy or hard disk;
          # required for all known boot loaders
          '-no-emul-boot')
    fi
    # Specify where to save the El Torito boot catalog
    # file in case it is not already set by bios.syslinux.eltorito
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' bios.' ]] || \
      _xorrisofs_options+=(
        '-eltorito-catalog' 'EFI/boot.cat')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito \
             "iso" \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito \
             "dongle_iso" \
             "${dongle_xorrisofs_options[@]}")")
}

# GRUB in an attached EFI system partition.
# Same as _add_xorrisofs_options_uefi-x64.systemd-boot.esp.
_add_xorrisofs_options_uefi-x64.grub.esp() {
    local _opt _xorrisofs_options=("$@")
    # Move the first partition away from the start of the ISO,
    # otherwise the GPT will not be valid and ISO 9660 partition
    # will not be mountable
    # shellcheck disable=SC2076
    [[ " ${_xorrisofs_options[*]} " =~ ' -partition_offset ' ]] || \
      _xorrisofs_options+=(
        '-partition_offset' '16')
    # Attach efiboot.img as a second partition and set its partition
    # type to "EFI system partition"
    _xorrisofs_options+=(
      '-append_partition' '2'
      'C12A7328-F81F-11D2-BA4B-00A0C93EC93B'
      "${efi_boot_img}")
    # Ensure GPT is used as some systems do not support UEFI booting without it
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # A valid GPT prevents BIOS booting on some systems, instead use
        # an invalid GPT (without a protective MBR).
        # The attached partition will have the EFI system partition type
        # code in MBR, but in the invalid GPT it will have a
        # Microsoft basic partition type code.
        if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.grub.eltorito ' ]] &&  \
           [[ ! " ${bootmodes[*]} " =~ ' uefi-ia32.grub.eltorito ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the
            # appended EFI system partition will have the EFI system 
            # partition type ID/GUID in both MBR and GPT.
            # If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have
            # the Microsoft basic data type GUID in GPT.
            _opt="-isohybrid-gpt-basdat"
            [[ ! " ${_xorrisofs_options[*]} " =~ " ${_opt} " ]] && \
              _xorrisofs_options+=("${_opt}")
        fi
    else
        # Use valid GPT if BIOS booting support will not be required
        _xorrisofs_options+=('-appended_part_as_gpt')
    fi
    echo "${_xorrisofs_options[@]}"
}
    
_add_xorrisofs_options_uefi-x64.grub.esp_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.grub.esp \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.grub.esp_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.grub.esp \
             "${dongle_xorrisofs_options[@]}")")
}

# GRUB via El Torito
# Same as _add_xorrisofs_options_uefi-x64.systemd-boot.eltorito.
_add_xorrisofs_options_uefi-x64.grub.eltorito() {
    local _bootable="${1}"
    # local bootable_dir="${1}"
    shift
    local _xorrisofs_options=("$@")
    local _opt
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.grub.esp ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' uefi-ia32.grub.esp ' ]]; then
        # grub in an attached EFI system partition via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set the second partition as the El Torito UEFI boot image
          '-e' '--interval:appended_partition_2:all::'
          # Boot image is not emulating floppy or hard disk;
          # required for all known boot loaders
          '-no-emul-boot'
        )
    # A valid GPT prevents BIOS booting on some systems,
    # use an invalid GPT instead.
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]] || \
       [[ " ${bootmodes[*]} " =~ ' bios.grub.mbr ' ]]; then
        # If '-isohybrid-gpt-basdat' is specified before '-e',
        # then the appended EFI system partition will have the
        # EFI system partition type ID/GUID in both MBR and GPT.
        # If '-isohybrid-gpt-basdat' is specified after '-e',
        # the appended EFI system partition will have the Microsoft
        # basic data type GUID in GPT.
        _opt="-isohybrid-gpt-basdat"
        [[ ! " ${_xorrisofs_options[*]} " =~ " ${_opt} " ]] && \
          _xorrisofs_options+=("${_opt}")
    fi
    else
        # The ISO will not contain a GPT partition table, so to be 
        # able to reference efiboot.img, place it as a
        # file inside the ISO 9660 file system
        _install_dir_cmd "${_bootable}" \
                         "/EFI/archiso"
        _install_cmd "${_bootable}"
                     "/EFI/archiso/efiboot.img"
        # grub in an embedded efiboot.img via El Torito
        _xorrisofs_options+=(
          # Start a new El Torito boot entry for UEFI
          '-eltorito-alt-boot'
          # Set efiboot.img as the El Torito UEFI boot image
          '-e' 'EFI/archiso/efiboot.img'
          # Boot image is not emulating floppy or hard disk;
          # required for all known boot loaders
          '-no-emul-boot'
        )
    fi
    # Specify where to save the El Torito boot catalog file in case 
    # it is not already set by bios.syslinux.eltorito
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' bios.' ]] || \
      _xorrisofs_options+=(
        '-eltorito-catalog'
        'EFI/boot.cat')
    echo "${_xorrisofs_options[@]}"
}

_add_xorrisofs_options_uefi-x64.grub.eltorito_iso() {
    xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.grub.eltorito \
             "iso" \
             "${xorrisofs_options[@]}")")
}

_add_xorrisofs_options_uefi-x64.grub.eltorito_dongle_iso() {
    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_uefi-x64.grub.eltorito \
             "dongle_iso" \
             "${dongle_xorrisofs_options[@]}")")
}

# Build bootstrap image
_build_bootstrap_image() {
    local _bootstrap_parent
    _bootstrap_parent="$(dirname -- "${pacstrap_dir}")"

    [[ -d "${out_dir}" ]] || \
      install -d -- "${out_dir}"

    cd -- "${_bootstrap_parent}"

    _msg_info "Creating bootstrap image..."
    bsdtar -cf - "root.${arch}" | \
        gzip -cn9 > "${out_dir}/${image_name}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"
    cd -- "${OLDPWD}"
}

# Builds dongle ISO image
_build_dongle_image() {
    local bootmode \
          dongle_xorriso_cmd_line \
          dongle_xorriso_options=() \
          dongle_xorrisofs_options=()
    dongle_iso_dir="${work_dir}/dongle_iso"

    # Add required xorrisofs options for each boot mode
    for bootmode in "${bootmodes[@]}"; do
        "_add_xorrisofs_options_${bootmode}_dongle" 
    done

    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_boot \
             "${dongle_xorrisofs_options[@]}")")

    [ "${persistent_size}" != "" ] && \
      dongle_xorrisofs_options=(
        "$(_add_xorrisofs_options_persistent \
               "${dongle_xorrisofs_options[@]}")")

    [ "${swap_size}" != "" ] && \
      dongle_xorrisofs_options=(
        "$(_add_xorrisofs_options_swap \
               "${dongle_xorrisofs_options[@]}")")

    dongle_xorrisofs_options=(
      "$(_add_xorrisofs_options_recovery \
             "${dongle_xorrisofs_options[@]}")")

    [[ -d "${out_dir}" ]] || \
      install -d -- "${out_dir}"

    [[ "${quiet}" == "y" ]] && \
      # The when xorriso is run in mkisofs compatibility mode (xorrisofs),
      # the mkisofs option -quiet is interpreted too late
      # (e.g. messages about SOURCE_DATE_EPOCH still get shown).
      # Instead use native xorriso option to silence the output.
      dongle_xorriso_options+=(
        '-report_about' 'SORRY'
        "${dongle_xorriso_options[@]}")

    # Update SORCE_DATE_EPOCH for dongle ISO UUID
    SOURCE_DATE_EPOCH="$(_get_epoch "dongle")"

    rm -f -- "${out_dir}/${image_name}"
    _msg_info "Creating ISO image..."
    _msg_info "xorriso options: ${dongle_xorriso_options[*]}"
    _msg_info "xorrisofs options: ${dongle_xorrisofs_options[*]}"
    # shellcheck disable=SC2116
    dongle_xorriso_cmd_line=(
      "${dongle_xorriso_options[@]}"
      '-as' 'mkisofs'
      '-iso-level' 3
      '-full-iso9660-filenames'
      '-joliet'
      '-joliet-long'
      '-rational-rock'
      '-volid' "$(_get_iso_partition_label "dongle")"
      '-appid' "\"${iso_application} dongle CD\""
      '-publisher' "\"${iso_publisher}\"" 
      '-preparer' "\"prepared by ${app_name}\""
      "${dongle_xorrisofs_options[@]}"
      '-output' "\"${out_dir}/${image_name}\""
      "${dongle_iso_dir}/")
    eval "xorriso ${dongle_xorriso_cmd_line[*]}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"
}

# Builds ISO image
_build_iso_image() {
    local xorriso_cmd_line
    iso_dir="${work_dir}/iso"
    local bootmode

    [[ -d "${out_dir}" ]] || \
      install -d -- "${out_dir}"

    [[ "${quiet}" == "y" ]] && \
      # The when xorriso is run in mkisofs compatibility mode (xorrisofs),
      # the mkisofs option -quiet is interpreted too late
      # (e.g. messages about SOURCE_DATE_EPOCH still get shown).
      # Instead use native xorriso option to silence the output.
      xorriso_options+=(
        '-report_about' 'SORRY'
        "${xorriso_options[@]}")

    # Add required xorrisofs options for each boot mode
    for bootmode in "${bootmodes[@]}"; do
        "_add_xorrisofs_options_${bootmode}_iso" 
    done

    [ "${persistent_size}" != "" ] && \
      xorrisofs_options=(
        "$(_add_xorrisofs_options_persistent \
               "${xorrisofs_options[@]}")")

    [ "${swap_size}" != "" ] && \
      xorrisofs_options=(
        "$(_add_xorrisofs_options_swap \
               "${xorrisofs_options[@]}")")

    rm -f -- "${out_dir}/${image_name}"
    # shellcheck disable=SC2116
    xorriso_cmd_line=(
      "${xorriso_options[@]}" '-as' 'mkisofs'
      '-iso-level' 3
      '-full-iso9660-filenames'
      '-joliet'
      '-joliet-long'
      '-rational-rock'
      '-volid' "${iso_label}"
      '-appid' "\"${iso_application}\""
      '-publisher' "\"${iso_publisher}\""
      '-preparer' "\"prepared by ${app_name}\""
      "${xorrisofs_options[@]}"
      '-output' "${out_dir}/${image_name}"
      "${iso_dir}/")
    _msg_info "Creating ISO image..."
    _msg_info "xorriso args: ${xorriso_cmd_line[*]}"
    eval "xorriso ${xorriso_cmd_line[*]}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"

    if [[ "$(_get "airootfs" \
                  "image_type")" == *"luks"* ]] && \
       [[ ! " ${buildmodes[*]} " =~ ' dongle ' ]]; then
        cp "$(_get "airootfs" \
                   "encryption_key")" \
           "${out_dir}"
        cp "${persistent_encryption_key}" \
           "${out_dir}"
    fi
}

# Read profile's values from profiledef.sh
_read_profile() {
    if [[ -z "${profile_dir}" ]]; then
        _msg_error "No profile specified!" 1
    fi
    if [[ ! -d "${profile_dir}" ]]; then
        _msg_error "Profile '${profile_dir}' does not exist!" 1
    elif [[ ! -e "${profile_dir}/profiledef.sh" ]]; then
        _msg_error "Profile '${profile_dir}' is missing 'profiledef.sh'!" 1
    else
        cd -- "${profile_dir}"

        # Source profile's variables
        # shellcheck source=configs/releng/profiledef.sh
        . "${profile_dir}/profiledef.sh"

        # Resolve paths of files that are expected to reside 
        # in the profile's directory
        [[ -n "$arch" ]] || \
          arch="$(uname -m)"
        [[ -n "$packages" ]] || \
          packages="${profile_dir}/packages.${arch}"
        packages="$(realpath -- "${packages}")"
        pacman_conf="$(realpath -- "${pacman_conf}")"

        # Resolve paths of files that may reside
        # in the profile's directory
        if [[ -z "$bootstrap_packages" ]] && \
           [[ -e "${profile_dir}/bootstrap_packages.${arch}" ]]; then
            bootstrap_packages="${profile_dir}/bootstrap_packages.${arch}"
            bootstrap_packages="$(realpath -- "${bootstrap_packages}")"
            pacman_conf="$(realpath -- "${pacman_conf}")"
        fi

        cd -- "${OLDPWD}"
    fi
}

# Validate set options
_validate_options() {
    local _buildmode \
          _msg=() \
          validation_error=0
    _msg_info "Validating options..."

    # Check if pacman configuration file exists
    if [[ ! -e "${pacman_conf}" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "File '${pacman_conf}' does not exist." 0
    fi

    # Check if the specified buildmodes are supported
    for _buildmode in "${buildmodes[@]}"; do
        _error_msg="${_buildmode} is not a valid build mode!"
        _validate_fun_error_msg=(
          "Validating the requirements of '${_buildmode}'"
          "build mode will not be possible.")
        _validate_requirements "build_buildmode_${_buildmode}" \
                               "buildmode" \
                               "${_buildmode}" \
                               "${_error_msg}" \
                               "${_validate_fun_error_msg}"
    done

    if (( validation_error )); then
        _msg=("${validation_error} errors were encountered while"
              "validating the profile. Aborting.")
        _msg_error "${_msg[*]}" 1
    fi
    _msg_info "Done!"
}

# Assign value to variable if empty
# $1: variable
# $2: value
_set_no_override() {
    local _var="${1}"
    local _value="${2}"
    ([[ "${!_var}" == "" ]] || \
     (! declare -p "${_var}" &> /dev/null)) && \
      printf -v "${_var}" "${_value}"
}

_set_override() {
    local _obj="${1}" \
          _var="${2}" \
          _default="${3}"
    if [[ -v "override_${_obj}_${_var}" ]]; then
        _set "${_obj}" \
             "${_var}" \
             "$(_get "override_${obj}" \
                     "${_var}")"
    elif [[ -z "$(_get "${_obj}" \
                       "${_var}")" ]]; then
        _set "${_obj}" \
             "${_var}" \
             "${_value}"
    fi
}

_override_path() {
    local _obj="${1}" \
          _var="${2}" \
          _value="${3}"
    _set_override "${_obj}" \
                  "${_var}" \
                  "${_value}"
    _set "${_obj}" \
         "${_var}" \
         "$(realpath -- "$(_get "${_obj}" \
                                "${_var}")")"
}

_override_volume() {
    local _volume="${1}"
    _override_path "${_volume}" \
                   "dir" \
                   "./${volume}"
}

# Set defaults and, if present, overrides
# from mkarchiso command line option parameters
_set_overrides() {
    local _img \
          _msg=() \
          _no_override_ciphered_volumes=() \
          _no_override_volumes=() \
          _var \
          _volume
    declare -A \
            _no_override_vars
    # Set variables that have command line overrides
    [[ ! -v override_buildmodes ]] || \
      buildmodes=(
        "${override_buildmodes[@]}")
    (( ${#buildmodes[@]} < 1 )) && \
      buildmodes+=(
        'iso')
    _override_volume "work"
    _override_volume "out"
    _override_path "pacman" \
                   "conf" \
                   "/etc/pacman.conf"
    [[ ! -v override_pkg_list ]] || \
      pkg_list+=(
        "${override_pkg_list[@]}")
    # TODO: allow overriding bootstrap_pkg_list
    _set_override "iso" \
                  "label" \
                  "${app_name^^}"
    _set_override "iso" \
                  "publisher" \
                  "${app_name}"
    _set_override "iso" \
                  "application" \
                  "${app_name} iso"
    _set_override "install" \
                  "dir" \
                  "${app_name}"
    if [[ -v override_quiet ]]; then
        quiet="$override_quiet"
    elif [[ -z "$quiet" ]]; then
        quiet="y"
    fi
    [[ ! -v override_gpg_key ]] || \
      gpg_key="${override_gpg_key}"
    [[ ! -v override_gpg_sender ]] || \
      gpg_sender="${override_gpg_sender}"
    [[ ! -v override_gpg_home ]] || \
      gpg_home="${override_gpg_home}"
    [[ -v override_cert_list ]] && \
      sign_netboot_artifacts="y"
    [[ ! -v override_cert_list ]] || \
      cert_list+=("${override_cert_list[@]}")
    if [[ -v override_quiet ]]; then
        quiet="$override_quiet"
    elif [[ -z "$quiet" ]]; then
        quiet="y"
    fi
    # Set variables that do not have overrides
    _set_volume_dir "iso"
    _set_volume_dir "dongle_iso"
    _encrypted_volumes=(
      "boot"
      "dongle_boot"
      "dongle_persistent"
      "dongle_swap"
      "keys"
      "persistent"
      "recovery"
      "swap")
    _no_override_volumes=(
      "${_no_encrypted_volumes[@]}"
      "efi_boot")
    _no_override_vars=(
      ["airootfs_image_type"]="squashfs"
      ["boot_image_type"]="ext4+luks"
      ["dongle_boot_image_type"]="ext4+luks"
      ["dongle_persistent_image_type"]="ext4+luks"
      ["dongle_swap_image_type"]="swap+luks"
      ["keys_image_type"]="squashfs+luks"
      ["persistent_image_type"]="ext4+luks"
      ["recovery_image_type"]="ext4+luks"
      ["swap_image_type"]="swap+luks"
      ["airootfs_encryption_key_auto"]="$(_get "work" \
                                               "dir")/$(_get "iso" \
                                                             "label").key"
      ["airootfs_dir"]="$(_get_airootfs_dir)"
      ["recovery"]="false"
      ["iso_name"]="${app_name}")
    for _volume in "${_encrypted_volumes[@]}"; do
        _msg=(
          "Setting ${_volume} encryption key to auto")
        _msg_info "${_msg[*]}"
        _no_override_vars["${_volume}_encryption_key"]="auto"
    done
    for _volume in "${_no_override_volumes[@]}"; do
        _msg=(
          "Setting ${_volume} image to"
          "'$(_get_volume_img ${_volume})'"
        _msg_info "${_msg[*]}"
        _no_override_vars["${_volume}_img"]="$(_get_volume_img \
                                                   "${_volume}")"
    done
    for _var in "${!_no_override_vars[@]}"; do
        _msg=(
          "Setting ${_var} to ${_no_override_vars[${_var}]}")
        _msg_info "${_msg[*]}"
        _set_no_override "${_var}" \
                         "${_no_override_vars[${_var}]}"
    done
}

_export_gpg_publickey() {
    local gpg_options=(
      --batch
      --no-armor
      --output "${work_dir}/pubkey.gpg"
      --export "${gpg_key}")

    rm -f -- "${work_dir}/pubkey.gpg"
    if [ "${gpg_home}" != "" ]; then
        gpg_options+=('--homedir' "${gpg_home}")
        GNUPGHOME="${gpg_home}" \
          gpg "${gpg_options[@]}"
    else
        gpg "${gpg_options[@]}"
    fi
}

# Builds the base for an ISO and/or a netboot target
_build_dongle_base() {
    local run_once_mode="base" \
          _sig_dir \
          _volume="dongle_iso"
    _setup_volume_dir "${_volume}"
    _setup_volume_dir "keys"
    _setup_volume_dir "dongle_boot"
    _setup_volume_dir "dongle_persistent"
    _setup_volume_dir "dongle_boot"
    _sig_dir="$(_get "${_volume}" \
                     "dir")/${install_dir}/${arch}"
    [ "$(_get "airootfs" \
              "encryption_key")" != "" ] && \
      cp "$(_get "airootfs" \
                 "encryption_key")" \
         "$(_get "keys" \
                 "dir")/airootfs.key"
    [[ "$(_get "airootfs" \
               "image_type")" == *"luks"* ]] && \
    [[ " ${buildmodes[*]} " =~ ' dongle ' ]] && \
      _run_once "_prepare_keys_image"
    _run_once "_make_kernel_on_${_volume}"
    "_make_bootmodes_${_volume}"
}

# Create working directory
# $1: value in fs_images
_setup_volume_dir() {
    local _volume="${1}"
    [[ "$(_get "${_volume}" \
               "dir")" == "" ]] && \
      _set_volume_dir "${_volume}"
    [[ -d "$(_get "${volume}" \
                  "dir")" ]] || \
      install_root_dir "$(_get "${_volume}" \
                               "dir")"
}

# Write build date to file or if the file exists,
# read it from there
_make_build_date() {
    if [[ -e "$(_get "work" \
                     "dir")/build_date" ]]; then
        SOURCE_DATE_EPOCH="$(<"$(_get "work" \
                                      "dir")/build_date")"
    else
        printf '%s\n' \
               "${SOURCE_DATE_EPOCH}" > \
          "$(_get "work" \
                  "dir")/build_date"
    fi
}

# build the base for an ISO and/or a netboot target
_build_iso_base() {
    local _volume="airootfs" \
          _root="pacstrap" \
          run_once_mode="base" \
          buildmode_packages="${packages}" \
          buildmode_pkg_list=("${pkg_list[@]}")
    # Set up essential directory paths
    _setup_volume_dir "iso"
    _setup_volume_dir "keys"
    _setup_volume_dir "persistent"
    _setup_volume_dir "dongle_persistent"
    _setup_volume_dir "dongle_boot"
    _set "${_root}" \
         "dir" \
         "$(_get "work" \
                 "dir")/${arch}/${_volume}"
    _set "${_volume}" \
         "dir" \
         "$(_get "iso" \
                 "dir")/$(_get "install" \
                               "dir")/${arch}"
    _setup_volume_dir "${_volume}"
    _make_build_date
    [[ "${quiet}" == "y" ]] || \
      _show_config
    _run_once _make_pacman_conf
    [[ -z "${gpg_key}" ]] || \
      _run_once _export_gpg_publickey
    _run_once "_make_custom_${_volume}"
    _run_once "_make_packages_${_volume}"
    _run_once "_make_version"
    _run_once "_make_customize_${_volume}"
    _run_once "_make_pkglist"
    _run_once "_prepare_persistent_image"
    _run_once "_prepare_swap_image"
    _run_once "_prepare_dongle_boot_image"
    _run_once "_prepare_dongle_swap_image"
    if [[ "${buildmode}" == 'netboot' ]]; then
        _run_once _make_kernel_on_iso
    else
        _make_bootmodes_iso
    fi
    _run_once "_cleanup_${_root}_dir"
    _run_once "_prepare_${_volume}_image"
    _run_once "_prepare_recovery_image"
}

_get_image_name() {
    local _buildmode="${1}" \
          _image_name=()
    _image_name=(
      "${iso_name}")
    [[ "${_buildmode}" != "iso" ]] && \
      _image_name+=(
        "${_buildmode}")
    _image_name+=(
      "${iso_version}"
      "${arch}")
    echo "$(IFS="-" ; \
            echo "${_image_name[*]}")"
}

# Build the bootstrap buildmode
_build_buildmode_bootstrap() {
    local _root="pacstrap" \
          buildmode_packages="${bootstrap_packages}" \
          # Set the package list to use
          buildmode_pkg_list=("${bootstrap_pkg_list[@]}") \
          image_name="$(_get_image_name "${bootstrap}").tar.gz" \
          run_once_mode="${buildmode}"
    # Set up essential directory paths
    _set "${_root}" \
         "dir" \
         "$(_get "work" \
                 "dir")/${arch}/${buildmode}/root.${arch}"
    
    [[ -d "$(_get "work" \
                  "dir")" ]] || \
      install -d -- \
              "$(_get "work" \
                      "dir")"
    _install_root_dir "$(_get "${_root}" \
                              "dir")"
    [[ "${quiet}" == "y" ]] || \
      _show_config
    _run_once "_make_pacman_conf"
    _run_once "_make_packages"
    _run_once "_make_version"
    _run_once "_make_pkglist"
    _run_once "_cleanup_${_root}_dir"
    _run_once "_build_${buildmode}_image"
}

# Build the netboot buildmode
_build_buildmode_netboot() {
    local run_once_mode="${buildmode}"
    _build_iso_base
    [[ -v cert_list ]] && \
      _run_once "_sign_${buildmode}_artifacts"
    _run_once "_export_${buildmode}_artifacts"
}

# Build the ISO buildmode
_build_buildmode_iso() {
    local image_name="$(_get_image_name "${buildmode}").iso" \
          run_once_mode="${buildmode}"
    _set "efi_boot" \
         "img" \
         "$(_get_volume_img "efi_boot")"
    "_build_${buildmode}_base"
    _run_once "_build_${buildmode}_image"
}

# Build the dongle ISO buildmode
_build_buildmode_dongle() {
    local image_name="$(_get_image_name "${buildmode}").iso" \
          run_once_mode="${buildmode}"
    _set "efi_boot" \
         "img" \
         "$(_get_volume_img "efi_boot")"
    "_build_${buildmode}_base"
    _run_once "_build_${buildmode}_image"
}

# build all buildmodes
_build() {
    local buildmode
    local run_once_mode="build"

    for buildmode in "${buildmodes[@]}"; do
        _run_once "_build_buildmode_${buildmode}"
    done
}

_read_symbols

while getopts 'c:p:C:L:P:A:D:w:m:o:g:G:H:vh?' arg; do
    case "${arg}" in
        p) read -r -a override_pkg_list <<< "${OPTARG}" ;;
        C) override_pacman_conf="${OPTARG}" ;;
        L) override_iso_label="${OPTARG}" ;;
        P) override_iso_publisher="${OPTARG}" ;;
        A) override_iso_application="${OPTARG}" ;;
        D) override_install_dir="${OPTARG}" ;;
        c) read -r -a override_cert_list <<< "${OPTARG}" ;;
        w) override_work_dir="${OPTARG}" ;;
        m) read -r -a override_buildmodes <<< "${OPTARG}" ;;
        o) override_out_dir="${OPTARG}" ;;
        g) override_gpg_key="${OPTARG}" ;;
        G) override_gpg_sender="${OPTARG}" ;;
        H) override_gpg_home="${OPTARG}" ;;
        v) override_quiet="n" ;;
        h|?) _usage 0 ;;
        *)
            _msg_error "Invalid argument '${arg}'" 0
            _usage 1
            ;;
    esac
done

shift $((OPTIND - 1))

if (( $# < 1 )); then
    _msg_error "No profile specified" 0
    _usage 1
fi

if (( EUID != 0 )); then
    _msg_error "${app_name} must be run as root." 1
fi

# get the absolute path representation of the first non-option argument
_set "profile" \
     "dir" \
     "$(realpath -- "${1}")"

_read_profile
_set_overrides
_validate_options
_build

# vim:ts=4:sw=4:et:
